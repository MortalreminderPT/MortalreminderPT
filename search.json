[
  
    {
      "title"    : "使用ChatGPT控制Arduino设备",
      "category" : "",
      "tags"     : "ChatGPT, Arduino, and 智能家庭",
      "url"      : "/2023/04/24/%E4%BD%BF%E7%94%A8ChatGPT%E6%8E%A7%E5%88%B6Arduino%E8%AE%BE%E5%A4%87/",
      "date"     : "Apr 24, 2023",
      "content"  : "这篇博客中将介绍如何使用ChatGPT来控制Arduino设备。ChatGPT是由OpenAI开发的一种自然语言处理模型，其强大的功能引发了很大的讨论。本文介绍了ChatGPT与外部系统集成的一种方法，通过ChatGPT作为控制器实现对Arduino设备的控制，以探索自然语言命令控制家庭设备的可能性及智能家庭设备的发展方向。这篇博客的代码公开在我的github仓库，点此链接传送至该项目。ChatGPT接入Prompt编写与测试我们期望ChatGPT以json格式输出命令实现对设备的控制，因此首先需要编写一个合适的提示（prompt），用于告诉ChatGPT我们的需求。在这个提示中，我们应该明确表达我们希望ChatGPT理解并回答的问题，如打开/关闭LED灯、控制电机转速等。经过数次测试之后，我们使用python代码整合了我们的全部需求，def generate_prompt(text):    possible_device = [        {            'light':'0 close,1 open'        },        {            'air-conditioner':'0 close,1 open'        },        {            'curtain': '0 close,1 open'        }    ]    prompt = f'As an Intelligent Assistant you need to rely on my words to determine what to do with some of devices.\n' \             f'{text}\n' \             f'your reply contain a list with json [device] only from these devices: {possible_device}' \             f' and only write json list without any discourse.'    return prompt在ChatGPT官网测试该提示词，发现ChatGPT可以正确理解我们的需求并做出回应。此时，我们相信ChatGPT可以集成到我们的项目中。OpenAI API接入OpenAI提供了官方API，以实现通过发送请求与ChatGPT进行实时交互。首先，我们需要获得OpenAI API的访问密钥。在OpenAI的开发者门户网站上可以注册一个账户并获取API密钥。将API密钥保存在安全的地方，因为它将用于与OpenAI API进行通信。接下来，我们可以通过引入OpenAI API包来实现与ChatGPT的交互，这个过程仍然被放在了一个函数中：def get_reply(prompt, mask = True, mask_reply = None):    if mask:        return json.dumps(mask_reply)    with open('OPENAI_API_KEY') as key:        openai.api_key = key.read().rstrip('\n')        completions = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {"role": "user", "content": prompt}            ],            temperature=0,            n=1,            max_tokens=100        )        message = completions.choices[0].message.content        return message执行代码并观察输出结果，发现我们成功与ChatGPT完成交互。In: As an Intelligent Assistant you need to rely on my words to determine what to do with some of devices.我很冷，你可以帮我些什么吗your reply contain a list with json [{"device":"device_1","param":0}] only from these devices: [{'light': '0 close,1 open'}, {'air-conditioner': '0 close,1 open'}, {'curtain': '0 close,1 open'}] and only write json list without any discourse.Out: [{"device":"air-conditioner","param":1}]基于Flask搭建服务器在上一部分中，我们完成了与ChatGPT的对话和集成。为了便于用户的使用及与Arduino的交互，我们将使用Flask框架搭建一个服务器，以通过网络实现交互。Flask框架搭建Flask是一个轻量级的Python Web框架，非常适合用于构建简单的Web应用程序。我们将使用Flask来搭建一个简单的服务器，以接收用户或Arduino的请求。首先，我们需要安装Flask。可以使用pip命令来安装Flask：pip install flask随后创建Flask主文件：from flask import Flaskimport flask_restful as restfulapp = Flask(__name__)api = restful.Api(app, default_mediatype="application/json")if __name__ == '__main__':    app.run()此时RESTful风格Flask框架已经搭建完成，我们需要为其添加用户及Arduino交互接口。添加用户API定义一个用户API文件order.py，用于向服务器发送请求并获取响应。核心代码如下所示：class OrderApi(Resource):    def post(self):        text_dict = RequestParser()\            .add_argument('text', type=str, location='json', required=True) \            .add_argument('device', type=str, location='json', required=False)\            .add_argument('param', type=float, location='json', required=False)\            .parse_args()                    mask_reply = []        if text_dict['device'] and text_dict['param'] is not None:            mask_reply.append({'device':text_dict['device'], 'param':text_dict['param']})        prompt=generate_prompt(text=text_dict['text'])        reply=get_reply(prompt=prompt,                        mask=False,                        mask_reply=mask_reply)        update_state=match_json(text=reply)        return device_states.update(update_state)随后我们需要在主文件中注册API文件：api.add_resource(OrderApi, '/')此时用户可以通过POST请求实现对Arduino设备状态的控制。Arduino APIArduino设备主要工作内容为读取当前设备工作状态并做出对应调整，因此只需编写简单GET请求响应：class ArduinoApi(Resource):    def get(self):        return device_states.get()同样在主文件中注册API文件：api.add_resource(ArduinoApi, '/arduino')通过Postman测试，发现可以服务器已经可以正常工作。使用MongoDB存储设备状态为了防止停电等因素对设备开关记忆的影响，我们使用数据库对设备状态进行持久化。MongoDB作为一种基于键值对的通用NoSQL数据库，非常适合实现这个需求。MongoDB数据库结构在我们开始之前，我们需要定义设备状态的数据结构。在这个例子中，我们假设我们的设备有一个LED灯，可以打开或关闭。我们可以使用以下JSON格式来表示设备状态：{    "device": "light",    "param": 1.0}在上面的示例中，device是设备的唯一标识符，param表示LED灯的状态。Flask接入MongoDB为了与MongoDB进行交互，我们将使用MongoDB的官方Python驱动程序pymongo。我们需要先安装它：pip install pymongo接下来，我们需要在Flask应用程序中添加与MongoDB的连接和数据访问逻辑。在app.py文件中添加pymongo库：from flask_pymongo import PyMongomongo = PyMongo(app, uri=config.MONGO_URI)与数据库的交互及数据缓存我们编写一个DeviceStates类与数据库进行交互，为了提升设备响应的即时性，我们还可以给数据库添加缓存。class DeviceStates(object):    def __init__(self):        self.state = {}        self._flash = False        pass    def get(self):        if not self._flash:            self._flash = True            for device_state in list(devices.find(projection = {'_id': 0})):                self.state[device_state['device']] = device_state        return self.state    def update(self, update_dict:DeviceState):        for update_device, update_state in update_dict.items():            devices.update_one({f'_id':update_device}, {'$set':{**update_state}}, upsert=True)            self.state[update_device] = update_state        return self.get()    def delete(self, all = True):        self.state = {}        return devices.delete_many({}).deleted_count编写QQbot实现QQ平台控制本节编写了一个简单的QQbot，用户可以在QQ平台与QQbot简单对话，完成对Arduino设备状态的控制。安装botpy包：pip install botpy为QQbot编写交互代码如下：import asyncioimport osimport botpyimport requestsfrom botpy import loggingfrom botpy.ext.cog_yaml import readfrom botpy.message import Messagetest_config = read(os.path.join(os.path.dirname(__file__), "config.yaml"))_log = logging.get_logger()headers = {    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8',    'content-type': 'application/json',}class MyClient(botpy.Client):    async def on_ready(self):        _log.info(f"robot 「{self.robot.name}」 on_ready!")    async def on_at_message_create(self, message: Message):        _log.info(message.author.avatar)        if "sleep" in message.content:            await asyncio.sleep(10)        _log.info(message.author.username)        url = test_config['server']        import re        text = re.sub('&lt;.*?&gt;', '', message.content)        data = {            'text': text,            'device': 'light',            'param': 1        }        response = requests.request("POST", url, headers=headers, json=data)        await message.reply(content=f"{response.content.decode('unicode_escape')}")if __name__ == "__main__":    intents = botpy.Intents(public_guild_messages=True)    client = MyClient(intents=intents)    client.run(appid=test_config["appid"], token=test_config["token"])此时，我们可以在QQ频道与QQbot对话，以实现对Arduino设备的控制Arduino状态控制在服务器及交互平台搭建完成后，本部分展示了Arduino设备代码实现，其原理主要为发出GET请求获取设备状态，随后通过字符串匹配控制设备的状态。Arduino设备代码实现这部分代码是由我的队友编写的，他速成了Arduino代码编写并实现了设备状态控制，感谢他在该项目的贡献。#include &lt;ESP8266WiFi.h&gt;#include &lt;SoftwareSerial.h&gt;#include &lt;ESP8266HTTPClient.h&gt;#include &lt;ArduinoJson.h&gt;const char * ssid; //Enter your Wi-Fi SSIDconst char * password; //Enter you Wi-Fi Passwordint i = 0;int check = 9;int ledpin = 2;String Payload = "";define URL "http://localhost:5000/arduino"void setup() {    WiFi.mode(WIFI_STA);    Serial.begin(115200);    pinMode(ledpin, OUTPUT);    digitalWrite(ledpin, 0);    Serial.println("开始连接");    WiFi.begin(ssid, password);    Serial.print("正在连接到");    Serial.print(ssid);    while (WiFi.status() != WL_CONNECTED) {        delay(1000);        Serial.print("waiting for ");        Serial.print(i++);        Serial.println("s...");    }    Serial.println("");    Serial.println("WiFi connected!");    Serial.print("IP address: ");    Serial.println(WiFi.localIP());}void loop() {    WiFiClient tcpClient;    HTTPClient httpClient;    httpClient.begin(tcpClient, URL);    Serial.print("URL: ");    Serial.println(URL);    int httpCode = httpClient.GET();    Serial.print("Send GET request to URL: ");    Serial.println(URL);    if (httpCode == 200) {        Payload = httpClient.getString();        Serial.print("\r\nServer Respose Code: ");        Serial.println(httpCode);        Serial.println("Server Response Payload: ");        Serial.println(Payload);    } else {        Serial.print("\r\nServer Respose Code: ");        Serial.println(httpCode);    }    httpClient.end();    StaticJsonDocument &lt; 200 &gt; doc;    DeserializationError error = deserializeJson(doc, Payload);    check = doc["light"]["param"];    Serial.print(check);    if (check == 1) {        digitalWrite(ledpin, HIGH);    }    if (check == 0) {        digitalWrite(ledpin, LOW);    }    Payload = "";    delay(10000);}结果展示如图所示，在向QQbot提出需求后，ChatGPT成功接收并理解了我们的需求并将其转化为指令，Arduino设备状态也随之发生改变。ChatGPT在此次实验中的强大作用向我们展示了大语言模型在智能家庭的重大潜力。包括但不限于识别并发掘深度需求，多模态智能家居控制，个性化用户体验等多种潜在方向。同样，该项应用也存在隐私保护，数据安全等问题，需要人们的进一步思考和解决。",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/04/24/%E4%BD%BF%E7%94%A8ChatGPT%E6%8E%A7%E5%88%B6Arduino%E8%AE%BE%E5%A4%87/'> <img src='/images/covers/acclerator1.jpg' alt='使用ChatGPT控制Arduino设备'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>11 min read <time class='article__date' datetime='2023-04-24T00:00:00+08:00'>Apr 24, 2023</time> </span> </div><h2 class='article__title'>使用ChatGPT控制Arduino设备</h2> <p class='article__excerpt'>aa</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/ChatGPT' class='article__tag'>ChatGPT</a>  <a href='/tag/Arduino' class='article__tag'>Arduino</a>  <a href='/tag/智能家庭' class='article__tag'>智能家庭</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "动态规划（三）股票问题系列",
      "category" : "",
      "tags"     : "算法 and 动态规划",
      "url"      : "/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 29, 2021",
      "content"  : "121. 买卖股票的最佳时机状态转移方程我们可以用$dp[i]$来表示，在前$i$日我们可以得到的最大利润，那么我们第$i$日的操作有两种选择：1.我们在第i日卖出得到的利润可能比之前的利润（dp[i-1]）更高2.我们之前的利润要比现在更高，不用进行任何操作对于情况1，我们得到状态转移方程$dp[i]=prices[i]-price_{min}$而对于情况2，我们有$dp[i]=dp[i-1]$综合两种情况，也就得到此题的状态转移方程：$dp[i]=max(dp[i-1],prices[i]-price_{min})$那么剩下的问题就在于如何表示$price_{min}$。如何表示$price_{min}$我们发现，$price_{min}$的计算也是一个无后效性的问题，我们同样可以通过动态规划来求解，用$dp_{price_{min}}[i]$来表示前i日股票的最低价格，则$dp_{price_{min}}[i]$的状态转移方程可以写成：$dp_{price_{min}}[i]$ = $min(prices[i],dp_{price_{min}}[i-1])$可能这时候你就要说了，你这不是脱了裤子放屁吗？那我们不妨换一个思维方式，还是上面的状态转移方程不变，我们用$dp[i][j]$表示前$i$天手上有$j$个股票时我们的最大利润。 这时候你不妨停下来思考一会，该如何写出状态转移方程呢？联立上面两个转移方程，得到$dp[i][j]$的状态转移方程：$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$$dp[i][1] = max(-prices[i], dp[i - 1][1]);$没错，此时的$dp[i][1]$就是之前我们的开销，用来辅助我们计算第$i$天的最大利润，也就是$dp[i][0]$边界条件$dp[0][0]$表示在第0天我们手上有0支股票时的最大利润，因此$dp[0][0]=0$$dp[0][1]$表示在第0天我们手上有1支股票时的最大利润，因此$dp[0][0]=-prices[0]$代码int maxProfit(vector&lt;int&gt;&amp; prices) {     const int MAX = 100100;     int dp[MAX][2];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)          dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]),         dp[i][1] = max(-prices[i], dp[i - 1][1]);     return dp[prices.size()-1][0];}篇幅关系，空间复杂度的优化留给读者自己思考，我这里不作展开122. 买卖股票的最佳时机 II状态转移方程122.题与121.题的不同点在于，122.是可以无限进行购买操作的，相应的，我们的状态转移方程也有所改变。根据我们第一题的状态转移方程，在第一题里，一但我们前面卖出了股票，下次再想购买股票时，总利润便会变成$-prices[i]$，但在这道题中，由于我们不再受购买次数的限制，因此我们的利润就可以一直累计下去，如何理解这种累计呢？在前$i-1$天，我们的最大利润达到了$dp[i-1][0]$，而在第$i$天我们要购入股票，此时的利润就会变为$dp[i-1][0]-prices[i]$即$dp[i][1]$的状态转移方程变为：$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$读者应该也注意到，在我们把状态转移方程分成两部分后，我们对转移方程的解读方式也转变了，这里我再次阐述一遍，$dp[i][0]$表示手上没有股票时的最大利润，$dp[i][1]$表示手上有一枚股票时的最大利润。综上，状态转移方程为：$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$边界条件与之前相同。代码int maxProfit(vector&lt;int&gt;&amp; prices) {     const int MAX = 100100;     int dp[MAX][2];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)         dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]),         dp[i][1] = max(dp[i - 1][0]-prices[i], dp[i - 1][1]);     return dp[prices.size()-1][0];}714. 买卖股票的最佳时机含手续费状态转移方程如果你认真阅读了题714.并理解了题122.那这道题你其实可以直接过的，因为这道题和题122.的不同之处就在于，它在售卖时多了手续费这个固定消耗，因此在决定卖出股票的第$i$天里，如果收益不足以抵消掉手续费，那我们会选择之前的利润作为最优解，即：$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$整体的转移方程表示为：$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$边界条件仍与之前相同代码int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {     const int MAX = 100100;     int dp[MAX][2];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)         dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee),         dp[i][1] = max(dp[i - 1][0]-prices[i], dp[i - 1][1]);     return dp[prices.size()-1][0];}309. 最佳买卖股票时机含冷冻期状态转移方程这道题的变化在于，之前我们只有$(0)$卖出、$(1)$买入两种状态，但这道题引入了一个新的新的状态$(2)$冷冻期，而这个冷冻期状态是在卖出操作后出现，如果我们用$dp[i][2]$来表示当我们在第$i$天的冷冻期收益，则$dp[i][2]$可以用$dp$表示为：$dp[i][2] = dp[i-1][0]$买入状态的转移方程也有所变化，因为此题中买入状态必须由冷冻期状态进入，也就是：$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$最后，综合三式就可以得到我们新的状态转移方程：$dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])$$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$$dp[i][2] = dp[i - 1][0]$边界条件仍然不变代码int maxProfit(vector&lt;int&gt;&amp; prices) {     const int MAX = 100100;     int dp[MAX][3];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)         dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]),         dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1]), //         dp[i][2] = dp[i - 1][0];     return dp[prices.size()-1][0];}123. 买卖股票的最佳时机 III思路如果没有前面的铺垫直接来看这道题，难度瞬间就高起来了。但现在带着前面的经验再来对比这道题，我们会发现这道题和题121. 题122.有着很大的关联。假设在第$i$天卖出了股票，当我们是第一次或第二次操作时，我们的利润是可以积累的。但如果是在第三次操作，那么我们就要重新累计利润了。我们不妨将$dp$升到三维数组，用第三维来区分第一次操作和第二次操作，即得到代码如下：代码int maxProfit(vector&lt;int&gt;&amp; prices) {    const int MAX = 100100;    int dp[MAX][2][2];    dp[0][1][1] = dp[0][1][0] = -prices[0];    for (int i = 1; i &lt; prices.size(); i++){        dp[i][0][0] = max(dp[i - 1][0][0], dp[i - 1][1][0] + prices[i]),        dp[i][1][0] = max(-prices[i], dp[i - 1][1][0]);        dp[i][0][1] = max(dp[i - 1][0][1], dp[i - 1][1][1] + prices[i]),        dp[i][1][1] = max(dp[i - 1][0][0]-prices[i], dp[i - 1][1][1]);    }    return dp[prices.size()-1][0][1];}这个代码并不优雅，但对于问题的解决无疑是直接而有效的188. 买卖股票的最佳时机 IV当问题扩充到$k$时，我们解决题123.的思路仍然有效，我们可以用初始化边界为$0$，再用一个$for$循环写出结果。 int maxProfit(int k, vector&lt;int&gt;&amp; prices) {    if(prices.empty()) return NULL;    const int MAX = 1100;    int dp[MAX][2][110]={0};    for(int j = 0; j &lt;= k; j++) dp[0][1][j] = -prices[0];    for(int i = 1; i &lt; prices.size(); i++)        for(int  j = 1; j &lt;= k ; j++)            dp[i][0][j] = max(dp[i-1][1][j] + prices[i], dp[i-1][0][j]),            dp[i][1][j] = max(dp[i-1][0][j-1] - prices[i], dp[i-1][1][j]);    return dp[prices.size()-1][0][k]; }股票问题的一般通解状态转移方程股票问题的三个限定条件是  当前天数$i$  手持股票$j$  允许的最大操作次数$k$我们设在第$i$天，手持股票为$j$，操作次数为$k$时我们的利润为$dp[i][j][k]$，视每次购买股票为进行一次操作，则我们的状态转移方程为：$dp[i][0][k] = max(dp[i-1][1][k] + prices[i], dp[i-1][0][k])$$dp[i][1][k] = max(dp[i-1][0][k-1] - prices[i], dp[i-1][1][k])$边界条件$dp[0][1][k] = -prices[0]$其余值都为0结束语股票问题系列和打家劫舍系列的不同点在于，股票问题的每一个系列问题都对状态转移方程进行了改动。面临一道动态规划问题时，要想迅速找到子问题并写出状态转移方程，关键还是要多了解不同的动归题型。",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/'> <img src='/images/covers/acclerator1.jpg' alt='动态规划（三）股票问题系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2021-09-29T20:29:46+08:00'>Sep 29, 2021</time> </span> </div><h2 class='article__title'>动态规划（三）股票问题系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "二叉树基础（一）二叉树的概念",
      "category" : "",
      "tags"     : "数据结构 and 二叉树",
      "url"      : "/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/",
      "date"     : "Sep 28, 2021",
      "content"  : "概念二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。二叉树的定义二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树基本形态  空二叉树  只有一个根节点的二叉树  根节点只有左子树的二叉树  根节点只有右子树的二叉树  根节点既有左子树，又有右子树的完全二叉树    特殊类型    满二叉树：只有度为0和2的节点，且度为0的结点在同一层上  完全二叉树：深度为k且每一个节点都与深度为k的满二叉树中编号从1到n的结点一一对应    相关术语    节点：包含一个数据元素及若干指向子树分支的信息  节点的度：一个节点拥有子树的数目  叶节点：也称为终端节点，没有子树的节点或度为0的节点  分支节点：也称为非终端节点，度不为0的节点  树的度：树中所有节点度的最大值  节点的层次：从根节点开始，根节点为第0层，根节点的子节点为第1层，依此类推  树的深度：也称树的高度，树中所有节点层次的最大值  有序树：如果树中各棵子树的次序有先后次序，则该树为有序树  无序树：如果树中各棵子树的次序没有先后次序，则该树为无序树  森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根结点删除，则该树就变成了一片森林，森林中的树由原来根结点的各棵子树构成    性质    一棵二叉树的第i层最多有$2^i$个节点 $(i≥0)$  深度为k的二叉树最多有$2^{k+1}-1$个节点 $(k≥0)$  对于1棵二叉树，度为0的节点为$n_0$，度为2的节点为$n_2$，则$n_0=n_2+1$  满二叉树定理：非空满二叉树的叶子节点数等于分支节点数$+1$  满二叉树定理推论：在一棵具有$n$个结点的二叉树中,所有结点的空子树等于$n+1$  $n$个节点的完全二叉树高度为$log_2(n+1)$，深度为$log_2(n+1)-1$二叉树的C++实现二叉树的顺序存储我们可以使用一个数组来存储所有的节点，按数组下标进行存储，根节点存储在下标\(0\)处，其左孩子存储于下标\(2*0+1\)，右孩子存储于下标\(2*0+2\)….依此类推，对于下标为\(i\)的节点，左右孩子分别存储于下标为\({2*i+1}\)和\({2*i+2}\)处。实现代码typedef int BinaryTree[MAX];void CreateBinaryTree(BinaryTree tree, int i) {    if (i &gt;= MAX) return;    int input;    cin &gt;&gt; tree[i];    CreateBinaryTree(tree,2*i+1);    CreateBinaryTree(tree,2*i+2);}二叉树的链式存储二叉树的顺序存储结构一般适用于完全二叉树，通常我们使用链式存储结构表示二叉树。实现代码typedef struct Node {    int data;                     // 数据    struct Node *lchild, *rchild; // 左右子树} * BinaryTree, BtNode;void CreateBinaryTree(BinaryTree &amp;tree) {    int input;    cin &gt;&gt; input;    if (input == -1) {        tree = NULL;        return;    }    tree = new BtNode;    tree-&gt;data = input;    CreateBinaryTree(tree-&gt;lchild);    CreateBinaryTree(tree-&gt;rchild);}二叉树的递归遍历先序遍历（DLR）若二叉树为空，则空操作，否则：  访问当前节点  先序遍历左子树  先序遍历右子树void DLR(BinaryTree tree) {    if (tree) {        cout &lt;&lt; tree-&gt;data &lt;&lt; endl;        DLR(tree-&gt;lchild);        DLR(tree-&gt;rchild);    }}中序遍历（LDR）若二叉树为空，则空操作，否则：  中序遍历左子树  访问当前节点  中序遍历右子树void LDR(BinaryTree tree) {    if (tree) {        LDR(tree-&gt;lchild);        cout &lt;&lt; tree-&gt;data &lt;&lt; endl;        LDR(tree-&gt;rchild);    }}后序遍历（LRD）若二叉树为空，则空操作，否则：  后序遍历左子树  后序遍历右子树  访问当前节点void LRD(BinaryTree tree) {    if (tree) {        LRD(tree-&gt;lchild);        LRD(tree-&gt;rchild);        cout &lt;&lt; tree-&gt;data &lt;&lt; endl;    }}",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/'> <img src='/images/covers/blackrock2.jpg' alt='二叉树基础（一）二叉树的概念'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2021-09-28T13:58:19+08:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（一）二叉树的概念</h2> <p class='article__excerpt'>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/tag/二叉树' class='article__tag'>二叉树</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "动态规划（二）最优子序列系列",
      "category" : "",
      "tags"     : "算法 and 动态规划",
      "url"      : "/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 28, 2021",
      "content"  : "动态规划核心思想动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。我们可以举个例子：  A: 1+1+1+1+1+1+1+1 = ?  B ( 计算 ) : 8  A: 在上面等式的左边写上 “1+” 呢？  B (脱口而出): 9  A: 你怎么这么快就得到答案了？  B: 只要在8的基础上加1就好了  A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间198. 打家劫舍  只有一间房屋时，我们选择偷这间房屋  存在两间房屋时，选择偷两间中较大的那间  如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间  将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：          偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和      不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额      我们总会选择1、2中可以得到更高金额的选项，这时我们用$d[i]$来表示偷窃前i间房子的总金额，并且用$d[i]$来表示选项1、2:\[\begin{equation}\left\{\begin{aligned}%\nonumber&amp;d[i] = d[i-2] + nums[i], \\&amp;d[i] = d[i-1].\end{aligned}\right.\end{equation}\]hello",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/'> <img src='/images/covers/mentalout1.jpg' alt='动态规划（二）最优子序列系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-28T11:12:38+08:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>动态规划（二）最优子序列系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "动态规划（一）打家劫舍系列",
      "category" : "",
      "tags"     : "算法 and 动态规划",
      "url"      : "/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 27, 2021",
      "content"  : "动态规划核心思想动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。我们可以举个例子：  A: 1+1+1+1+1+1+1+1 = ?  B ( 计算 ) : 8  A: 在上面等式的左边写上 “1+” 呢？  B (脱口而出): 9  A: 你怎么这么快就得到答案了？  B: 只要在8的基础上加1就好了  A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间198. 打家劫舍  只有一间房屋时，我们选择偷这间房屋  存在两间房屋时，选择偷两间中较大的那间  如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间  将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：          偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和      不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额      我们总会选择1、2中可以得到更高金额的选项，这时我们用$d[i]$来表示偷窃前i间房子的总金额，并且用$d[i]$来表示选项1、2:\[\begin{equation}\left\{\begin{aligned}%\nonumber&amp;d[i] = d[i-2] + nums[i], \\&amp;d[i] = d[i-1].\end{aligned}\right.\end{equation}\]hello",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/'> <img src='/images/covers/blackrock1.jpg' alt='动态规划（一）打家劫舍系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-27T20:12:45+08:00'>Sep 27, 2021</time> </span> </div><h2 class='article__title'>动态规划（一）打家劫舍系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
    } 
  
]
