[
  
    {
      "title"    : "使用ChatGPT控制Arduino设备",
      "category" : "",
      "tags"     : "ChatGPT, Arduino, and 智能家庭",
      "url"      : "/2023/04/24/%E4%BD%BF%E7%94%A8ChatGPT%E6%8E%A7%E5%88%B6Arduino%E8%AE%BE%E5%A4%87/",
      "date"     : "Apr 24, 2023",
      "content"  : "这篇博客中将介绍如何使用ChatGPT来控制Arduino设备。ChatGPT是由OpenAI开发的一种自然语言处理模型，其强大的功能引发了很大的讨论。本文介绍了ChatGPT与外部系统集成的一种方法，通过ChatGPT作为控制器实现对Arduino设备的控制，以探索自然语言命令控制家庭设备的可能性及智能家庭设备的发展方向。这篇博客的代码公开在我的github仓库，点此链接传送至该项目。ChatGPT接入Prompt编写与测试我们期望ChatGPT以json格式输出命令实现对设备的控制，因此首先需要编写一个合适的提示（prompt），用于告诉ChatGPT我们的需求。在这个提示中，我们应该明确表达我们希望ChatGPT理解并回答的问题，如打开/关闭LED灯、控制电机转速等。经过数次测试之后，我们使用python代码整合了我们的全部需求，def generate_prompt(text):    possible_device = [        {            'light':'0 close,1 open'        },        {            'air-conditioner':'0 close,1 open'        },        {            'curtain': '0 close,1 open'        }    ]    prompt = f'As an Intelligent Assistant you need to rely on my words to determine what to do with some of devices.\n' \             f'{text}\n' \             f'your reply contain a list with json [device] only from these devices: {possible_device}' \             f' and only write json list without any discourse.'    return prompt在ChatGPT官网测试该提示词，发现ChatGPT可以正确理解我们的需求并做出回应。此时，我们相信ChatGPT可以集成到我们的项目中。OpenAI API接入OpenAI提供了官方API，以实现通过发送请求与ChatGPT进行实时交互。首先，我们需要获得OpenAI API的访问密钥。在OpenAI的开发者门户网站上可以注册一个账户并获取API密钥。将API密钥保存在安全的地方，因为它将用于与OpenAI API进行通信。接下来，我们可以通过引入OpenAI API包来实现与ChatGPT的交互，这个过程仍然被放在了一个函数中：def get_reply(prompt, mask = True, mask_reply = None):    if mask:        return json.dumps(mask_reply)    with open('OPENAI_API_KEY') as key:        openai.api_key = key.read().rstrip('\n')        completions = openai.ChatCompletion.create(            model="gpt-3.5-turbo",            messages=[                {"role": "user", "content": prompt}            ],            temperature=0,            n=1,            max_tokens=100        )        message = completions.choices[0].message.content        return message执行代码并观察输出结果，发现我们成功与ChatGPT完成交互。In: As an Intelligent Assistant you need to rely on my words to determine what to do with some of devices.我很冷，你可以帮我些什么吗your reply contain a list with json [{"device":"device_1","param":0}] only from these devices: [{'light': '0 close,1 open'}, {'air-conditioner': '0 close,1 open'}, {'curtain': '0 close,1 open'}] and only write json list without any discourse.Out: [{"device":"air-conditioner","param":1}]基于Flask搭建服务器在上一部分中，我们完成了与ChatGPT的对话和集成。为了便于用户的使用及与Arduino的交互，我们将使用Flask框架搭建一个服务器，以通过网络实现交互。Flask框架搭建Flask是一个轻量级的Python Web框架，非常适合用于构建简单的Web应用程序。我们将使用Flask来搭建一个简单的服务器，以接收用户或Arduino的请求。首先，我们需要安装Flask。可以使用pip命令来安装Flask：pip install flask随后创建Flask主文件：from flask import Flaskimport flask_restful as restfulapp = Flask(__name__)api = restful.Api(app, default_mediatype="application/json")if __name__ == '__main__':    app.run()此时RESTful风格Flask框架已经搭建完成，我们需要为其添加用户及Arduino交互接口。添加用户API定义一个用户API文件order.py，用于向服务器发送请求并获取响应。核心代码如下所示：class OrderApi(Resource):    def post(self):        text_dict = RequestParser()\            .add_argument('text', type=str, location='json', required=True) \            .add_argument('device', type=str, location='json', required=False)\            .add_argument('param', type=float, location='json', required=False)\            .parse_args()                    mask_reply = []        if text_dict['device'] and text_dict['param'] is not None:            mask_reply.append({'device':text_dict['device'], 'param':text_dict['param']})        prompt=generate_prompt(text=text_dict['text'])        reply=get_reply(prompt=prompt,                        mask=False,                        mask_reply=mask_reply)        update_state=match_json(text=reply)        return device_states.update(update_state)随后我们需要在主文件中注册API文件：api.add_resource(OrderApi, '/')此时用户可以通过POST请求实现对Arduino设备状态的控制。Arduino APIArduino设备主要工作内容为读取当前设备工作状态并做出对应调整，因此只需编写简单GET请求响应：class ArduinoApi(Resource):    def get(self):        return device_states.get()同样在主文件中注册API文件：api.add_resource(ArduinoApi, '/arduino')通过Postman测试，发现可以服务器已经可以正常工作。使用MongoDB存储设备状态为了防止停电等因素对设备开关记忆的影响，我们使用数据库对设备状态进行持久化。MongoDB作为一种基于键值对的通用NoSQL数据库，非常适合实现这个需求。MongoDB数据库结构在我们开始之前，我们需要定义设备状态的数据结构。在这个例子中，我们假设我们的设备有一个LED灯，可以打开或关闭。我们可以使用以下JSON格式来表示设备状态：{    "device": "light",    "param": 1.0}在上面的示例中，device是设备的唯一标识符，param表示LED灯的状态。Flask接入MongoDB为了与MongoDB进行交互，我们将使用MongoDB的官方Python驱动程序pymongo。我们需要先安装它：pip install pymongo接下来，我们需要在Flask应用程序中添加与MongoDB的连接和数据访问逻辑。在app.py文件中添加pymongo库：from flask_pymongo import PyMongomongo = PyMongo(app, uri=config.MONGO_URI)与数据库的交互及数据缓存我们编写一个DeviceStates类与数据库进行交互，为了提升设备响应的即时性，我们还可以给数据库添加缓存。class DeviceStates(object):    def __init__(self):        self.state = {}        self._flash = False        pass    def get(self):        if not self._flash:            self._flash = True            for device_state in list(devices.find(projection = {'_id': 0})):                self.state[device_state['device']] = device_state        return self.state    def update(self, update_dict:DeviceState):        for update_device, update_state in update_dict.items():            devices.update_one({f'_id':update_device}, {'$set':{**update_state}}, upsert=True)            self.state[update_device] = update_state        return self.get()    def delete(self, all = True):        self.state = {}        return devices.delete_many({}).deleted_count编写QQbot实现QQ平台控制本节编写了一个简单的QQbot，用户可以在QQ平台与QQbot简单对话，完成对Arduino设备状态的控制。安装botpy包：pip install botpy为QQbot编写交互代码如下：import asyncioimport osimport botpyimport requestsfrom botpy import loggingfrom botpy.ext.cog_yaml import readfrom botpy.message import Messagetest_config = read(os.path.join(os.path.dirname(__file__), "config.yaml"))_log = logging.get_logger()headers = {    'accept-language': 'zh-CN,zh;q=0.9,en;q=0.8',    'content-type': 'application/json',}class MyClient(botpy.Client):    async def on_ready(self):        _log.info(f"robot 「{self.robot.name}」 on_ready!")    async def on_at_message_create(self, message: Message):        _log.info(message.author.avatar)        if "sleep" in message.content:            await asyncio.sleep(10)        _log.info(message.author.username)        url = test_config['server']        import re        text = re.sub('&lt;.*?&gt;', '', message.content)        data = {            'text': text,            'device': 'light',            'param': 1        }        response = requests.request("POST", url, headers=headers, json=data)        await message.reply(content=f"{response.content.decode('unicode_escape')}")if __name__ == "__main__":    intents = botpy.Intents(public_guild_messages=True)    client = MyClient(intents=intents)    client.run(appid=test_config["appid"], token=test_config["token"])此时，我们可以在QQ频道与QQbot对话，以实现对Arduino设备的控制Arduino状态控制在服务器及交互平台搭建完成后，本部分展示了Arduino设备代码实现，其原理主要为发出GET请求获取设备状态，随后通过字符串匹配控制设备的状态。Arduino设备代码实现这部分代码是由我的队友编写的，他速成了Arduino代码编写并实现了设备状态控制，感谢他在该项目的贡献。#include &lt;ESP8266WiFi.h&gt;#include &lt;SoftwareSerial.h&gt;#include &lt;ESP8266HTTPClient.h&gt;#include &lt;ArduinoJson.h&gt;const char * ssid; //Enter your Wi-Fi SSIDconst char * password; //Enter you Wi-Fi Passwordint i = 0;int check = 9;int ledpin = 2;String Payload = "";define URL "http://localhost:5000/arduino"void setup() {    WiFi.mode(WIFI_STA);    Serial.begin(115200);    pinMode(ledpin, OUTPUT);    digitalWrite(ledpin, 0);    Serial.println("开始连接");    WiFi.begin(ssid, password);    Serial.print("正在连接到");    Serial.print(ssid);    while (WiFi.status() != WL_CONNECTED) {        delay(1000);        Serial.print("waiting for ");        Serial.print(i++);        Serial.println("s...");    }    Serial.println("");    Serial.println("WiFi connected!");    Serial.print("IP address: ");    Serial.println(WiFi.localIP());}void loop() {    WiFiClient tcpClient;    HTTPClient httpClient;    httpClient.begin(tcpClient, URL);    Serial.print("URL: ");    Serial.println(URL);    int httpCode = httpClient.GET();    Serial.print("Send GET request to URL: ");    Serial.println(URL);    if (httpCode == 200) {        Payload = httpClient.getString();        Serial.print("\r\nServer Respose Code: ");        Serial.println(httpCode);        Serial.println("Server Response Payload: ");        Serial.println(Payload);    } else {        Serial.print("\r\nServer Respose Code: ");        Serial.println(httpCode);    }    httpClient.end();    StaticJsonDocument &lt; 200 &gt; doc;    DeserializationError error = deserializeJson(doc, Payload);    check = doc["light"]["param"];    Serial.print(check);    if (check == 1) {        digitalWrite(ledpin, HIGH);    }    if (check == 0) {        digitalWrite(ledpin, LOW);    }    Payload = "";    delay(10000);}结果展示如图所示，在向QQbot提出需求后，ChatGPT成功接收并理解了我们的需求并将其转化为指令，Arduino设备状态也随之发生改变。ChatGPT在此次实验中的强大作用向我们展示了大语言模型在智能家庭的重大潜力。包括但不限于识别并发掘深度需求，多模态智能家居控制，个性化用户体验等多种潜在方向。同样，该项应用也存在隐私保护，数据安全等问题，需要人们的进一步思考和解决。",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/04/24/%E4%BD%BF%E7%94%A8ChatGPT%E6%8E%A7%E5%88%B6Arduino%E8%AE%BE%E5%A4%87/'> <img src='https://api.wannote.com/image/bing.php?day=2' alt='使用ChatGPT控制Arduino设备'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>11 min read <time class='article__date' datetime='2023-04-24T00:00:00+08:00'>Apr 24, 2023</time> </span> </div><h2 class='article__title'>使用ChatGPT控制Arduino设备</h2> <p class='article__excerpt'>本文介绍了ChatGPT与外部系统集成的一种方法，通过ChatGPT作为控制器实现对Arduino设备的控制，以探索自然语言命令控制家庭设备的可能性及智能家庭设备的发展方向。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/ChatGPT' class='article__tag'>ChatGPT</a>  <a href='/tag/Arduino' class='article__tag'>Arduino</a>  <a href='/tag/智能家庭' class='article__tag'>智能家庭</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "二分查找（Binary Search）",
      "category" : "",
      "tags"     : "算法",
      "url"      : "/2021/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search/",
      "date"     : "Oct 15, 2021",
      "content"  : "概念二分查找是对已排好序的数组查找特定值的常用方法，二分查找不必遍历整个序列，只需关注序列的边界及中间值即可，因此时间复杂度可以达到\(O(logn)\)模板在一个有序序列中查找关键字\(key\)的模板代码如下int binarySearch(vector&lt;int&gt;&amp; nums, int key) {    int l = 0, r = nums.size() - 1, ans = nums.size();    while (l &lt;= r) {        int mid = (l + r) / 2;        if (nums[mid] &lt; key)            l = mid + 1;        else            r = mid - 1, ans = mid;    }    return ans;}题目二分的题目模板一般都是固定的，主要是能否想到的对什么进行二分，怎样二分。34. 在排序数组中查找元素的第一个和最后一个位置该题不仅要求元素出现的第一个位置，还要求出元素出现的最后一个位置。在模板代码中，若nums[i] &lt; key，才会继续查找左边，如果我们想在已经找到元素后继续查找，则需要修改为nums[i] &lt;= key。这样查找的结果是大于\(key\)的第一个元素的位置。因此该题的代码如下class Solution {public:    int binarySearch(vector&lt;int&gt; &amp;nums, int key, bool next) {        int l = 0, r = nums.size() - 1, ans = nums.size();        while (l &lt;= r) {            int mid = (l + r) / 2;            if (nums[mid] &lt; key || (last &amp;&amp; nums[mid] &lt;= key))                l = mid + 1;            else                r = mid - 1, ans = mid;        }        return ans;    }    vector&lt;int&gt; searchRange(vector&lt;int&gt; &amp;nums, int target) {        int l = binarySearch(nums, target, false),                r = binarySearch(nums, target, true) - 1;        if (l &lt;= r)            return {l, r};        else return {-1, -1};    }};74. 搜索二维矩阵依题可知待查找元素必大于或等于该行第一个元素，因此我们先对列进行一次二分查找，寻找不大于\(target\)的最大元素之后对该行进行基本的二分查找，即可得到结果。代码如下class Solution {public:    bool searchMatrix(vector&lt;vector&lt;int&gt;&gt; &amp;matrix, int target) {        int l = 0, r = matrix.size() - 1, ans = matrix.size(), res = matrix[0].size();        // 先找小于target的第一个数的位置        while (l &lt;= r) {            int mid = (l + r) / 2;            if (matrix[mid][0] &gt; target) r = mid - 1;            else  					     l = mid + 1, ans = mid;        }        if (ans &lt; 0 || ans &gt;= matrix.size()) return false;        l = 0, r = matrix[0].size() - 1;        while (l &lt;= r) {            int mid = (l + r) / 2;            if (matrix[ans][mid] &gt; target) r = mid - 1;            else						   l = mid + 1, res = mid;        }        return matrix[ans][res] == target;    }};33. 搜索旋转排序数组该题只保证了数组的局部有序，但对数组进行二分后，会发现总有一半的数组是有序的，此时可以继续对有序的数组进行二分查找，代码如下class Solution {public:    int binarySearch(vector&lt;int&gt; nums, int key, int s, int t) {        int l = s, r = t - 1, ans = t;        while (l &lt;= r) {            int mid = (l + r) / 2;            if (nums[mid] &gt; key) {                r = mid - 1;            } else {                l = mid + 1;                ans = mid;            }        }        return (ans &lt; t &amp;&amp; nums[ans] == key) ? ans : -1;    }    int search(vector&lt;int&gt; &amp;nums, int target) {        int l = 0, r = nums.size() - 1, ans = -1;        while (l &lt;= r) {            int mid = (l + r) / 2;            if (nums[mid] == target) return mid;            if (nums[l] &lt; nums[mid]) {                ans = binarySearch(nums, target, l, mid);                l = mid + 1;            } else {                ans = binarySearch(nums, target, mid + 1, r + 1);                r = mid - 1;            }            if (ans &gt;= 0) return ans;        }        return ans;    }};153. 寻找旋转排序数组中的最小值该题要查找的是上一题中旋转的排序数组的最小值，也即旋转点的值，我们依然利用部分有序的性质，二分查找数组最小值，代码如下class Solution {public:    int findMin(vector&lt;int&gt;&amp; nums) {        int l = 0, r = nums.size() - 1, ans = nums.size();        while (l &lt;= r) {            int mid = (l + r) / 2;            if (nums[r] &gt; nums[mid])                r = mid;            else                l = mid + 1, ans = mid;        }        return nums[ans];    }};162. 寻找峰值我们可以用\([l,r]\)来存储可能存在峰值的区间，根据\(mid\)进行二分，若nums[mid] &lt; nums[mid + 1]则说明在区间\([mid+1,r]\)存在峰值，反之则说明在区间[l,mid]存在峰值，因此代码如下class Solution {public:    int findPeakElement(vector&lt;int&gt;&amp; nums) {        int l = 0, r = nums.size() - 1;        while (l &lt;= r) { // 用l,r表示可能存在峰值的区间            int mid = (l + r) / 2;            if (l == r) return l;            if (nums[mid] &lt; nums[mid + 1])                l = mid + 1;//mid+1-r更大            else                r = mid;//l-mid更大        }        return -1;    }};",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search/'> <img src='/images/covers/blackrock2.jpg' alt='二分查找（Binary Search）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2021-10-15T20:51:55+08:00'>Oct 15, 2021</time> </span> </div><h2 class='article__title'>二分查找（Binary Search）</h2> <p class='article__excerpt'>二分查找是对已排好序的数组查找特定值的常用方法，二分查找不必遍历整个序列，只需关注序列的边界及中间值即可，因此时间复杂度可以达到 O(log n)</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "动态规划（四）最长上升子序列（LIS）",
      "category" : "",
      "tags"     : "算法 and 动态规划",
      "url"      : "/2021/10/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9B%9B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-LIS/",
      "date"     : "Oct 11, 2021",
      "content"  : "300.最长递增子序列动态规划我们可以定义\(dp[i]\)为以\(i\)结尾的递增子序列长度的最大值（数组\(dp\)的常用套路），则我们可以写出状态转移方程为\(dp[i]=max(dp[j])+1,(0≤j&lt;i, nums[j]&lt;nums[i])\)最后，此题的结果便是\(max(dp[i])\)，代码如下int lengthOfLIS(vector&lt;int&gt;&amp; nums) {    int n = nums.size();    vector&lt;int&gt; dp(n);    dp[0] = 1;    int res = dp[0];    for (int i = 1; i &lt; n; i++) {        dp[i] = 1;        for (int j = 0; j &lt; i; j++)            if (nums[j] &lt; nums[i])                dp[i] = max(dp[i], dp[j] + 1);        res = max(res, dp[i]);    }    return res;}该解法时间复杂度为\(O(n^2)\)树状数组LIS问题的本质是偏序问题，我们之前在二维偏序问题中提到过，树状数组可以轻松的解决这类问题。但之前的问题中，我们求的是数对的数量，而不是序列的长度。为了能够求得序列长度，我们要对树状数组进行修改。我们可以用树状数组存储以\(i\)结尾的递增子序列最大值，修改树状数组结构如下void update(int i, int k) {    i++;    while (i &lt;= N) {        node[i] = max(k, node[i]);        i += lowbit(i);    }}int sum(int i) {    int sum = 0;    while (i &gt; 0) {        sum = max(sum, node[i]);        i -= lowbit(i);    }    return sum;}随后用和\(dp\)同样的方式进行遍历，可以得出正确结果，同时要注意数据的离散化，代码如下class Fenwick {public:    int N;    vector&lt;int&gt; node;    Fenwick(int n) : N(n), node(n + 1, 0) {}    int lowbit(int i) {        return i &amp; -i;    }    void update(int i, int k) {        i++;        while (i &lt;= N) {            node[i] = max(k, node[i]);            i += lowbit(i);        }    }        int sum(int i) {        int sum = 0;        while (i &gt; 0) {            sum = max(sum, node[i]);            i -= lowbit(i);        }        return sum;    }};class Solution {public:    int lengthOfLIS(vector&lt;int&gt; &amp;nums) {        int n = nums.size();        int res = 0;        vector&lt;int&gt; l = nums;        sort(l.begin(), l.end());        l.erase(unique(l.begin(), l.end()), l.end());        Fenwick f = Fenwick(l.size());        for (int i = 0; i &lt; n; i++) {            nums[i] = lower_bound(l.begin(), l.end(), nums[i]) - l.begin();            res = max(res, f.sum(nums[i]) + 1);            f.update(nums[i], f.sum(nums[i]) + 1);            cout &lt;&lt; i &lt;&lt; f.sum(nums[i]) + 1 &lt;&lt; endl;        }        return res;    }};该解法时间复杂度为\(O(nlogn)\)",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9B%9B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-LIS/'> <img src='/images/covers/village.jpg' alt='动态规划（四）最长上升子序列（LIS）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-11T21:19:19+08:00'>Oct 11, 2021</time> </span> </div><h2 class='article__title'>动态规划（四）最长上升子序列（LIS）</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "二叉树基础（三） 线段树（Segment Tree）",
      "category" : "",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree/",
      "date"     : "Oct 9, 2021",
      "content"  : "概念线段树是常用于维护区间信息的数据结构线段树可以在$O(logn)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作结构线段树将每个长度不为$1$的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。假设以线段树存储数组$a=[6,7,8,9,10]$，设线段树的根节点编号为$1$，用数组$node$来保存线段树，$node[i]$用来保存线段树上编号为$i$的节点的值该线段树的结构如下代码如下    vector&lt;int&gt; node; // 线段树下标从1开始    vector&lt;int&gt; nums; // 辅助建树    int N;基本操作线段树的建立对于节点$i$，其子节点的编号为$2i$以及$2i+1$，若节点$i$存储的区间为$[a,b]$，则节点$2i$存储的区间应该是$[a,\frac{a+b}{2}]$，相应地，节点$2i+1$存储的区间为$[\frac{a+b}{2}+1,b]$。我们可以采用递归的方式建树，代码如下void build(int i, int l, int r) { // i表示当前节点, l表示左边界, r表示右边界    if (l == r) {        node[i] = nums[l];        return;    }    int mid = (l + r) / 2;    build(2 * i, l, mid);    build(2 * i + 1, mid + 1, r);    node[i] = node[2 * i] + node[2 * i + 1];}区间查询若查询的区间为$[1,5]$，我们只需直接返回$node[1]$，但如果我们查询的是$[3,5]$，则需要合并$[3,3]$和$[4,5]$的答案，代码如下int query(int i, int l, int r, int s, int t) { //i表示当前节点, [l,r]是查询区间, [s,t]表示当前节点包含区间    if (l &lt;= s &amp;&amp; r &gt;= t) // 若[s,t]是[l,r]的子区间，直接返回        return node[i];    int sum = 0, mid = (s + t) / 2; //递归查询存在交集的子区间    if (l &lt;= mid) sum += query(2 * i, l, r, s, mid); // 递归查询左字串    if (r &gt;= mid + 1) sum += query(2 * i + 1, l, r, mid + 1, t); // 递归查询右字串    return sum;}区间修改和区间查询相同，若区间存在包含关系，我们可以为其直接加上所需要更新的值，而当区间存在交集时，进行递归更新，代码如下void update(int i, int l, int r, int s, int t, int add) {    if (l &lt;= s &amp;&amp; r &gt;= t) { // 若[s,t]是[l,r]的子区间，直接更新        node[i] += (t - s + 1) * add;        return;    }    int mid = (s + t) / 2; //递归更新存在交集的子区间    if (l &lt;= mid) update(2 * i, l, r, s, mid, add); // 递归更新左字串    if (r &gt;= mid + 1) update(2 * i + 1, l, r, mid + 1, t, add); // 递归更新右字串    node[i] = node[2 * i] + node[2 * i + 1];}懒惰标记当我们按照上面的方法对$[6,7,8,9,10]$的区间$[3,5]$加上$2$后，更新后的线段树结构如下我们会发现，在进行递归更新时，递归执行到节点$3$时就已经结束了，因此节点$3$的两个子节点没有被更新遇到这种情况，我们需要给递归结束的节点打上一个标记，在下一次查询操作时将没有更新的子节点更新，这个标记被称为懒惰标记，这样更新时效果如图而查询后的效果如下我们可以用vector&lt;int&gt; lazy来存储懒惰标记，下方懒惰标记的代码如下void push_down(int i, int l, int r) {    if (!lazy[i])        return;    int mid = (l + r) / 2;    lazy[2 * i] += lazy[i];    lazy[2 * i + 1] += lazy[i];             // 下放懒惰标记    node[2 * i] += (mid - l + 1) * lazy[i];    node[2 * i + 1] += (r - mid) * lazy[i]; // 将懒惰标记的值加给子树    lazy[i] = 0;}然后在查询和更新函数中调用push_down()即可整体代码class SegmentTree {public:    vector&lt;int&gt; node; // 线段树下标从1开始    vector&lt;int&gt; lazy; // 懒惰标记    vector&lt;int&gt; nums; // 辅助建树    int N = 1;    SegmentTree(vector&lt;int&gt; nums, int n) : node(n + 1, 0), lazy(n + 1, 0), nums(nums) {}    void build(int i, int l, int r) { // i表示当前节点, l表示左边界, r表示右边界        N++;        if (l == r) {            node[i] = nums[l - 1];            return;        }        int mid = (l + r) / 2;        build(2 * i, l, mid);        build(2 * i + 1, mid + 1, r);        node[i] = node[2 * i] + node[2 * i + 1];    }    void push_down(int i, int l, int r) {        if (!lazy[i])            return;        int mid = (l + r) / 2;        lazy[2 * i] += lazy[i];        lazy[2 * i + 1] += lazy[i];             // 下放懒惰标记        node[2 * i] += (mid - l + 1) * lazy[i];        node[2 * i + 1] += (r - mid) * lazy[i]; // 将懒惰标记的值加给子树        lazy[i] = 0;    }    int query(int i, int l, int r, int s, int t) { //i表示当前节点, [l,r]是查询区间, [s,t]表示当前节点包含区间        if (l &lt;= s &amp;&amp; r &gt;= t) // 若[s,t]是[l,r]的子区间，直接返回            return node[i];        push_down(i, s, t);        int sum = 0, mid = (s + t) / 2; //递归查询存在交集的子区间        if (l &lt;= mid) sum += query(2 * i, l, r, s, mid); // 递归查询左字串        if (r &gt;= mid + 1) sum += query(2 * i + 1, l, r, mid + 1, t); // 递归查询右字串        return sum;    }    void update(int i, int l, int r, int s, int t, int add) {        if (l &lt;= s &amp;&amp; r &gt;= t) { // 若[s,t]是[l,r]的子区间，直接更新            lazy[i] += add;            node[i] += (t - s + 1) * add;            return;        }        push_down(i, s, t);        int mid = (s + t) / 2; //递归更新存在交集的子区间        if (l &lt;= mid) update(2 * i, l, r, s, mid, add); // 递归更新左字串        if (r &gt;= mid + 1) update(2 * i + 1, l, r, mid + 1, t, add); // 递归更新右字串        node[i] = node[2 * i] + node[2 * i + 1];    }};",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree/'> <img src='https://api.dujin.org/bing/1920.php' alt='二叉树基础（三） 线段树（Segment Tree）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>9 min read <time class='article__date' datetime='2021-10-09T19:00:50+08:00'>Oct 9, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（三） 线段树（Segment Tree）</h2> <p class='article__excerpt'>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "二叉树基础（二）二叉搜索树（BST）",
      "category" : "",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/2021/10/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/",
      "date"     : "Oct 5, 2021",
      "content"  : "概念二叉搜索树（Binary Search Tree）（又：二叉查找树，二叉排序树），它或者是一棵空树，或者是具有下列性质的二叉树：若它的左子树非空，则左子树上所有结点的值均小于它的根结点的值； 若它的右子树非空，则右子树上所有结点的值均大于它的根结点的值；它的左、右子树也分别是二叉搜索树。二叉搜索树作为一种经典的数据结构，既有快速插入与删除操作的特点，又有快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。性质二叉搜索树有以下性质：  若左子树非空，则左子树上的所有节点值均小于根节点的值。  若右子树非空，则右子树上的所有节点值均小于根节点的值。  左右子树是二叉搜索树。结构BST是以二叉树来构建的，除了key和位置数据之外，每个结点还包含属性lchild、rchild，如果某个孩子结点不存在，则相应属性的值为空。typedef struct Node {    int data;                               // 数据    struct Node *lchild, *rchild;  			// 左右子树} * BST, BSTNode;代码基本操作BST的构造和析构与普通二叉树相同，这里不多赘述。相比于普通二叉树，BST的主要功能增加了查找，插入和删除$find()$$find()$函数的作用是查找某一个数据值已知的节点是否在树中，并返回节点值。代码如下BST find(BST tree, int data){    BST p = tree;    while(p) {        if (p-&gt;data == data) return p;        if (data &lt; p-&gt;data) {            p = p-&gt;lchild;        } else {            p = p-&gt;rchild;        }    }    return NULL;}$insert()$$insert()$函数的作用是在树中插入一个节点。BST中所有的节点都是作为叶子节点插入的，因此在创建节点$p$后，要找到合适的父节点$f$并插入其中。代码如下bool insert(BST&amp; tree, int data) {    BST p = tree, f;    while(p) {        if (p-&gt;data == data) return false;        f = p;                  // 记录f为p的父节点        if (data &lt; p-&gt;data) {            p = p-&gt;lchild;        } else {            p = p-&gt;rchild;        }    }                           // 查找data是否已经在树中    p = (BST) malloc(sizeof(BSTNode));    p-&gt;lchild = p-&gt;rchild = NULL;    p-&gt;data = data;             // 创建节点    if(!tree) tree = p;    else if(data &lt; f-&gt;data) f-&gt;lchild = p;    else f-&gt;rchild = p;    return true;}$delete()$二叉搜索树进行删除操作后，仍然要保证它的排序正确，因此我们的删除操作分为三种情况：  待删除节点无左孩子，则用右孩子代替其位置  待删除节点无右孩子，则用左孩子代替其位置  待删除节点拥有左右孩子，则用左子树最大节点或右子树最小节点代替其位置代码如下bool delete(BST&amp; tree, int data) {    if(!tree) return false;    BST p = tree, f;    while(p) {        if (p-&gt;data == data) break;        f = p;                  // 记录f为p的父节点        if (data &lt; p-&gt;data) {            p = p-&gt;lchild;        } else {            p = p-&gt;rchild;        }    }                           // 查找data的位置    if(!p)  return false;       // 若未找到，则返回false    if(!p-&gt;lchild) {            // 情况1        if(tree == p) tree = p-&gt;rchild;        else if(f-&gt;lchild == p) f-&gt;lchild = p-&gt;rchild;        else if(f-&gt;rchild == p) f-&gt;rchild = p-&gt;rchild;        free(p);    }    else if(!p-&gt;rchild){        // 情况2        if(tree == p) tree = p-&gt;lchild;        else if(f-&gt;lchild == p) f-&gt;lchild = p-&gt;lchild;        else if(f-&gt;rchild == p) f-&gt;rchild = p-&gt;lchild;        free(p);    }    else{                       // 情况3        BST tmp = p-&gt;lchild, fl = p;        while(tmp-&gt;rchild) fl = tmp,tmp = tmp-&gt;rchild;        p-&gt;data = tmp-&gt;data;        if(fl-&gt;lchild == tmp) fl-&gt;lchild = NULL;        else if(fl-&gt;rchild == tmp) fl-&gt;rchild = tmp-&gt;lchild;        free(tmp);    }    return true;}",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/'> <img src='https://api.dujin.org/bing/1920.php' alt='二叉树基础（二）二叉搜索树（BST）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-05T01:14:28+08:00'>Oct 5, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（二）二叉搜索树（BST）</h2> <p class='article__excerpt'>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "动态规划（三）股票问题系列",
      "category" : "",
      "tags"     : "算法 and 动态规划",
      "url"      : "/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 29, 2021",
      "content"  : "121. 买卖股票的最佳时机状态转移方程我们可以用$dp[i]$来表示，在前$i$日我们可以得到的最大利润，那么我们第$i$日的操作有两种选择：1.我们在第i日卖出得到的利润可能比之前的利润（dp[i-1]）更高2.我们之前的利润要比现在更高，不用进行任何操作对于情况1，我们得到状态转移方程$dp[i]=prices[i]-price_{min}$而对于情况2，我们有$dp[i]=dp[i-1]$综合两种情况，也就得到此题的状态转移方程：$dp[i]=max(dp[i-1],prices[i]-price_{min})$那么剩下的问题就在于如何表示$price_{min}$。如何表示$price_{min}$我们发现，$price_{min}$的计算也是一个无后效性的问题，我们同样可以通过动态规划来求解，用$dp_{price_{min}}[i]$来表示前i日股票的最低价格，则$dp_{price_{min}}[i]$的状态转移方程可以写成：$dp_{price_{min}}[i]$ = $min(prices[i],dp_{price_{min}}[i-1])$可能这时候你就要说了，你这不是脱了裤子放屁吗？那我们不妨换一个思维方式，还是上面的状态转移方程不变，我们用$dp[i][j]$表示前$i$天手上有$j$个股票时我们的最大利润。 这时候你不妨停下来思考一会，该如何写出状态转移方程呢？联立上面两个转移方程，得到$dp[i][j]$的状态转移方程：$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$$dp[i][1] = max(-prices[i], dp[i - 1][1]);$没错，此时的$dp[i][1]$就是之前我们的开销，用来辅助我们计算第$i$天的最大利润，也就是$dp[i][0]$边界条件$dp[0][0]$表示在第0天我们手上有0支股票时的最大利润，因此$dp[0][0]=0$$dp[0][1]$表示在第0天我们手上有1支股票时的最大利润，因此$dp[0][0]=-prices[0]$代码int maxProfit(vector&lt;int&gt;&amp; prices) {     const int MAX = 100100;     int dp[MAX][2];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)          dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]),         dp[i][1] = max(-prices[i], dp[i - 1][1]);     return dp[prices.size()-1][0];}篇幅关系，空间复杂度的优化留给读者自己思考，我这里不作展开122. 买卖股票的最佳时机 II状态转移方程122.题与121.题的不同点在于，122.是可以无限进行购买操作的，相应的，我们的状态转移方程也有所改变。根据我们第一题的状态转移方程，在第一题里，一但我们前面卖出了股票，下次再想购买股票时，总利润便会变成$-prices[i]$，但在这道题中，由于我们不再受购买次数的限制，因此我们的利润就可以一直累计下去，如何理解这种累计呢？在前$i-1$天，我们的最大利润达到了$dp[i-1][0]$，而在第$i$天我们要购入股票，此时的利润就会变为$dp[i-1][0]-prices[i]$即$dp[i][1]$的状态转移方程变为：$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$读者应该也注意到，在我们把状态转移方程分成两部分后，我们对转移方程的解读方式也转变了，这里我再次阐述一遍，$dp[i][0]$表示手上没有股票时的最大利润，$dp[i][1]$表示手上有一枚股票时的最大利润。综上，状态转移方程为：$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$边界条件与之前相同。代码int maxProfit(vector&lt;int&gt;&amp; prices) {     const int MAX = 100100;     int dp[MAX][2];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)         dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]),         dp[i][1] = max(dp[i - 1][0]-prices[i], dp[i - 1][1]);     return dp[prices.size()-1][0];}714. 买卖股票的最佳时机含手续费状态转移方程如果你认真阅读了题714.并理解了题122.那这道题你其实可以直接过的，因为这道题和题122.的不同之处就在于，它在售卖时多了手续费这个固定消耗，因此在决定卖出股票的第$i$天里，如果收益不足以抵消掉手续费，那我们会选择之前的利润作为最优解，即：$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$整体的转移方程表示为：$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$边界条件仍与之前相同代码int maxProfit(vector&lt;int&gt;&amp; prices, int fee) {     const int MAX = 100100;     int dp[MAX][2];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)         dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i] - fee),         dp[i][1] = max(dp[i - 1][0]-prices[i], dp[i - 1][1]);     return dp[prices.size()-1][0];}309. 最佳买卖股票时机含冷冻期状态转移方程这道题的变化在于，之前我们只有$(0)$卖出、$(1)$买入两种状态，但这道题引入了一个新的新的状态$(2)$冷冻期，而这个冷冻期状态是在卖出操作后出现，如果我们用$dp[i][2]$来表示当我们在第$i$天的冷冻期收益，则$dp[i][2]$可以用$dp$表示为：$dp[i][2] = dp[i-1][0]$买入状态的转移方程也有所变化，因为此题中买入状态必须由冷冻期状态进入，也就是：$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$最后，综合三式就可以得到我们新的状态转移方程：$dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])$$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$$dp[i][2] = dp[i - 1][0]$边界条件仍然不变代码int maxProfit(vector&lt;int&gt;&amp; prices) {     const int MAX = 100100;     int dp[MAX][3];     dp[0][1] = -prices[0],dp[0][0] = 0;     for (int i = 1; i &lt; prices.size(); i++)         dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]),         dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1]), //         dp[i][2] = dp[i - 1][0];     return dp[prices.size()-1][0];}123. 买卖股票的最佳时机 III思路如果没有前面的铺垫直接来看这道题，难度瞬间就高起来了。但现在带着前面的经验再来对比这道题，我们会发现这道题和题121. 题122.有着很大的关联。假设在第$i$天卖出了股票，当我们是第一次或第二次操作时，我们的利润是可以积累的。但如果是在第三次操作，那么我们就要重新累计利润了。我们不妨将$dp$升到三维数组，用第三维来区分第一次操作和第二次操作，即得到代码如下：代码int maxProfit(vector&lt;int&gt;&amp; prices) {    const int MAX = 100100;    int dp[MAX][2][2];    dp[0][1][1] = dp[0][1][0] = -prices[0];    for (int i = 1; i &lt; prices.size(); i++){        dp[i][0][0] = max(dp[i - 1][0][0], dp[i - 1][1][0] + prices[i]),        dp[i][1][0] = max(-prices[i], dp[i - 1][1][0]);        dp[i][0][1] = max(dp[i - 1][0][1], dp[i - 1][1][1] + prices[i]),        dp[i][1][1] = max(dp[i - 1][0][0]-prices[i], dp[i - 1][1][1]);    }    return dp[prices.size()-1][0][1];}这个代码并不优雅，但对于问题的解决无疑是直接而有效的188. 买卖股票的最佳时机 IV当问题扩充到$k$时，我们解决题123.的思路仍然有效，我们可以用初始化边界为$0$，再用一个$for$循环写出结果。 int maxProfit(int k, vector&lt;int&gt;&amp; prices) {    if(prices.empty()) return NULL;    const int MAX = 1100;    int dp[MAX][2][110]={0};    for(int j = 0; j &lt;= k; j++) dp[0][1][j] = -prices[0];    for(int i = 1; i &lt; prices.size(); i++)        for(int  j = 1; j &lt;= k ; j++)            dp[i][0][j] = max(dp[i-1][1][j] + prices[i], dp[i-1][0][j]),            dp[i][1][j] = max(dp[i-1][0][j-1] - prices[i], dp[i-1][1][j]);    return dp[prices.size()-1][0][k]; }股票问题的一般通解状态转移方程股票问题的三个限定条件是  当前天数$i$  手持股票$j$  允许的最大操作次数$k$我们设在第$i$天，手持股票为$j$，操作次数为$k$时我们的利润为$dp[i][j][k]$，视每次购买股票为进行一次操作，则我们的状态转移方程为：$dp[i][0][k] = max(dp[i-1][1][k] + prices[i], dp[i-1][0][k])$$dp[i][1][k] = max(dp[i-1][0][k-1] - prices[i], dp[i-1][1][k])$边界条件$dp[0][1][k] = -prices[0]$其余值都为0结束语股票问题系列和打家劫舍系列的不同点在于，股票问题的每一个系列问题都对状态转移方程进行了改动。面临一道动态规划问题时，要想迅速找到子问题并写出状态转移方程，关键还是要多了解不同的动归题型。",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/'> <img src='/images/covers/village.jpg' alt='动态规划（三）股票问题系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2021-09-29T20:29:46+08:00'>Sep 29, 2021</time> </span> </div><h2 class='article__title'>动态规划（三）股票问题系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "二叉树基础（一）二叉树的概念",
      "category" : "",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/",
      "date"     : "Sep 28, 2021",
      "content"  : "概念二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。二叉树的定义二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树基本形态  空二叉树  只有一个根节点的二叉树  根节点只有左子树的二叉树  根节点只有右子树的二叉树  根节点既有左子树，又有右子树的完全二叉树    特殊类型    满二叉树：只有度为0和2的节点，且度为0的结点在同一层上  完全二叉树：深度为k且每一个节点都与深度为k的满二叉树中编号从1到n的结点一一对应    相关术语    节点：包含一个数据元素及若干指向子树分支的信息  节点的度：一个节点拥有子树的数目  叶节点：也称为终端节点，没有子树的节点或度为0的节点  分支节点：也称为非终端节点，度不为0的节点  树的度：树中所有节点度的最大值  节点的层次：从根节点开始，根节点为第0层，根节点的子节点为第1层，依此类推  树的深度：也称树的高度，树中所有节点层次的最大值  有序树：如果树中各棵子树的次序有先后次序，则该树为有序树  无序树：如果树中各棵子树的次序没有先后次序，则该树为无序树  森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根结点删除，则该树就变成了一片森林，森林中的树由原来根结点的各棵子树构成    性质    一棵二叉树的第i层最多有$2^i$个节点 $(i≥0)$  深度为k的二叉树最多有$2^{k+1}-1$个节点 $(k≥0)$  对于1棵二叉树，度为0的节点为$n_0$，度为2的节点为$n_2$，则$n_0=n_2+1$  满二叉树定理：非空满二叉树的叶子节点数等于分支节点数$+1$  满二叉树定理推论：在一棵具有$n$个结点的二叉树中,所有结点的空子树等于$n+1$  $n$个节点的完全二叉树高度为$log_2(n+1)$，深度为$log_2(n+1)-1$二叉树的C++实现二叉树的顺序存储我们可以使用一个数组来存储所有的节点，按数组下标进行存储，根节点存储在下标\(0\)处，其左孩子存储于下标\(2*0+1\)，右孩子存储于下标\(2*0+2\)….依此类推，对于下标为\(i\)的节点，左右孩子分别存储于下标为\({2*i+1}\)和\({2*i+2}\)处。实现代码typedef int BinaryTree[MAX];void CreateBinaryTree(BinaryTree tree, int i) {    if (i &gt;= MAX) return;    int input;    cin &gt;&gt; tree[i];    CreateBinaryTree(tree,2*i+1);    CreateBinaryTree(tree,2*i+2);}二叉树的链式存储二叉树的顺序存储结构一般适用于完全二叉树，通常我们使用链式存储结构表示二叉树。实现代码typedef struct Node {    int data;                     // 数据    struct Node *lchild, *rchild; // 左右子树} * BinaryTree, BtNode;void CreateBinaryTree(BinaryTree &amp;tree) {    int input;    cin &gt;&gt; input;    if (input == -1) {        tree = NULL;        return;    }    tree = new BtNode;    tree-&gt;data = input;    CreateBinaryTree(tree-&gt;lchild);    CreateBinaryTree(tree-&gt;rchild);}二叉树的递归遍历先序遍历（DLR）若二叉树为空，则空操作，否则：  访问当前节点  先序遍历左子树  先序遍历右子树void DLR(BinaryTree tree) {    if (tree) {        cout &lt;&lt; tree-&gt;data &lt;&lt; endl;        DLR(tree-&gt;lchild);        DLR(tree-&gt;rchild);    }}中序遍历（LDR）若二叉树为空，则空操作，否则：  中序遍历左子树  访问当前节点  中序遍历右子树void LDR(BinaryTree tree) {    if (tree) {        LDR(tree-&gt;lchild);        cout &lt;&lt; tree-&gt;data &lt;&lt; endl;        LDR(tree-&gt;rchild);    }}后序遍历（LRD）若二叉树为空，则空操作，否则：  后序遍历左子树  后序遍历右子树  访问当前节点void LRD(BinaryTree tree) {    if (tree) {        LRD(tree-&gt;lchild);        LRD(tree-&gt;rchild);        cout &lt;&lt; tree-&gt;data &lt;&lt; endl;    }}",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/'> <img src='https://api.dujin.org/bing/1920.php' alt='二叉树基础（一）二叉树的概念'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2021-09-28T13:58:19+08:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（一）二叉树的概念</h2> <p class='article__excerpt'>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "动态规划（二）最优子序列系列",
      "category" : "",
      "tags"     : "算法 and 动态规划",
      "url"      : "/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 28, 2021",
      "content"  : "动态规划核心思想动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。我们可以举个例子：  A: 1+1+1+1+1+1+1+1 = ?  B ( 计算 ) : 8  A: 在上面等式的左边写上 “1+” 呢？  B (脱口而出): 9  A: 你怎么这么快就得到答案了？  B: 只要在8的基础上加1就好了  A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间198. 打家劫舍  只有一间房屋时，我们选择偷这间房屋  存在两间房屋时，选择偷两间中较大的那间  如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间  将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：          偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和      不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额      我们总会选择1、2中可以得到更高金额的选项，这时我们用$d[i]$来表示偷窃前i间房子的总金额，并且用$d[i]$来表示选项1、2:\[\begin{equation}\left\{\begin{aligned}%\nonumber&amp;d[i] = d[i-2] + nums[i], \\&amp;d[i] = d[i-1].\end{aligned}\right.\end{equation}\]hello",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/'> <img src='/images/covers/village.jpg' alt='动态规划（二）最优子序列系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-28T11:12:38+08:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>动态规划（二）最优子序列系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
    } ,
  
    {
      "title"    : "动态规划（一）打家劫舍系列",
      "category" : "",
      "tags"     : "算法 and 动态规划",
      "url"      : "/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 27, 2021",
      "content"  : "动态规划核心思想动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。我们可以举个例子：  A: 1+1+1+1+1+1+1+1 = ?  B ( 计算 ) : 8  A: 在上面等式的左边写上 “1+” 呢？  B (脱口而出): 9  A: 你怎么这么快就得到答案了？  B: 只要在8的基础上加1就好了  A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间198. 打家劫舍  只有一间房屋时，我们选择偷这间房屋  存在两间房屋时，选择偷两间中较大的那间  如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间  将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：          偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和      不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额      我们总会选择1、2中可以得到更高金额的选项，这时我们用\(d[i]\)来表示偷窃前i间房子的总金额，并且用\(d[i]\)来表示选项1、2:\[\begin{equation}\left\{\begin{aligned}%\nonumber&amp;d[i] = d[i-2] + nums[i], \\&amp;d[i] = d[i-1].\end{aligned}\right.\end{equation}\]hello",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/'> <img src='/images/covers/village.jpg' alt='动态规划（一）打家劫舍系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-27T20:12:45+08:00'>Sep 27, 2021</time> </span> </div><h2 class='article__title'>动态规划（一）打家劫舍系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
    } 
  
]
