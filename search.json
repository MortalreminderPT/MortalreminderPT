[
  
    {
      "title"    : "使用DiskGenius进行系统迁移",
      "category" : "",
      "tags"     : "磁盘管理",
      "url"      : "/2023/10/12/%E4%BD%BF%E7%94%A8DiskGenius%E8%BF%81%E7%A7%BBC%E7%9B%98/",
      "date"     : "Oct 12, 2023",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#引言\" id=\"markdown-toc-引言\">引言</a></li>\n  <li><a href=\"#系统盘迁移\" id=\"markdown-toc-系统盘迁移\">系统盘迁移</a>    <ol>\n      <li><a href=\"#diskgenius简介\" id=\"markdown-toc-diskgenius简介\">DiskGenius简介</a></li>\n      <li><a href=\"#磁盘格式化\" id=\"markdown-toc-磁盘格式化\">磁盘格式化</a></li>\n      <li><a href=\"#系统迁移\" id=\"markdown-toc-系统迁移\">系统迁移</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#修改启动顺序\" id=\"markdown-toc-修改启动顺序\">修改启动顺序</a></li>\n</ol>\n\n<h2 id=\"引言\">引言</h2>\n\n<p>博主在本科四年来一直饱受硬盘空间不足的折磨，最近终于有机会加装一块固态硬盘。\n安装过程中，相对繁琐的是系统盘的迁移过程。\n因此我将迁移过程记录于此，或许之后还能用到。</p>\n\n<h2 id=\"系统盘迁移\">系统盘迁移</h2>\n\n<h3 id=\"diskgenius简介\">DiskGenius简介</h3>\n\n<p>DiskGenius（<a href=\"https://www.diskgenius.cn/download.php\">中文版</a> <code>&#124;</code> <a href=\"https://www.diskgenius.com/download.php\">English</a>）是一款常用的专业级磁盘管理软件。\n其包括分区管理，备份还原等使用功能，在本文中我们使用此工具完成系统盘的迁移。</p>\n\n<h3 id=\"磁盘格式化\">磁盘格式化</h3>\n\n<p>在装入新磁盘后，首先对其进行格式化，选择NTFS存储格式。\n而为了避免经常清理C盘的麻烦，我这里选择不分卷。</p>\n\n<h3 id=\"系统迁移\">系统迁移</h3>\n\n<p>安装DiskGenius后，选择其菜单栏中的系统迁移功能。</p>\n\n<p><img src=\"\\images\\posts\\diskGenius-0.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>随后选中原来的系统分区，一般为C盘；随后选择转移的目标磁盘，即我们刚才所格式化的盘。</p>\n\n<p>系统迁移可以选择PE环境或者热迁移。\n由于我没有对其热迁移进行深入研究，我选择更稳健的PE环境进行迁移。</p>\n\n<p>等待一段时间后，系统盘迁移完成。</p>\n\n<h2 id=\"修改启动顺序\">修改启动顺序</h2>\n\n<p>最后的工作为修改硬盘的启动顺序，首先进入BIOS环境（因电脑型号不同而异，我这里为开机过程中按F2）。</p>\n\n<p>在Boot菜单中修改系统启动优先级，将新安装的硬盘优先级与原硬盘互换即可。</p>\n\n<p>重新启动后进行测试，迁移后的系统盘使用顺畅，与迁移前无异。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/10/12/%E4%BD%BF%E7%94%A8DiskGenius%E8%BF%81%E7%A7%BBC%E7%9B%98/'> <img src='https://bing.biturl.top/?resolution=1920&format=image&index=0&mkt=zh-CN' alt='使用DiskGenius进行系统迁移'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2023-10-12T18:54:54+08:00'>Oct 12, 2023</time> </span> </div><h2 class='article__title'>使用DiskGenius进行系统迁移</h2> <p class='article__excerpt'></p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/磁盘管理' class='article__tag'>磁盘管理</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "使用ChatGPT控制Arduino设备",
      "category" : "",
      "tags"     : "ChatGPT, Arduino, and 智能家庭",
      "url"      : "/2023/04/24/%E4%BD%BF%E7%94%A8ChatGPT%E6%8E%A7%E5%88%B6Arduino%E8%AE%BE%E5%A4%87/",
      "date"     : "Apr 24, 2023",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#chatgpt接入\" id=\"markdown-toc-chatgpt接入\">ChatGPT接入</a>    <ol>\n      <li><a href=\"#prompt编写与测试\" id=\"markdown-toc-prompt编写与测试\">Prompt编写与测试</a></li>\n      <li><a href=\"#openai-api接入\" id=\"markdown-toc-openai-api接入\">OpenAI API接入</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#基于flask搭建服务器\" id=\"markdown-toc-基于flask搭建服务器\">基于Flask搭建服务器</a>    <ol>\n      <li><a href=\"#flask框架搭建\" id=\"markdown-toc-flask框架搭建\">Flask框架搭建</a></li>\n      <li><a href=\"#添加用户api\" id=\"markdown-toc-添加用户api\">添加用户API</a></li>\n      <li><a href=\"#arduino-api\" id=\"markdown-toc-arduino-api\">Arduino API</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#使用mongodb存储设备状态\" id=\"markdown-toc-使用mongodb存储设备状态\">使用MongoDB存储设备状态</a>    <ol>\n      <li><a href=\"#mongodb数据库结构\" id=\"markdown-toc-mongodb数据库结构\">MongoDB数据库结构</a></li>\n      <li><a href=\"#flask接入mongodb\" id=\"markdown-toc-flask接入mongodb\">Flask接入MongoDB</a></li>\n      <li><a href=\"#与数据库的交互及数据缓存\" id=\"markdown-toc-与数据库的交互及数据缓存\">与数据库的交互及数据缓存</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#编写qqbot实现qq平台控制\" id=\"markdown-toc-编写qqbot实现qq平台控制\">编写QQbot实现QQ平台控制</a></li>\n  <li><a href=\"#arduino状态控制\" id=\"markdown-toc-arduino状态控制\">Arduino状态控制</a>    <ol>\n      <li><a href=\"#arduino设备代码实现\" id=\"markdown-toc-arduino设备代码实现\">Arduino设备代码实现</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#结果展示\" id=\"markdown-toc-结果展示\">结果展示</a></li>\n</ol>\n\n<p>这篇博客中将介绍如何使用ChatGPT来控制Arduino设备。ChatGPT是由OpenAI开发的一种自然语言处理模型，其强大的功能引发了很大的讨论。本文介绍了ChatGPT与外部系统集成的一种方法，通过ChatGPT作为控制器实现对Arduino设备的控制，以探索自然语言命令控制家庭设备的可能性及智能家庭设备的发展方向。</p>\n\n<p>这篇博客的代码公开在我的github仓库，<a href=\"https://github.com/MortalreminderPT/HomeGPT-Intelligent-Home-Assistant\">点此链接</a>传送至该项目。</p>\n\n<h2 id=\"chatgpt接入\">ChatGPT接入</h2>\n\n<h3 id=\"prompt编写与测试\">Prompt编写与测试</h3>\n\n<p>我们期望ChatGPT以json格式输出命令实现对设备的控制，因此首先需要编写一个合适的提示（prompt），用于告诉ChatGPT我们的需求。在这个提示中，我们应该明确表达我们希望ChatGPT理解并回答的问题，如打开/关闭LED灯、控制电机转速等。经过数次测试之后，我们使用python代码整合了我们的全部需求，</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">generate_prompt</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"p\">):</span>\n    <span class=\"n\">possible_device</span> <span class=\"o\">=</span> <span class=\"p\">[</span>\n        <span class=\"p\">{</span>\n            <span class=\"sh\">'</span><span class=\"s\">light</span><span class=\"sh\">'</span><span class=\"p\">:</span><span class=\"sh\">'</span><span class=\"s\">0 close,1 open</span><span class=\"sh\">'</span>\n        <span class=\"p\">},</span>\n        <span class=\"p\">{</span>\n            <span class=\"sh\">'</span><span class=\"s\">air-conditioner</span><span class=\"sh\">'</span><span class=\"p\">:</span><span class=\"sh\">'</span><span class=\"s\">0 close,1 open</span><span class=\"sh\">'</span>\n        <span class=\"p\">},</span>\n        <span class=\"p\">{</span>\n            <span class=\"sh\">'</span><span class=\"s\">curtain</span><span class=\"sh\">'</span><span class=\"p\">:</span> <span class=\"sh\">'</span><span class=\"s\">0 close,1 open</span><span class=\"sh\">'</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">]</span>\n    <span class=\"n\">prompt</span> <span class=\"o\">=</span> <span class=\"sa\">f</span><span class=\"sh\">'</span><span class=\"s\">As an Intelligent Assistant you need to rely on my words to determine what to do with some of devices.</span><span class=\"se\">\\n</span><span class=\"sh\">'</span> \\\n             <span class=\"sa\">f</span><span class=\"sh\">'</span><span class=\"si\">{</span><span class=\"n\">text</span><span class=\"si\">}</span><span class=\"se\">\\n</span><span class=\"sh\">'</span> \\\n             <span class=\"sa\">f</span><span class=\"sh\">'</span><span class=\"s\">your reply contain a list with json [device] only from these devices: </span><span class=\"si\">{</span><span class=\"n\">possible_device</span><span class=\"si\">}</span><span class=\"sh\">'</span> \\\n             <span class=\"sa\">f</span><span class=\"sh\">'</span><span class=\"s\"> and only write json list without any discourse.</span><span class=\"sh\">'</span>\n    <span class=\"k\">return</span> <span class=\"n\">prompt</span>\n</code></pre></div></div>\n\n<p>在ChatGPT官网测试该提示词，发现ChatGPT可以正确理解我们的需求并做出回应。</p>\n\n<p><img src=\"\\images\\posts\\gpt1.jpg\" style=\"   display: block;   margin-left: auto;   margin-right: auto;    zoom:50%;\" /></p>\n\n<p>此时，我们相信ChatGPT可以集成到我们的项目中。</p>\n\n<h3 id=\"openai-api接入\">OpenAI API接入</h3>\n\n<p>OpenAI提供了官方API，以实现通过发送请求与ChatGPT进行实时交互。</p>\n\n<p>首先，我们需要获得OpenAI API的访问密钥。在OpenAI的开发者门户网站上可以注册一个账户并获取API密钥。将API密钥保存在安全的地方，因为它将用于与OpenAI API进行通信。</p>\n\n<p>接下来，我们可以通过引入OpenAI API包来实现与ChatGPT的交互，这个过程仍然被放在了一个函数中：</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">def</span> <span class=\"nf\">get_reply</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"p\">,</span> <span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"bp\">True</span><span class=\"p\">,</span> <span class=\"n\">mask_reply</span> <span class=\"o\">=</span> <span class=\"bp\">None</span><span class=\"p\">):</span>\n    <span class=\"k\">if</span> <span class=\"n\">mask</span><span class=\"p\">:</span>\n        <span class=\"k\">return</span> <span class=\"n\">json</span><span class=\"p\">.</span><span class=\"nf\">dumps</span><span class=\"p\">(</span><span class=\"n\">mask_reply</span><span class=\"p\">)</span>\n    <span class=\"k\">with</span> <span class=\"nf\">open</span><span class=\"p\">(</span><span class=\"sh\">'</span><span class=\"s\">OPENAI_API_KEY</span><span class=\"sh\">'</span><span class=\"p\">)</span> <span class=\"k\">as</span> <span class=\"n\">key</span><span class=\"p\">:</span>\n        <span class=\"n\">openai</span><span class=\"p\">.</span><span class=\"n\">api_key</span> <span class=\"o\">=</span> <span class=\"n\">key</span><span class=\"p\">.</span><span class=\"nf\">read</span><span class=\"p\">().</span><span class=\"nf\">rstrip</span><span class=\"p\">(</span><span class=\"sh\">'</span><span class=\"se\">\\n</span><span class=\"sh\">'</span><span class=\"p\">)</span>\n        <span class=\"n\">completions</span> <span class=\"o\">=</span> <span class=\"n\">openai</span><span class=\"p\">.</span><span class=\"n\">ChatCompletion</span><span class=\"p\">.</span><span class=\"nf\">create</span><span class=\"p\">(</span>\n            <span class=\"n\">model</span><span class=\"o\">=</span><span class=\"sh\">\"</span><span class=\"s\">gpt-3.5-turbo</span><span class=\"sh\">\"</span><span class=\"p\">,</span>\n            <span class=\"n\">messages</span><span class=\"o\">=</span><span class=\"p\">[</span>\n                <span class=\"p\">{</span><span class=\"sh\">\"</span><span class=\"s\">role</span><span class=\"sh\">\"</span><span class=\"p\">:</span> <span class=\"sh\">\"</span><span class=\"s\">user</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"sh\">\"</span><span class=\"s\">content</span><span class=\"sh\">\"</span><span class=\"p\">:</span> <span class=\"n\">prompt</span><span class=\"p\">}</span>\n            <span class=\"p\">],</span>\n            <span class=\"n\">temperature</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n            <span class=\"n\">n</span><span class=\"o\">=</span><span class=\"mi\">1</span><span class=\"p\">,</span>\n            <span class=\"n\">max_tokens</span><span class=\"o\">=</span><span class=\"mi\">100</span>\n        <span class=\"p\">)</span>\n        <span class=\"n\">message</span> <span class=\"o\">=</span> <span class=\"n\">completions</span><span class=\"p\">.</span><span class=\"n\">choices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">message</span><span class=\"p\">.</span><span class=\"n\">content</span>\n        <span class=\"k\">return</span> <span class=\"n\">message</span>\n</code></pre></div></div>\n\n<p>执行代码并观察输出结果，发现我们成功与ChatGPT完成交互。</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>In: As an Intelligent Assistant you need to rely on my words to determine what to <span class=\"k\">do </span>with some of devices.\n我很冷，你可以帮我些什么吗\nyour reply contain a list with json <span class=\"o\">[{</span><span class=\"s2\">\"device\"</span>:<span class=\"s2\">\"device_1\"</span>,<span class=\"s2\">\"param\"</span>:0<span class=\"o\">}]</span> only from these devices: <span class=\"o\">[{</span><span class=\"s1\">'light'</span>: <span class=\"s1\">'0 close,1 open'</span><span class=\"o\">}</span>, <span class=\"o\">{</span><span class=\"s1\">'air-conditioner'</span>: <span class=\"s1\">'0 close,1 open'</span><span class=\"o\">}</span>, <span class=\"o\">{</span><span class=\"s1\">'curtain'</span>: <span class=\"s1\">'0 close,1 open'</span><span class=\"o\">}]</span> and only write json list without any discourse.\n\nOut: <span class=\"o\">[{</span><span class=\"s2\">\"device\"</span>:<span class=\"s2\">\"air-conditioner\"</span>,<span class=\"s2\">\"param\"</span>:1<span class=\"o\">}]</span>\n</code></pre></div></div>\n\n<h2 id=\"基于flask搭建服务器\">基于Flask搭建服务器</h2>\n<p>在上一部分中，我们完成了与ChatGPT的对话和集成。为了便于用户的使用及与Arduino的交互，我们将使用Flask框架搭建一个服务器，以通过网络实现交互。</p>\n\n<h3 id=\"flask框架搭建\">Flask框架搭建</h3>\n<p>Flask是一个轻量级的Python Web框架，非常适合用于构建简单的Web应用程序。我们将使用Flask来搭建一个简单的服务器，以接收用户或Arduino的请求。</p>\n\n<p>首先，我们需要安装Flask。可以使用pip命令来安装Flask：</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pip <span class=\"nb\">install </span>flask\n</code></pre></div></div>\n\n<p>随后创建Flask主文件：</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"n\">flask</span> <span class=\"kn\">import</span> <span class=\"n\">Flask</span>\n<span class=\"kn\">import</span> <span class=\"n\">flask_restful</span> <span class=\"k\">as</span> <span class=\"n\">restful</span>\n<span class=\"n\">app</span> <span class=\"o\">=</span> <span class=\"nc\">Flask</span><span class=\"p\">(</span><span class=\"n\">__name__</span><span class=\"p\">)</span>\n<span class=\"n\">api</span> <span class=\"o\">=</span> <span class=\"n\">restful</span><span class=\"p\">.</span><span class=\"nc\">Api</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">,</span> <span class=\"n\">default_mediatype</span><span class=\"o\">=</span><span class=\"sh\">\"</span><span class=\"s\">application/json</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n<span class=\"k\">if</span> <span class=\"n\">__name__</span> <span class=\"o\">==</span> <span class=\"sh\">'</span><span class=\"s\">__main__</span><span class=\"sh\">'</span><span class=\"p\">:</span>\n    <span class=\"n\">app</span><span class=\"p\">.</span><span class=\"nf\">run</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p>此时RESTful风格Flask框架已经搭建完成，我们需要为其添加用户及Arduino交互接口。</p>\n<h3 id=\"添加用户api\">添加用户API</h3>\n<p>定义一个用户API文件order.py，用于向服务器发送请求并获取响应。核心代码如下所示：</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">OrderApi</span><span class=\"p\">(</span><span class=\"n\">Resource</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">post</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">text_dict</span> <span class=\"o\">=</span> <span class=\"nc\">RequestParser</span><span class=\"p\">()</span>\\\n            <span class=\"p\">.</span><span class=\"nf\">add_argument</span><span class=\"p\">(</span><span class=\"sh\">'</span><span class=\"s\">text</span><span class=\"sh\">'</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">location</span><span class=\"o\">=</span><span class=\"sh\">'</span><span class=\"s\">json</span><span class=\"sh\">'</span><span class=\"p\">,</span> <span class=\"n\">required</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span> \\\n            <span class=\"p\">.</span><span class=\"nf\">add_argument</span><span class=\"p\">(</span><span class=\"sh\">'</span><span class=\"s\">device</span><span class=\"sh\">'</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"nb\">str</span><span class=\"p\">,</span> <span class=\"n\">location</span><span class=\"o\">=</span><span class=\"sh\">'</span><span class=\"s\">json</span><span class=\"sh\">'</span><span class=\"p\">,</span> <span class=\"n\">required</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span>\\\n            <span class=\"p\">.</span><span class=\"nf\">add_argument</span><span class=\"p\">(</span><span class=\"sh\">'</span><span class=\"s\">param</span><span class=\"sh\">'</span><span class=\"p\">,</span> <span class=\"nb\">type</span><span class=\"o\">=</span><span class=\"nb\">float</span><span class=\"p\">,</span> <span class=\"n\">location</span><span class=\"o\">=</span><span class=\"sh\">'</span><span class=\"s\">json</span><span class=\"sh\">'</span><span class=\"p\">,</span> <span class=\"n\">required</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">)</span>\\\n            <span class=\"p\">.</span><span class=\"nf\">parse_args</span><span class=\"p\">()</span>\n            \n        <span class=\"n\">mask_reply</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n        <span class=\"k\">if</span> <span class=\"n\">text_dict</span><span class=\"p\">[</span><span class=\"sh\">'</span><span class=\"s\">device</span><span class=\"sh\">'</span><span class=\"p\">]</span> <span class=\"ow\">and</span> <span class=\"n\">text_dict</span><span class=\"p\">[</span><span class=\"sh\">'</span><span class=\"s\">param</span><span class=\"sh\">'</span><span class=\"p\">]</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"bp\">None</span><span class=\"p\">:</span>\n            <span class=\"n\">mask_reply</span><span class=\"p\">.</span><span class=\"nf\">append</span><span class=\"p\">({</span><span class=\"sh\">'</span><span class=\"s\">device</span><span class=\"sh\">'</span><span class=\"p\">:</span><span class=\"n\">text_dict</span><span class=\"p\">[</span><span class=\"sh\">'</span><span class=\"s\">device</span><span class=\"sh\">'</span><span class=\"p\">],</span> <span class=\"sh\">'</span><span class=\"s\">param</span><span class=\"sh\">'</span><span class=\"p\">:</span><span class=\"n\">text_dict</span><span class=\"p\">[</span><span class=\"sh\">'</span><span class=\"s\">param</span><span class=\"sh\">'</span><span class=\"p\">]})</span>\n\n        <span class=\"n\">prompt</span><span class=\"o\">=</span><span class=\"nf\">generate_prompt</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">text_dict</span><span class=\"p\">[</span><span class=\"sh\">'</span><span class=\"s\">text</span><span class=\"sh\">'</span><span class=\"p\">])</span>\n        <span class=\"n\">reply</span><span class=\"o\">=</span><span class=\"nf\">get_reply</span><span class=\"p\">(</span><span class=\"n\">prompt</span><span class=\"o\">=</span><span class=\"n\">prompt</span><span class=\"p\">,</span>\n                        <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"bp\">False</span><span class=\"p\">,</span>\n                        <span class=\"n\">mask_reply</span><span class=\"o\">=</span><span class=\"n\">mask_reply</span><span class=\"p\">)</span>\n        <span class=\"n\">update_state</span><span class=\"o\">=</span><span class=\"nf\">match_json</span><span class=\"p\">(</span><span class=\"n\">text</span><span class=\"o\">=</span><span class=\"n\">reply</span><span class=\"p\">)</span>\n        <span class=\"k\">return</span> <span class=\"n\">device_states</span><span class=\"p\">.</span><span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">update_state</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>随后我们需要在主文件中注册API文件：</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">api</span><span class=\"p\">.</span><span class=\"nf\">add_resource</span><span class=\"p\">(</span><span class=\"n\">OrderApi</span><span class=\"p\">,</span> <span class=\"sh\">'</span><span class=\"s\">/</span><span class=\"sh\">'</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>此时用户可以通过POST请求实现对Arduino设备状态的控制。</p>\n<h3 id=\"arduino-api\">Arduino API</h3>\n\n<p>Arduino设备主要工作内容为读取当前设备工作状态并做出对应调整，因此只需编写简单GET请求响应：</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">ArduinoApi</span><span class=\"p\">(</span><span class=\"n\">Resource</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">return</span> <span class=\"n\">device_states</span><span class=\"p\">.</span><span class=\"nf\">get</span><span class=\"p\">()</span>\n</code></pre></div></div>\n\n<p>同样在主文件中注册API文件：</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">api</span><span class=\"p\">.</span><span class=\"nf\">add_resource</span><span class=\"p\">(</span><span class=\"n\">ArduinoApi</span><span class=\"p\">,</span> <span class=\"sh\">'</span><span class=\"s\">/arduino</span><span class=\"sh\">'</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>通过Postman测试，发现可以服务器已经可以正常工作。</p>\n\n<p><img src=\"\\images\\posts\\gpt2.jpg\" style=\"   display: block;   margin-left: auto;   margin-right: auto;    zoom:50%;\" /></p>\n\n<h2 id=\"使用mongodb存储设备状态\">使用MongoDB存储设备状态</h2>\n\n<p>为了防止停电等因素对设备开关记忆的影响，我们使用数据库对设备状态进行持久化。MongoDB作为一种基于键值对的通用NoSQL数据库，非常适合实现这个需求。</p>\n\n<h3 id=\"mongodb数据库结构\">MongoDB数据库结构</h3>\n<p>在我们开始之前，我们需要定义设备状态的数据结构。在这个例子中，我们假设我们的设备有一个LED灯，可以打开或关闭。我们可以使用以下JSON格式来表示设备状态：</p>\n\n<div class=\"language-json highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"p\">{</span><span class=\"nl\">\"device\"</span><span class=\"p\">:</span><span class=\"s2\">\"light\"</span><span class=\"p\">,</span><span class=\"nl\">\"param\"</span><span class=\"p\">:</span><span class=\"mf\">1.0</span><span class=\"p\">}</span><span class=\"w\">\n</span></code></pre></div></div>\n\n<p>在上面的示例中，device是设备的唯一标识符，param表示LED灯的状态。</p>\n\n<h3 id=\"flask接入mongodb\">Flask接入MongoDB</h3>\n<p>为了与MongoDB进行交互，我们将使用MongoDB的官方Python驱动程序pymongo。我们需要先安装它：</p>\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pip <span class=\"nb\">install </span>pymongo\n</code></pre></div></div>\n<p>接下来，我们需要在Flask应用程序中添加与MongoDB的连接和数据访问逻辑。</p>\n\n<p>在app.py文件中添加pymongo库：</p>\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">from</span> <span class=\"n\">flask_pymongo</span> <span class=\"kn\">import</span> <span class=\"n\">PyMongo</span>\n<span class=\"n\">mongo</span> <span class=\"o\">=</span> <span class=\"nc\">PyMongo</span><span class=\"p\">(</span><span class=\"n\">app</span><span class=\"p\">,</span> <span class=\"n\">uri</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"p\">.</span><span class=\"n\">MONGO_URI</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<h3 id=\"与数据库的交互及数据缓存\">与数据库的交互及数据缓存</h3>\n\n<p>我们编写一个DeviceStates类与数据库进行交互，为了提升设备响应的即时性，我们还可以给数据库添加缓存。</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">DeviceStates</span><span class=\"p\">(</span><span class=\"nb\">object</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span> <span class=\"nf\">__init__</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">state</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">_flash</span> <span class=\"o\">=</span> <span class=\"bp\">False</span>\n        <span class=\"k\">pass</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">get</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">):</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">_flash</span><span class=\"p\">:</span>\n            <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">_flash</span> <span class=\"o\">=</span> <span class=\"bp\">True</span>\n            <span class=\"k\">for</span> <span class=\"n\">device_state</span> <span class=\"ow\">in</span> <span class=\"nf\">list</span><span class=\"p\">(</span><span class=\"n\">devices</span><span class=\"p\">.</span><span class=\"nf\">find</span><span class=\"p\">(</span><span class=\"n\">projection</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"sh\">'</span><span class=\"s\">_id</span><span class=\"sh\">'</span><span class=\"p\">:</span> <span class=\"mi\">0</span><span class=\"p\">})):</span>\n                <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">state</span><span class=\"p\">[</span><span class=\"n\">device_state</span><span class=\"p\">[</span><span class=\"sh\">'</span><span class=\"s\">device</span><span class=\"sh\">'</span><span class=\"p\">]]</span> <span class=\"o\">=</span> <span class=\"n\">device_state</span>\n        <span class=\"k\">return</span> <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">state</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">,</span> <span class=\"n\">update_dict</span><span class=\"p\">:</span><span class=\"n\">DeviceState</span><span class=\"p\">):</span>\n        <span class=\"k\">for</span> <span class=\"n\">update_device</span><span class=\"p\">,</span> <span class=\"n\">update_state</span> <span class=\"ow\">in</span> <span class=\"n\">update_dict</span><span class=\"p\">.</span><span class=\"nf\">items</span><span class=\"p\">():</span>\n            <span class=\"n\">devices</span><span class=\"p\">.</span><span class=\"nf\">update_one</span><span class=\"p\">({</span><span class=\"sa\">f</span><span class=\"sh\">'</span><span class=\"s\">_id</span><span class=\"sh\">'</span><span class=\"p\">:</span><span class=\"n\">update_device</span><span class=\"p\">},</span> <span class=\"p\">{</span><span class=\"sh\">'</span><span class=\"s\">$set</span><span class=\"sh\">'</span><span class=\"p\">:{</span><span class=\"o\">**</span><span class=\"n\">update_state</span><span class=\"p\">}},</span> <span class=\"n\">upsert</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n            <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">state</span><span class=\"p\">[</span><span class=\"n\">update_device</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">update_state</span>\n        <span class=\"k\">return</span> <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"nf\">get</span><span class=\"p\">()</span>\n\n    <span class=\"k\">def</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">,</span> <span class=\"nb\">all</span> <span class=\"o\">=</span> <span class=\"bp\">True</span><span class=\"p\">):</span>\n        <span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">state</span> <span class=\"o\">=</span> <span class=\"p\">{}</span>\n        <span class=\"k\">return</span> <span class=\"n\">devices</span><span class=\"p\">.</span><span class=\"nf\">delete_many</span><span class=\"p\">({}).</span><span class=\"n\">deleted_count</span>\n</code></pre></div></div>\n\n<h2 id=\"编写qqbot实现qq平台控制\">编写QQbot实现QQ平台控制</h2>\n<p>本节编写了一个简单的QQbot，用户可以在QQ平台与QQbot简单对话，完成对Arduino设备状态的控制。</p>\n\n<p>安装botpy包：</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>pip <span class=\"nb\">install </span>botpy\n</code></pre></div></div>\n\n<p>为QQbot编写交互代码如下：</p>\n\n<div class=\"language-python highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kn\">import</span> <span class=\"n\">asyncio</span>\n<span class=\"kn\">import</span> <span class=\"n\">os</span>\n\n<span class=\"kn\">import</span> <span class=\"n\">botpy</span>\n<span class=\"kn\">import</span> <span class=\"n\">requests</span>\n<span class=\"kn\">from</span> <span class=\"n\">botpy</span> <span class=\"kn\">import</span> <span class=\"n\">logging</span>\n<span class=\"kn\">from</span> <span class=\"n\">botpy.ext.cog_yaml</span> <span class=\"kn\">import</span> <span class=\"n\">read</span>\n<span class=\"kn\">from</span> <span class=\"n\">botpy.message</span> <span class=\"kn\">import</span> <span class=\"n\">Message</span>\n\n<span class=\"n\">test_config</span> <span class=\"o\">=</span> <span class=\"nf\">read</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"p\">.</span><span class=\"n\">path</span><span class=\"p\">.</span><span class=\"nf\">join</span><span class=\"p\">(</span><span class=\"n\">os</span><span class=\"p\">.</span><span class=\"n\">path</span><span class=\"p\">.</span><span class=\"nf\">dirname</span><span class=\"p\">(</span><span class=\"n\">__file__</span><span class=\"p\">),</span> <span class=\"sh\">\"</span><span class=\"s\">config.yaml</span><span class=\"sh\">\"</span><span class=\"p\">))</span>\n\n<span class=\"n\">_log</span> <span class=\"o\">=</span> <span class=\"n\">logging</span><span class=\"p\">.</span><span class=\"nf\">get_logger</span><span class=\"p\">()</span>\n<span class=\"n\">headers</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"sh\">'</span><span class=\"s\">accept-language</span><span class=\"sh\">'</span><span class=\"p\">:</span> <span class=\"sh\">'</span><span class=\"s\">zh-CN,zh;q=0.9,en;q=0.8</span><span class=\"sh\">'</span><span class=\"p\">,</span>\n    <span class=\"sh\">'</span><span class=\"s\">content-type</span><span class=\"sh\">'</span><span class=\"p\">:</span> <span class=\"sh\">'</span><span class=\"s\">application/json</span><span class=\"sh\">'</span><span class=\"p\">,</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">MyClient</span><span class=\"p\">(</span><span class=\"n\">botpy</span><span class=\"p\">.</span><span class=\"n\">Client</span><span class=\"p\">):</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">on_ready</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">):</span>\n        <span class=\"n\">_log</span><span class=\"p\">.</span><span class=\"nf\">info</span><span class=\"p\">(</span><span class=\"sa\">f</span><span class=\"sh\">\"</span><span class=\"s\">robot 「</span><span class=\"si\">{</span><span class=\"n\">self</span><span class=\"p\">.</span><span class=\"n\">robot</span><span class=\"p\">.</span><span class=\"n\">name</span><span class=\"si\">}</span><span class=\"s\">」 on_ready!</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n    <span class=\"k\">async</span> <span class=\"k\">def</span> <span class=\"nf\">on_at_message_create</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">:</span> <span class=\"n\">Message</span><span class=\"p\">):</span>\n        <span class=\"n\">_log</span><span class=\"p\">.</span><span class=\"nf\">info</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">.</span><span class=\"n\">author</span><span class=\"p\">.</span><span class=\"n\">avatar</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"sh\">\"</span><span class=\"s\">sleep</span><span class=\"sh\">\"</span> <span class=\"ow\">in</span> <span class=\"n\">message</span><span class=\"p\">.</span><span class=\"n\">content</span><span class=\"p\">:</span>\n            <span class=\"k\">await</span> <span class=\"n\">asyncio</span><span class=\"p\">.</span><span class=\"nf\">sleep</span><span class=\"p\">(</span><span class=\"mi\">10</span><span class=\"p\">)</span>\n        <span class=\"n\">_log</span><span class=\"p\">.</span><span class=\"nf\">info</span><span class=\"p\">(</span><span class=\"n\">message</span><span class=\"p\">.</span><span class=\"n\">author</span><span class=\"p\">.</span><span class=\"n\">username</span><span class=\"p\">)</span>\n        <span class=\"n\">url</span> <span class=\"o\">=</span> <span class=\"n\">test_config</span><span class=\"p\">[</span><span class=\"sh\">'</span><span class=\"s\">server</span><span class=\"sh\">'</span><span class=\"p\">]</span>\n        <span class=\"kn\">import</span> <span class=\"n\">re</span>\n        <span class=\"n\">text</span> <span class=\"o\">=</span> <span class=\"n\">re</span><span class=\"p\">.</span><span class=\"nf\">sub</span><span class=\"p\">(</span><span class=\"sh\">'</span><span class=\"s\">&lt;.*?&gt;</span><span class=\"sh\">'</span><span class=\"p\">,</span> <span class=\"sh\">''</span><span class=\"p\">,</span> <span class=\"n\">message</span><span class=\"p\">.</span><span class=\"n\">content</span><span class=\"p\">)</span>\n        <span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n            <span class=\"sh\">'</span><span class=\"s\">text</span><span class=\"sh\">'</span><span class=\"p\">:</span> <span class=\"n\">text</span><span class=\"p\">,</span>\n            <span class=\"sh\">'</span><span class=\"s\">device</span><span class=\"sh\">'</span><span class=\"p\">:</span> <span class=\"sh\">'</span><span class=\"s\">light</span><span class=\"sh\">'</span><span class=\"p\">,</span>\n            <span class=\"sh\">'</span><span class=\"s\">param</span><span class=\"sh\">'</span><span class=\"p\">:</span> <span class=\"mi\">1</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">response</span> <span class=\"o\">=</span> <span class=\"n\">requests</span><span class=\"p\">.</span><span class=\"nf\">request</span><span class=\"p\">(</span><span class=\"sh\">\"</span><span class=\"s\">POST</span><span class=\"sh\">\"</span><span class=\"p\">,</span> <span class=\"n\">url</span><span class=\"p\">,</span> <span class=\"n\">headers</span><span class=\"o\">=</span><span class=\"n\">headers</span><span class=\"p\">,</span> <span class=\"n\">json</span><span class=\"o\">=</span><span class=\"n\">data</span><span class=\"p\">)</span>\n        <span class=\"k\">await</span> <span class=\"n\">message</span><span class=\"p\">.</span><span class=\"nf\">reply</span><span class=\"p\">(</span><span class=\"n\">content</span><span class=\"o\">=</span><span class=\"sa\">f</span><span class=\"sh\">\"</span><span class=\"si\">{</span><span class=\"n\">response</span><span class=\"p\">.</span><span class=\"n\">content</span><span class=\"p\">.</span><span class=\"nf\">decode</span><span class=\"p\">(</span><span class=\"sh\">'</span><span class=\"s\">unicode_escape</span><span class=\"sh\">'</span><span class=\"p\">)</span><span class=\"si\">}</span><span class=\"sh\">\"</span><span class=\"p\">)</span>\n\n<span class=\"k\">if</span> <span class=\"n\">__name__</span> <span class=\"o\">==</span> <span class=\"sh\">\"</span><span class=\"s\">__main__</span><span class=\"sh\">\"</span><span class=\"p\">:</span>\n    <span class=\"n\">intents</span> <span class=\"o\">=</span> <span class=\"n\">botpy</span><span class=\"p\">.</span><span class=\"nc\">Intents</span><span class=\"p\">(</span><span class=\"n\">public_guild_messages</span><span class=\"o\">=</span><span class=\"bp\">True</span><span class=\"p\">)</span>\n    <span class=\"n\">client</span> <span class=\"o\">=</span> <span class=\"nc\">MyClient</span><span class=\"p\">(</span><span class=\"n\">intents</span><span class=\"o\">=</span><span class=\"n\">intents</span><span class=\"p\">)</span>\n    <span class=\"n\">client</span><span class=\"p\">.</span><span class=\"nf\">run</span><span class=\"p\">(</span><span class=\"n\">appid</span><span class=\"o\">=</span><span class=\"n\">test_config</span><span class=\"p\">[</span><span class=\"sh\">\"</span><span class=\"s\">appid</span><span class=\"sh\">\"</span><span class=\"p\">],</span> <span class=\"n\">token</span><span class=\"o\">=</span><span class=\"n\">test_config</span><span class=\"p\">[</span><span class=\"sh\">\"</span><span class=\"s\">token</span><span class=\"sh\">\"</span><span class=\"p\">])</span>\n</code></pre></div></div>\n\n<p>此时，我们可以在QQ频道与QQbot对话，以实现对Arduino设备的控制</p>\n\n<p><img src=\"\\images\\posts\\gpt3.jpg\" style=\"   display: block;   margin-left: auto;   margin-right: auto;    zoom:50%;\" /></p>\n\n<h2 id=\"arduino状态控制\">Arduino状态控制</h2>\n<p>在服务器及交互平台搭建完成后，本部分展示了Arduino设备代码实现，其原理主要为发出GET请求获取设备状态，随后通过字符串匹配控制设备的状态。</p>\n\n<h3 id=\"arduino设备代码实现\">Arduino设备代码实现</h3>\n\n<p><strong>这部分代码是由我的队友编写的，他速成了Arduino代码编写并实现了设备状态控制，感谢他在该项目的贡献。</strong></p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;ESP8266WiFi.h&gt;</span><span class=\"cp\">\n#include</span> <span class=\"cpf\">&lt;SoftwareSerial.h&gt;</span><span class=\"cp\">\n#include</span> <span class=\"cpf\">&lt;ESP8266HTTPClient.h&gt;</span><span class=\"cp\">\n#include</span> <span class=\"cpf\">&lt;ArduinoJson.h&gt;</span><span class=\"cp\">\n</span><span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span> <span class=\"n\">ssid</span><span class=\"p\">;</span> <span class=\"c1\">//Enter your Wi-Fi SSID</span>\n<span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"o\">*</span> <span class=\"n\">password</span><span class=\"p\">;</span> <span class=\"c1\">//Enter you Wi-Fi Password</span>\n<span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">check</span> <span class=\"o\">=</span> <span class=\"mi\">9</span><span class=\"p\">;</span>\n<span class=\"kt\">int</span> <span class=\"n\">ledpin</span> <span class=\"o\">=</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n<span class=\"n\">String</span> <span class=\"n\">Payload</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span><span class=\"p\">;</span>\n<span class=\"n\">define</span> <span class=\"n\">URL</span> <span class=\"s\">\"http://localhost:5000/arduino\"</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">setup</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">WiFi</span><span class=\"p\">.</span><span class=\"n\">mode</span><span class=\"p\">(</span><span class=\"n\">WIFI_STA</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"mi\">115200</span><span class=\"p\">);</span>\n    <span class=\"n\">pinMode</span><span class=\"p\">(</span><span class=\"n\">ledpin</span><span class=\"p\">,</span> <span class=\"n\">OUTPUT</span><span class=\"p\">);</span>\n    <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"n\">ledpin</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"开始连接\"</span><span class=\"p\">);</span>\n    <span class=\"n\">WiFi</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"n\">ssid</span><span class=\"p\">,</span> <span class=\"n\">password</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"正在连接到\"</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">ssid</span><span class=\"p\">);</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">WiFi</span><span class=\"p\">.</span><span class=\"n\">status</span><span class=\"p\">()</span> <span class=\"o\">!=</span> <span class=\"n\">WL_CONNECTED</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"mi\">1000</span><span class=\"p\">);</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"waiting for \"</span><span class=\"p\">);</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">);</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"s...\"</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"\"</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"WiFi connected!\"</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"IP address: \"</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">WiFi</span><span class=\"p\">.</span><span class=\"n\">localIP</span><span class=\"p\">());</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">loop</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">WiFiClient</span> <span class=\"n\">tcpClient</span><span class=\"p\">;</span>\n    <span class=\"n\">HTTPClient</span> <span class=\"n\">httpClient</span><span class=\"p\">;</span>\n    <span class=\"n\">httpClient</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"n\">tcpClient</span><span class=\"p\">,</span> <span class=\"n\">URL</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"URL: \"</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">URL</span><span class=\"p\">);</span>\n    <span class=\"kt\">int</span> <span class=\"n\">httpCode</span> <span class=\"o\">=</span> <span class=\"n\">httpClient</span><span class=\"p\">.</span><span class=\"n\">GET</span><span class=\"p\">();</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"Send GET request to URL: \"</span><span class=\"p\">);</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">URL</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">httpCode</span> <span class=\"o\">==</span> <span class=\"mi\">200</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">Payload</span> <span class=\"o\">=</span> <span class=\"n\">httpClient</span><span class=\"p\">.</span><span class=\"n\">getString</span><span class=\"p\">();</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"</span><span class=\"se\">\\r\\n</span><span class=\"s\">Server Respose Code: \"</span><span class=\"p\">);</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">httpCode</span><span class=\"p\">);</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"s\">\"Server Response Payload: \"</span><span class=\"p\">);</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">Payload</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"s\">\"</span><span class=\"se\">\\r\\n</span><span class=\"s\">Server Respose Code: \"</span><span class=\"p\">);</span>\n        <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">println</span><span class=\"p\">(</span><span class=\"n\">httpCode</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">httpClient</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">();</span>\n    <span class=\"n\">StaticJsonDocument</span> <span class=\"o\">&lt;</span> <span class=\"mi\">200</span> <span class=\"o\">&gt;</span> <span class=\"n\">doc</span><span class=\"p\">;</span>\n    <span class=\"n\">DeserializationError</span> <span class=\"n\">error</span> <span class=\"o\">=</span> <span class=\"n\">deserializeJson</span><span class=\"p\">(</span><span class=\"n\">doc</span><span class=\"p\">,</span> <span class=\"n\">Payload</span><span class=\"p\">);</span>\n    <span class=\"n\">check</span> <span class=\"o\">=</span> <span class=\"n\">doc</span><span class=\"p\">[</span><span class=\"s\">\"light\"</span><span class=\"p\">][</span><span class=\"s\">\"param\"</span><span class=\"p\">];</span>\n    <span class=\"n\">Serial</span><span class=\"p\">.</span><span class=\"n\">print</span><span class=\"p\">(</span><span class=\"n\">check</span><span class=\"p\">);</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">check</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"n\">ledpin</span><span class=\"p\">,</span> <span class=\"n\">HIGH</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">check</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">digitalWrite</span><span class=\"p\">(</span><span class=\"n\">ledpin</span><span class=\"p\">,</span> <span class=\"n\">LOW</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">Payload</span> <span class=\"o\">=</span> <span class=\"s\">\"\"</span><span class=\"p\">;</span>\n    <span class=\"n\">delay</span><span class=\"p\">(</span><span class=\"mi\">10000</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"结果展示\">结果展示</h2>\n\n<p>如图所示，在向QQbot提出需求后，ChatGPT成功接收并理解了我们的需求并将其转化为指令，Arduino设备状态也随之发生改变。</p>\n\n<p><img src=\"\\images\\posts\\gpt4.jpg\" style=\"   display: block;   margin-left: auto;   margin-right: auto;    zoom:50%;\" /></p>\n\n<p>ChatGPT在此次实验中的强大作用向我们展示了大语言模型在智能家庭的重大潜力。包括但不限于识别并发掘深度需求，多模态智能家居控制，个性化用户体验等多种潜在方向。</p>\n\n<p>同样，该项应用也存在隐私保护，数据安全等问题，需要人们的进一步思考和解决。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2023/04/24/%E4%BD%BF%E7%94%A8ChatGPT%E6%8E%A7%E5%88%B6Arduino%E8%AE%BE%E5%A4%87/'> <img src='https://bing.biturl.top/?resolution=1920&format=image&index=0&mkt=zh-CN' alt='使用ChatGPT控制Arduino设备'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>11 min read <time class='article__date' datetime='2023-04-24T00:00:00+08:00'>Apr 24, 2023</time> </span> </div><h2 class='article__title'>使用ChatGPT控制Arduino设备</h2> <p class='article__excerpt'>本文介绍了ChatGPT与外部系统集成的一种方法，通过ChatGPT作为控制器实现对Arduino设备的控制，以探索自然语言命令控制家庭设备的可能性及智能家庭设备的发展方向。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/ChatGPT' class='article__tag'>ChatGPT</a>  <a href='/tag/Arduino' class='article__tag'>Arduino</a>  <a href='/tag/智能家庭' class='article__tag'>智能家庭</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "设计模式（三）生成器（Builder）",
      "category" : "",
      "tags"     : "设计模式",
      "url"      : "/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%89-%E7%94%9F%E6%88%90%E5%99%A8-Builder/",
      "date"     : "Sep 10, 2022",
      "content"  : "<h2 id=\"意图\">意图</h2>\n<p>将一个复杂对象的<strong>构建与它的表示分离</strong>，使得<strong>同样构建过程可以创建不同的表示</strong></p>\n\n<h2 id=\"动机\">动机</h2>\n<p>一个RTF阅读器应该能将RTF转换为多种文本格式。\n该阅读器可以将RTF文档转换成ASCII文本或能以交互方式编辑的文本窗口组件。\n然而，可以转换的数目是无限的，因此要能够很容易实现新的转换的增加，而又不改变RTF阅读器。</p>\n\n<p>一个解决办法是用一个可以将RTF转换成另一种文本表示的TextConverter对象来配置这个RTFReader类。\n当RTFReader对RTF文档进行语法分析时，使用TextConverter去做转换。\n无论何时RTFReader识别了一个RTF标记（或是普通文本或是RTF控制字），它都将发送一个请求给TextConverter去转换这个标记。\nTextConverter对象负责进行数据转换以及用特定格式表示该标记，如图</p>\n\n<p>TextConverter的子类对不同转换和不同格式进行特殊处理。\n每种转换器类将创建和装配一个复杂对象的机制隐含在抽象接口后面。\n转换器独立于阅读器，阅读器负责对一个RTF文档进行语法分析。</p>\n\n<p>Builder模式描述了所有这些关系，每个<strong>转换器类在该模式中被称为生成器（Builder），而阅读器称为导向器（Director）</strong>。\n在上面的例子中，Builder模式将分析文本格式的算法（即RTF文档的语法分析程序）与描述怎样创建和表示一个转换后的格式的算法分离开来。\n这样我们可以复用RTFReader的语法分析算法，根据RTF文档创建不同的文本表示——仅需使用不同的TextConverter子类配置RTFReader即可。</p>\n\n<h2 id=\"适用性\">适用性</h2>\n<ul>\n  <li>当<strong>创建</strong>复杂对象的算法应当<strong>独立于该对象的组成部分以及它们的装配方式</strong>时；</li>\n  <li>当构造过程必须允许<strong>被构造的对象有不同的表示时</strong>。</li>\n</ul>\n\n<h2 id=\"结构\">结构</h2>\n\n<h2 id=\"参与者\">参与者</h2>\n<ol>\n  <li>Builder（TextConverter）\n    <ul>\n      <li>为创建一个Product对象的各个部件（Part）指定抽象接口</li>\n    </ul>\n  </li>\n  <li>ConcreteBuilder（ASCIIConverter、TeXConverter、TextWidgetConverter）\n    <ul>\n      <li>实现Builder的接口以构造和装配该产品的各个部件；</li>\n      <li>定义并追踪它所创建的表示；</li>\n      <li>提供一个检索产品的接口（例如GetASCIIText、GetTextWidget）</li>\n    </ul>\n  </li>\n  <li>Director（RTFReader）\n    <ul>\n      <li>构造一个使用Builder接口的对象</li>\n    </ul>\n  </li>\n  <li>Product（ASCIIText、TeXText、TextWidget）\n    <ul>\n      <li>表示被构造的复杂对象，ConcreteBuilder创建该产品的内部表示并定义它的装配过程；</li>\n      <li>包含定义组成部件的类，包括将这些部件装配成最终产品的接口。</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"协作\">协作</h2>\n<ul>\n  <li>用户创建Director对象，并用它所想要的Builder对象进行配置；</li>\n  <li>一旦生成了产品部件，Director就会通知Builder；</li>\n  <li>Builder处理Director的请求，并将部件添加到该产品中。</li>\n  <li>用户从Builder中检索产品。</li>\n</ul>\n\n<h2 id=\"效果\">效果</h2>\n<ul>\n  <li>改变一个产品的内部表示：</li>\n  <li>将构造代码和表示代码分开：</li>\n  <li>可以对构造过程进行更精细的控制：</li>\n</ul>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%89-%E7%94%9F%E6%88%90%E5%99%A8-Builder/'> <img src='/images/covers/操作系统-cover1.png' alt='设计模式（三）生成器（Builder）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-09-10T21:00:42+08:00'>Sep 10, 2022</time> </span> </div><h2 class='article__title'>设计模式（三）生成器（Builder）</h2> <p class='article__excerpt'></p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/设计模式' class='article__tag'>设计模式</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "设计模式（二）抽象工厂（Abstract Factory）",
      "category" : "",
      "tags"     : "设计模式",
      "url"      : "/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-Abstract-Factory/",
      "date"     : "Sep 10, 2022",
      "content"  : "<h2 id=\"意图\">意图</h2>\n<p>提供一个<strong>接口</strong>，以创建<strong>一系列相关或相互依赖的对象</strong>，而无须指定它们的具体的类</p>\n\n<h2 id=\"动机\">动机</h2>\n<p>在设计一套支持不同主题的GUI时，同一套主题的GUI下会包括滚动条，窗口和按钮等组件。\n为了保证主题的可移植性，一个应用不该为一个特定的主题硬编码组件，否则会使改变主题变得困难。</p>\n\n<p>因此，可以定义一个抽象的WidgetFactory类，声明用来创建基本窗口组件的接口。\n其中，每一个窗口组件都有抽象类，它们的子类则实现窗口组件的具体主题。\n用户通过WidgetFactory提供的接口获得窗口组件，但是用户并不知道其使用的具体类，因此用户不依赖于具体的主题。</p>\n\n<p>每一种主题对应一个具体的WidgetFactory子类，每个子类实现用于创建该主题的组件操作。\n<strong>客户仅与抽象类定义的接口交互，而不使用特定类的接口</strong></p>\n\n<h2 id=\"适用性\">适用性</h2>\n\n<ul>\n  <li>一个<strong>系统</strong>要<strong>独立于其产品</strong>的创建、组合和表示；</li>\n  <li>一个<strong>系统</strong>要由<strong>多个产品系列中的一个</strong>来配置；</li>\n  <li>要强调<strong>一系列相关产品的对象的设计</strong>以便进行<strong>联合使用</strong>；</li>\n  <li>提供一个<strong>产品类库</strong>，但只想<strong>显示它们的接口</strong>而不是实现。</li>\n</ul>\n\n<h2 id=\"结构\">结构</h2>\n\n<h2 id=\"参与者\">参与者</h2>\n\n<ol>\n  <li>AbstractFactory（WidgetFactory）\n    <ul>\n      <li>声明一个创建抽象产品对象的操作接口</li>\n    </ul>\n  </li>\n  <li>ConcreteFactory（MotifWidgetFactory、PMWidgetFactory）\n    <ul>\n      <li>实现创建具体产品对象的操作</li>\n    </ul>\n  </li>\n  <li>AbstractProduct（Window、ScrollBar）\n    <ul>\n      <li>为一类产品对象声明一个接口</li>\n    </ul>\n  </li>\n  <li>ConcreteProduct（MotifWindow、MotifScrollBar）\n    <ul>\n      <li>定义一个将被具体工厂创建的产品对象；</li>\n      <li>实现AbstractProduct接口</li>\n    </ul>\n  </li>\n  <li>Client\n    <ul>\n      <li>仅由AbstractFactory和AbstractProduct类声明的接口</li>\n    </ul>\n  </li>\n</ol>\n\n<h2 id=\"协作\">协作</h2>\n\n<ul>\n  <li>通常在运行时创建一个ConcreteFactory的实例，这一具体工厂创建具有特定实现的产品对象。为创建不同的产品对象，客户应该使用不同的具体工厂;</li>\n  <li>AbstractProduct将产品对象的创建延迟到它的ConcreteFactory子类</li>\n</ul>\n\n<h2 id=\"效果\">效果</h2>\n\n<ol>\n  <li><strong>分离了具体的类</strong>：将客户与类的实现分离，客户通过它们的抽象接口操纵实例。\n产品的类名也在具体工厂的实现中被隔离，即不出现在客户的代码中。</li>\n  <li><strong>易于交换产品系列</strong>：一个具体的工厂类在一个应用中仅出现一次，即在它初始化的时候，这使得改变一个ConcreteFactory变得容易。\n只要改变具体工厂就可以使用不同产品配置，因为一个抽象工厂创建了一个完整的产品系列，所以整个产品系列会立刻改变。</li>\n  <li><strong>有利于产品一致性</strong>：当一个系列中产品对象被设计成一起工作时，一个应用只能使用同一个系列中的对象，而AbstractFactory很容易实现这一点</li>\n  <li><strong>难以支持新种类的产品</strong>：由于AbstractFactory确定了AbstractProduct的集合。\n因此支持新种类的Product就需要扩展该工厂的接口，并扩展其全部ConcreteFactory</li>\n</ol>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%BA%8C-%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82-Abstract-Factory/'> <img src='/images/covers/操作系统-cover1.png' alt='设计模式（二）抽象工厂（Abstract Factory）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-09-10T20:22:42+08:00'>Sep 10, 2022</time> </span> </div><h2 class='article__title'>设计模式（二）抽象工厂（Abstract Factory）</h2> <p class='article__excerpt'></p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/设计模式' class='article__tag'>设计模式</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "设计模式（一）简介",
      "category" : "",
      "tags"     : "设计模式",
      "url"      : "/2022/09/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E4%B8%80-%E7%AE%80%E4%BB%8B/",
      "date"     : "Sep 10, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#什么是设计模式\" id=\"markdown-toc-什么是设计模式\">什么是设计模式</a></li>\n  <li><a href=\"#设计原则\" id=\"markdown-toc-设计原则\">设计原则</a></li>\n  <li><a href=\"#怎样解决设计问题\" id=\"markdown-toc-怎样解决设计问题\">怎样解决设计问题</a></li>\n</ol>\n\n<p>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p>\n\n<h2 id=\"什么是设计模式\">什么是设计模式</h2>\n\n<p>设计模式是<strong>对用来在特定场景下解决一般设计问题的类和相互通信的对象的描述</strong></p>\n\n<h2 id=\"设计原则\">设计原则</h2>\n\n<h2 id=\"怎样解决设计问题\">怎样解决设计问题</h2>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-09-10T19:45:18+08:00'>Sep 10, 2022</time> </span> </div><h2 class='article__title'>设计模式（一）简介</h2> <p class='article__excerpt'>设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/设计模式' class='article__tag'>设计模式</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（三十四）管程",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E5%9B%9B-%E7%AE%A1%E7%A8%8B/",
      "date"     : "Apr 30, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#为什么要引入管程\" id=\"markdown-toc-为什么要引入管程\">为什么要引入管程</a></li>\n  <li><a href=\"#管程的定义和基本特征\" id=\"markdown-toc-管程的定义和基本特征\">管程的定义和基本特征</a></li>\n  <li><a href=\"#用管程解决生产者-消费者问题\" id=\"markdown-toc-用管程解决生产者-消费者问题\">用管程解决生产者-消费者问题</a></li>\n  <li><a href=\"#java中类似管程的机制\" id=\"markdown-toc-java中类似管程的机制\">Java中类似管程的机制</a></li>\n</ol>\n\n<h2 id=\"为什么要引入管程\">为什么要引入管程</h2>\n<p>信号量机制存在的问题：编写程序困难、易出错。</p>\n\n<p>能不能设计一种机制，让程序员写程序时不需要再关注复杂的PV操作，让写代码更轻松呢？</p>\n\n<p>1973年，Brinch Hansen首次在程序设计语言（Pascal）中引入了“管程”成分——一种高级同步机制。</p>\n\n<h2 id=\"管程的定义和基本特征\">管程的定义和基本特征</h2>\n<p>管程是一种特殊的软件模块，有这些部分组成：</p>\n<ol>\n  <li>局部于管程的<strong>共享数据结构</strong>说明；</li>\n  <li>对该数据结构进行操作的<strong>一组过程</strong>；</li>\n  <li>对局部于管程的共享数据设置初始值的语句；</li>\n  <li>管程有一个名字。</li>\n</ol>\n\n<p>管程的基本特征：</p>\n<ol>\n  <li>局部于管程的数据只能被局部于管程的过程所访问；</li>\n  <li>一个进程只有通过调用管程内的过程才能进入管程访问共享数据；</li>\n  <li><strong>每次仅允许一个进程在管程内执行某个内部过程</strong>。</li>\n</ol>\n\n<h2 id=\"用管程解决生产者-消费者问题\">用管程解决生产者-消费者问题</h2>\n\n<p>管程：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">monitor</span> <span class=\"n\">ProducerConsumer</span>\n    <span class=\"n\">condition</span> <span class=\"n\">full</span><span class=\"p\">,</span> <span class=\"n\">empty</span><span class=\"p\">;</span>      <span class=\"c1\">// 条件变量用来实现同步（排队），管程中设置条件变量和等待/唤醒操作，以解决同步问题</span>\n    <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>              <span class=\"c1\">// 缓冲区中的产品数</span>\n    <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"n\">Item</span> <span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// 把产品item放入缓冲区，由编译器负责实现各进程互斥地进入管程中的过程</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">N</span><span class=\"p\">)</span>\n            <span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">full</span><span class=\"p\">);</span>\n        <span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"n\">insert_item</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">Item</span> <span class=\"nf\">remove</span><span class=\"p\">()</span> <span class=\"p\">{</span>             <span class=\"c1\">// 从缓冲区中取出一个产品</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>\n            <span class=\"n\">wait</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">);</span>\n        <span class=\"n\">count</span><span class=\"o\">--</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"n\">N</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n            <span class=\"n\">signal</span><span class=\"p\">(</span><span class=\"n\">full</span><span class=\"p\">);</span>\n        <span class=\"k\">return</span> <span class=\"n\">remove_item</span><span class=\"p\">();</span>\n    <span class=\"p\">}</span>\n<span class=\"n\">end</span> <span class=\"n\">monitor</span>    \n</code></pre></div></div>\n\n<p>使用示例：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/* 生产者进程 */</span>\n<span class=\"n\">Producer</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"err\">生产一个产品</span><span class=\"p\">;</span>\n        <span class=\"n\">ProducerConsumer</span><span class=\"p\">.</span><span class=\"n\">insert</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"cm\">/* 消费者进程 */</span>\n<span class=\"n\">Consumer</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"n\">ProducerConsumer</span><span class=\"p\">.</span><span class=\"n\">remove</span><span class=\"p\">();</span>\n        <span class=\"err\">消费产品</span><span class=\"n\">item</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>引入管程的目的是更方便地实现进程互斥和同步：</p>\n<ol>\n  <li>需要在<strong>管程中定义共享数据</strong>（如生产者消费者问题的缓冲区）；</li>\n  <li>需要在<strong>管程中定义用于访问这些共享数据的“入口”</strong>——其实就是一些函数（如生产者消费者问题中，可以定义一个函数用于将产品放入缓冲区，再定义一个函数用于从缓冲区取出产品）；</li>\n  <li>只有<strong>通过这些特定的“入口”才能访问共享数据</strong>；</li>\n  <li>管程中有很多“入口”，但是<strong>每次只能开放其中一个“入口”</strong>，并且<strong>只能让一个进程或线程进入</strong>（如生产者消费者问题中，各进程需要互斥地访问共享缓冲区。管程的这种特性即可保证一个时间段内最多只会有一个进程在访问缓冲区。注意：<strong>这种互斥特性是由编译器负责实现的，程序员不用关心</strong>）；</li>\n  <li>可在管程中设置<strong>条件变量</strong>及<strong>等待/唤醒操作</strong>以解决同步问题。可以让一个进程或线程在条件变量上等待（<strong>此时，该进程应先释放管程的使用权，也就是让出“入口”</strong>)；可以通过唤醒操作将等待在条件变量上的进程或线程唤醒。</li>\n</ol>\n\n<h2 id=\"java中类似管程的机制\">Java中类似管程的机制</h2>\n\n<p>Java中，如果用关键字synchronized来描述一个函数，那么这个函数同一时间段内只能被一个线程调用：</p>\n\n<div class=\"language-java highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kd\">static</span> <span class=\"kd\">class</span> <span class=\"nc\">monitor</span> <span class=\"o\">{</span>\n    <span class=\"kd\">private</span> <span class=\"nc\">Item</span> <span class=\"n\">buffer</span><span class=\"o\">[]</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"nc\">Item</span><span class=\"o\">[</span><span class=\"no\">N</span><span class=\"o\">];</span>\n    <span class=\"kd\">private</span> <span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"o\">;</span>\n    \n    <span class=\"kd\">public</span> <span class=\"kd\">synchronized</span> <span class=\"kt\">void</span> <span class=\"nf\">insert</span><span class=\"o\">(</span><span class=\"nc\">Item</span> <span class=\"n\">item</span><span class=\"o\">)</span> <span class=\"o\">{</span>\n        <span class=\"cm\">/* ... */</span>\n    <span class=\"o\">}</span>\n<span class=\"o\">}</span>\n</code></pre></div></div>\n\n<p>每次只能有一个线程进入<code class=\"language-plaintext highlighter-rouge\">insert()</code>函数，如果多个线程同时调用<code class=\"language-plaintext highlighter-rouge\">insert()</code>函数，则后来者需要排队等待。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E5%9B%9B-%E7%AE%A1%E7%A8%8B/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（三十四）管程'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-30T18:16:50+08:00'>Apr 30, 2022</time> </span> </div><h2 class='article__title'>操作系统（三十四）管程</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（三十三）哲学家进餐问题",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E4%B8%89-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98/",
      "date"     : "Apr 30, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#问题描述\" id=\"markdown-toc-问题描述\">问题描述</a></li>\n  <li><a href=\"#实现原理\" id=\"markdown-toc-实现原理\">实现原理</a></li>\n  <li><a href=\"#典型错误代码实现\" id=\"markdown-toc-典型错误代码实现\">典型错误代码实现</a></li>\n  <li><a href=\"#一种可行的代码实现\" id=\"markdown-toc-一种可行的代码实现\">一种可行的代码实现</a></li>\n  <li><a href=\"#其它可行方法\" id=\"markdown-toc-其它可行方法\">其它可行方法</a></li>\n  <li><a href=\"#总结\" id=\"markdown-toc-总结\">总结</a></li>\n</ol>\n\n<h2 id=\"问题描述\">问题描述</h2>\n\n<p>一张圆桌上坐着5名哲学家，每两个哲学家之间的桌上摆一根筷子，桌子的中间是一碗米饭。\n哲学家们倾注毕生的精力用于思考和进餐，哲学家在思考时，并不影响他人。\n只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。\n如果筷子已在他人手上，则需等待。饥饿的哲学家只有同时拿起两根筷子才可以开始进餐，当进餐完毕后，放下筷子继续思考。</p>\n\n<h2 id=\"实现原理\">实现原理</h2>\n\n<p>关系分析：系统中有5个哲学家进程，5位哲学家与左右邻居对其中间筷子的访问是互斥关系。</p>\n\n<p>这个问题中只有互斥关系，但与之前遇到的问题不同的事，每个哲学家进程需要同时持有两个临界资源才能开始吃饭。\n<strong>如何避免临界资源分配不当造成的死锁现象，是哲学家问题的精髓。</strong></p>\n\n<p>信号量设计：定义互斥信号量数组<code class=\"language-plaintext highlighter-rouge\">chopstick[5]={1,1,1,1,1}</code>用于实现对5个筷子的互斥访问。\n并对哲学家按0~4编号，哲学家<code class=\"language-plaintext highlighter-rouge\">i</code>左边的筷子编号为<code class=\"language-plaintext highlighter-rouge\">i</code>，右边的筷子编号为<code class=\"language-plaintext highlighter-rouge\">(i+1)%5</code>。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量9.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"典型错误代码实现\">典型错误代码实现</h2>\n\n<p>首先编写如下代码</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">semaphore</span> <span class=\"n\">chopstick</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">};</span>\n<span class=\"n\">Pi</span><span class=\"p\">(){</span>                               <span class=\"c1\">// i号哲学家的进程</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>            <span class=\"c1\">// 拿起左手边筷子</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"mi\">5</span><span class=\"p\">]);</span>      <span class=\"c1\">// 拿起右手边筷子</span>\n        <span class=\"err\">吃饭</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>            <span class=\"c1\">// 放下左手边筷子</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"mi\">5</span><span class=\"p\">]);</span>      <span class=\"c1\">// 放下右手边筷子</span>\n        <span class=\"err\">思考</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>这样代码实现存在的问题在于，如果5个哲学家<strong>并发地拿起了自己左手边的筷子</strong>，每位哲学家循环等待右边的人放下筷子（阻塞），<strong>发生“死锁”</strong>。</p>\n\n<h2 id=\"一种可行的代码实现\">一种可行的代码实现</h2>\n\n<p>为了防止死锁发生，<strong>可以令各哲学家拿筷子这件事互斥的执行</strong>。\n这就保证了<strong>即使一个哲学家在拿筷子拿到一半时被阻塞</strong>,也<strong>不会有别的哲学家会继续尝试拿筷子</strong>。\n这样的话，当前正在吃饭的哲学家放下筷子后，被阻塞的哲学家就可以获得等待的筷子了。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">semaphore</span> <span class=\"n\">chopstick</span><span class=\"p\">[</span><span class=\"mi\">5</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">};</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">mutex</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>                <span class=\"c1\">// 互斥地取筷子</span>\n<span class=\"n\">Pi</span><span class=\"p\">(){</span>                               <span class=\"c1\">// i号哲学家的进程</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>            <span class=\"c1\">// 拿起左手边筷子</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"mi\">5</span><span class=\"p\">]);</span>      <span class=\"c1\">// 拿起右手边筷子</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"err\">吃饭</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>            <span class=\"c1\">// 放下左手边筷子</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">chopstick</span><span class=\"p\">[(</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">%</span><span class=\"mi\">5</span><span class=\"p\">]);</span>      <span class=\"c1\">// 放下右手边筷子</span>\n        <span class=\"err\">思考</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"其它可行方法\">其它可行方法</h2>\n\n<ul>\n  <li>可以对哲学家进程施加一些限制条件，比如最多允许四个哲学家同时进餐。（设置一个信号量为4）这样可以保证至少有一个哲学家是可以拿到左右两只筷子的。</li>\n  <li>要求奇数号哲学家先拿左边的筷子，然后再拿右边的筷子，而偶数号哲学家刚好相反。用这种方法可以保证如果相邻的两个奇偶号哲学家都想吃饭，那么只会有其中一个可以拿起第一只筷子，另一个会直接阻塞。这就避免了占有一支后再等待另一只的情况。</li>\n</ul>\n\n<h2 id=\"总结\">总结</h2>\n\n<p>哲学家进餐问题的关键在于解决进程死锁。</p>\n\n<p>这些进程之间只存在互斥关系，但是与之前接触到的互斥关系不同的是，每个进程都需要同时持有两个临界资源，因此就有“死锁”问题的隐患。</p>\n\n<p>遇到一个进程需要同时持有多个临界资源的情况，应该参考哲学家问题的思想，分析题中给出的进程之间是否会发生循环等待，是否会发生死锁。</p>\n\n<p>可以参考哲学家就餐问题解决死锁的三种思路。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/30/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E4%B8%89-%E5%93%B2%E5%AD%A6%E5%AE%B6%E8%BF%9B%E9%A4%90%E9%97%AE%E9%A2%98/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（三十三）哲学家进餐问题'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-30T12:05:09+08:00'>Apr 30, 2022</time> </span> </div><h2 class='article__title'>操作系统（三十三）哲学家进餐问题</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（三十二）读者-写者问题",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E4%BA%8C-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/",
      "date"     : "Apr 29, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#问题描述\" id=\"markdown-toc-问题描述\">问题描述</a></li>\n  <li><a href=\"#实现原理\" id=\"markdown-toc-实现原理\">实现原理</a></li>\n  <li><a href=\"#代码实现\" id=\"markdown-toc-代码实现\">代码实现</a>    <ol>\n      <li><a href=\"#实现互斥访问\" id=\"markdown-toc-实现互斥访问\">实现互斥访问</a></li>\n      <li><a href=\"#保证读进程不会相互阻塞\" id=\"markdown-toc-保证读进程不会相互阻塞\">保证读进程不会相互阻塞</a></li>\n      <li><a href=\"#实现写优先\" id=\"markdown-toc-实现写优先\">实现写优先</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#总结\" id=\"markdown-toc-总结\">总结</a></li>\n</ol>\n\n<h2 id=\"问题描述\">问题描述</h2>\n<p>有读者和写者两组并发进程，共享一个文件。\n当两个或两个以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。\n因此要求：</p>\n<ol>\n  <li><strong>允许多个读者</strong>可以同时对文件执行读操作；</li>\n  <li><strong>只允许一个写者</strong>往文件中写信息；</li>\n  <li>任一写者在<strong>完成写操作之前不允许其他读者或写者工作</strong>；</li>\n  <li>写者<strong>执行写操作前，应让已有的读者和写者全部退出</strong>。</li>\n</ol>\n\n<p>注：与消费者进程不同，读者进程在读数据后并不会将数据清空，并不会改变数据。因此多个读者可同时访问共享数据。</p>\n\n<h2 id=\"实现原理\">实现原理</h2>\n<p>两类进程：写进程、读进程</p>\n\n<p>互斥关系：</p>\n<ul>\n  <li>写进程―写进程、写进程―读进程之间存在互斥关系。</li>\n  <li>读进程与读进程不存在互斥问题。</li>\n</ul>\n\n<h2 id=\"代码实现\">代码实现</h2>\n<h3 id=\"实现互斥访问\">实现互斥访问</h3>\n\n<p>我们可以设置一个信号量rw保证写进程-读进程和写进程-写进程的互斥关系：</p>\n\n<p>Writer：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">)</span>\n<span class=\"err\">写文件</span><span class=\"p\">;</span>\n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<p>Reader：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">)</span>\n<span class=\"err\">读文件</span><span class=\"p\">;</span>\n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">)</span>\n</code></pre></div></div>\n\n<h3 id=\"保证读进程不会相互阻塞\">保证读进程不会相互阻塞</h3>\n\n<p>为了防止信号量rw阻塞多个读进程读文件过程，如下代码可以使加锁过程仅由<strong>第一个读进程负责</strong>。\n之后的读进程不再需要获得锁就可以读取文件内容。\n而<strong>最后一个读进程负责解锁过程</strong>。</p>\n\n<p>Reader：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\">// 由第一个读进程负责</span>\n    <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>      <span class=\"c1\">// 读之前加锁</span>\n<span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span>        <span class=\"c1\">// 访问文件的读进程数+1</span>\n<span class=\"err\">读文件</span><span class=\"p\">;</span>\n<span class=\"n\">count</span><span class=\"o\">--</span><span class=\"p\">;</span>        <span class=\"c1\">// 访问文件的读进程数-1</span>\n<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>  <span class=\"c1\">// 由最后一个读进程负责</span>\n    <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>      <span class=\"c1\">// 读完了解锁</span>\n</code></pre></div></div>\n\n<p>若两个读进程并发执行，则count=0时两个进程也许都能满足if条件，都会执行<code class=\"language-plaintext highlighter-rouge\">P(rw)</code>，从而使第二个读进程阻塞。\n出现上述问题的原因在于对count变量的检查和赋值无法一气呵成，因此可以设置另一个互斥信号量来保证各读进程对count的访问是互斥的。</p>\n\n<p><strong>count此时属于临界资源，需要另加一个信号量mutex保证其操作的原子性。</strong></p>\n\n<p>Reader：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 各读进程互斥访问count</span>\n<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\">// 由第一个读进程负责</span>\n    <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>      <span class=\"c1\">// 读之前加锁</span>\n<span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span>        <span class=\"c1\">// 访问文件的读进程数+1</span>\n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 访问完count解锁</span>\n<span class=\"err\">读文件</span><span class=\"p\">;</span>\n<span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 各读进程互斥访问count</span>\n<span class=\"n\">count</span><span class=\"o\">--</span><span class=\"p\">;</span>        <span class=\"c1\">// 访问文件的读进程数-1</span>\n<span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>  <span class=\"c1\">// 由最后一个读进程负责</span>\n    <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>      <span class=\"c1\">// 读完了解锁</span>\n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 访问完count解锁</span>\n</code></pre></div></div>\n\n<h3 id=\"实现写优先\">实现写优先</h3>\n\n<p>之前的实现仍然存在潜在问题，即只要有读进程还在读，写进程就要一直阻塞等待，可能“饿死”。\n因此，这种算法中，读进程是优先的。\n为了解决这种问题，可以再加一个信号量w防止写进程饥饿。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"c1\">// 信号量设置</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">rw</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>       <span class=\"c1\">//用于实现对共享文件的互斥访问</span>\n<span class=\"kt\">int</span> <span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>          <span class=\"c1\">//记录当前有几个读进程在访问文件</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">mutex</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>    <span class=\"c1\">//用于保证对count变量的互斥访问</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">w</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>        <span class=\"c1\">//用于实现\"写优先\"</span>\n\n<span class=\"n\">Writer</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">);</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>          <span class=\"c1\">// 写之前加锁</span>\n        <span class=\"err\">写文件</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>          <span class=\"c1\">// 写之后解锁</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Reader</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">);</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 各读进程互斥访问count</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\">// 由第一个读进程负责</span>\n            <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>      <span class=\"c1\">// 读之前加锁</span>\n        <span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span>        <span class=\"c1\">// 访问文件的读进程数+1</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 访问完count解锁</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">w</span><span class=\"p\">);</span>\n        <span class=\"err\">读文件</span><span class=\"p\">;</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 各读进程互斥访问count</span>\n        <span class=\"n\">count</span><span class=\"o\">--</span><span class=\"p\">;</span>        <span class=\"c1\">// 访问文件的读进程数-1</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">count</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span>  <span class=\"c1\">// 由最后一个读进程负责</span>\n            <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">rw</span><span class=\"p\">);</span>      <span class=\"c1\">// 读完了解锁</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>       <span class=\"c1\">// 访问完count解锁</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n</code></pre></div></div>\n\n<p>分析以下并发执行P(w)的情况：</p>\n<ul>\n  <li>读者1-&gt;写者1-&gt;读者2</li>\n  <li>写者1-&gt;读者1-&gt;写者2</li>\n</ul>\n\n<p>在这种算法中，连续进入的多个读者可以同时读文件；写者和其他进程不能同时访问文件；写者不会饥饿，但也并不是真正的“写优先”，而是<strong>相对公平的先来先服务原则。</strong>\n这种算法又称“读写公平法”。</p>\n\n<h2 id=\"总结\">总结</h2>\n\n<p>读者-写者问题为我们解决复杂的互斥问题提供了一个参考思路。</p>\n\n<p>其<strong>核心思想</strong>在于设置了一个<strong>计数器count</strong>用来记录当前正在访问共享文件的读进程数。\n我们可以用count的值来判断当前进入的进程是否是第一个/最后一个读进程，从而做出不同的处理。</p>\n\n<p>另外，对count变量的检查和赋值不能一气呵成导致了一些错误，如果<strong>需要实现“一气呵成”，自然应该想到用互斥信号量。</strong></p>\n\n<p>最后，还要认真体会我们是如何解决<strong>“写进程饥饿”</strong>问题的。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E4%BA%8C-%E8%AF%BB%E8%80%85-%E5%86%99%E8%80%85%E9%97%AE%E9%A2%98/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（三十二）读者-写者问题'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2022-04-29T10:47:21+08:00'>Apr 29, 2022</time> </span> </div><h2 class='article__title'>操作系统（三十二）读者-写者问题</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（三十一）吸烟者问题",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E4%B8%80-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98/",
      "date"     : "Apr 29, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#问题描述\" id=\"markdown-toc-问题描述\">问题描述</a></li>\n  <li><a href=\"#实现原理\" id=\"markdown-toc-实现原理\">实现原理</a></li>\n  <li><a href=\"#代码实现\" id=\"markdown-toc-代码实现\">代码实现</a></li>\n  <li><a href=\"#总结\" id=\"markdown-toc-总结\">总结</a></li>\n</ol>\n\n<h2 id=\"问题描述\">问题描述</h2>\n<p>假设一个系统有<strong>三个抽烟者进程</strong>和<strong>一个供应者进程</strong>。\n每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。\n三个抽烟者中，<strong>第一个拥有烟草、第二个拥有纸、第三个拥有胶水。</strong>\n供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）</p>\n\n<h2 id=\"实现原理\">实现原理</h2>\n\n<p>这个问题本质上也属于“生产者-消费者”问题，更详细的说是“可生产多种产品的单生产者-多消费者”。</p>\n\n<p>互斥关系：</p>\n<ul>\n  <li>桌子可以抽象为容量为1的缓冲区，要互斥访问。</li>\n</ul>\n\n<p>桌子上可能的组合：</p>\n<ul>\n  <li>组合一：纸+胶水；</li>\n  <li>组合二：烟草+胶水；</li>\n  <li>组合三：烟草+纸。</li>\n</ul>\n\n<p>同步关系（从事件的角度分析）：</p>\n<ul>\n  <li>桌上有组合一-&gt;第一个抽烟者取走东西；</li>\n  <li>桌上有组合二-&gt;第二个抽烟者取走东西；</li>\n  <li>桌上有组合三-&gt;第三个抽烟者取走东西；</li>\n  <li>发出完成信号-&gt;供应者将下一个组合放到桌上。</li>\n</ul>\n\n<p>信号量设计：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量8.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"代码实现\">代码实现</h2>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">semaphore</span> <span class=\"n\">offer1</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>     <span class=\"c1\">//桌上组合一的数量</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">offer2</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>     <span class=\"c1\">//桌上组合二的数量</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">offer3</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>     <span class=\"o\">/</span><span class=\"err\">桌上组合三的数量</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">finish</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>     <span class=\"c1\">//抽烟是否完成</span>\n<span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>                <span class=\"c1\">//用于实现\"三个抽烟者轮流抽烟\"</span>\n\n<span class=\"n\">Provider</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"err\">将组合一放到桌上</span><span class=\"p\">;</span>\n            <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">offer1</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"err\">将组合二放到桌上</span><span class=\"p\">;</span>\n            <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">offer2</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">==</span> <span class=\"mi\">2</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"err\">将组合三放到桌上</span><span class=\"p\">;</span>\n            <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">offer3</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">%</span> <span class=\"mi\">3</span><span class=\"p\">;</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Smoker1</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">offer1</span><span class=\"p\">);</span>\n        <span class=\"err\">从桌上拿走组合一</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Smoker2</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">offer2</span><span class=\"p\">);</span>\n        <span class=\"err\">从桌上拿走组合二</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Smoker3</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">offer3</span><span class=\"p\">);</span>\n        <span class=\"err\">从桌上拿走组合三</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">finish</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>缓冲区大小为1，同一时刻，四个同步信号量中至多有一个的值为1，因此<strong>不必专门设置一个互斥信号量</strong>。</p>\n\n<h2 id=\"总结\">总结</h2>\n\n<p>吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。\n值得吸取的精华是：<strong>轮流让各个吸烟者吸烟</strong>必然需要<strong>轮流的在桌上放上组合</strong>一、二、三。\n注意体会我们是如何用一个整型变量i实现这个<strong>轮流</strong>过程的。</p>\n\n<p>若<strong>一个生产者要生产多种产品</strong>（或者说会<strong>引发多种前驱事件</strong>），那么<strong>各个V操作</strong>应该放在各自<strong>对应的“事件”发生之后</strong>的位置。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/29/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81%E4%B8%80-%E5%90%B8%E7%83%9F%E8%80%85%E9%97%AE%E9%A2%98/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（三十一）吸烟者问题'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-29T09:26:25+08:00'>Apr 29, 2022</time> </span> </div><h2 class='article__title'>操作系统（三十一）吸烟者问题</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（三十）多生产者-多消费者问题",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/",
      "date"     : "Apr 28, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#问题描述\" id=\"markdown-toc-问题描述\">问题描述</a></li>\n  <li><a href=\"#实现原理\" id=\"markdown-toc-实现原理\">实现原理</a></li>\n  <li><a href=\"#代码实现\" id=\"markdown-toc-代码实现\">代码实现</a></li>\n  <li><a href=\"#去掉互斥信号的情况\" id=\"markdown-toc-去掉互斥信号的情况\">去掉互斥信号的情况</a>    <ol>\n      <li><a href=\"#缓冲区容量为1\" id=\"markdown-toc-缓冲区容量为1\">缓冲区容量为1</a></li>\n      <li><a href=\"#缓冲区容量为2\" id=\"markdown-toc-缓冲区容量为2\">缓冲区容量为2</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#总结\" id=\"markdown-toc-总结\">总结</a></li>\n</ol>\n\n<h2 id=\"问题描述\">问题描述</h2>\n<p>桌子上有一只盘子，每次只能向其中放入一个水果。\n爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。\n只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。\n仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。</p>\n\n<h2 id=\"实现原理\">实现原理</h2>\n\n<p>互斥关系（mutex = 1）：</p>\n<ul>\n  <li>对缓冲区（盘子）的访问要互斥地进行。</li>\n</ul>\n\n<p>同步关系（一前一后）：</p>\n<ol>\n  <li>父亲将苹果放入盘子后，女儿才能取苹果；</li>\n  <li>母亲将橘子放入盘子后，儿子才能取橘子；</li>\n  <li>只有盘子为空时，父亲或母亲才能放入水果。（“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）</li>\n</ol>\n\n<p>信号量设计：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量5.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"代码实现\">代码实现</h2>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">semaphore</span> <span class=\"n\">mutex</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>   <span class=\"c1\">//实现互斥访问盘子（缓冲区）</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">apple</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>   <span class=\"c1\">//盘子中有几个苹果</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">orange</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"c1\">//盘子中有几个橘子</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">plate</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>   <span class=\"c1\">//盘子中还可以放多少个水果</span>\n\n<span class=\"n\">dad</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"err\">准备一个苹果</span><span class=\"p\">;</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">plate</span><span class=\"p\">);</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"err\">把苹果放入盘子</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">apple</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">mom</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"err\">准备一个橘子；</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">plate</span><span class=\"p\">);</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"err\">把橘子放入盘子</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">orange</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">daughter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">apple</span><span class=\"p\">);</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"err\">从盘中取出苹果</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">plate</span><span class=\"p\">);</span>\n        <span class=\"err\">吃掉苹果</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">son</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">orange</span><span class=\"p\">);</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"err\">从盘中取出橘子</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">plate</span><span class=\"p\">);</span>\n        <span class=\"err\">吃掉橘子</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"去掉互斥信号的情况\">去掉互斥信号的情况</h2>\n\n<h3 id=\"缓冲区容量为1\">缓冲区容量为1</h3>\n\n<p>在缓冲区容量为1时，即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。</p>\n\n<p>分析：刚开始，儿子、女儿进程即使上处理机运行也会被阻塞。\n如果刚开始是父亲进程先上处埋机行，则父亲<code class=\"language-plaintext highlighter-rouge\">P(plate)</code>，可以访问盘子-&gt;\n母亲<code class=\"language-plaintext highlighter-rouge\">P(plate)</code>，阻塞等待盘子-&gt;\n父亲放入苹果<code class=\"language-plaintext highlighter-rouge\">V(apple)</code>，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）-&gt;\n女儿<code class=\"language-plaintext highlighter-rouge\">P(apple)</code>，访问盘子，<code class=\"language-plaintext highlighter-rouge\">V(plate)</code>，等待盘子的母亲进程被唤醒-&gt;\n母亲进程访问盘子（其他进程暂时都无法进入临界区）-&gt;……</p>\n\n<p>原因在于本题中的缓冲区大小为1。\n在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。\n因此最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。</p>\n\n<h3 id=\"缓冲区容量为2\">缓冲区容量为2</h3>\n\n<p>父亲<code class=\"language-plaintext highlighter-rouge\">P(plate)</code>，可以访问盘子-&gt;\n母亲<code class=\"language-plaintext highlighter-rouge\">P(plate)</code>，可以访问盘子-&gt;\n父亲在往盘子里放苹果，同时母亲也可以往盘子里放橘子。\n于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。\n因此，如果缓冲区大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区。</p>\n\n<h2 id=\"总结\">总结</h2>\n\n<p>解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。</p>\n\n<p>在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。</p>\n\n<p>比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：</p>\n<ul>\n  <li><strong>如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果；</strong></li>\n  <li><strong>如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果。</strong></li>\n</ul>\n\n<p>这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量6.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>正确的分析方法应该<strong>从“事件”的角度来考虑</strong>，我们可以把上述<strong>四对“进程行为的前后关系”</strong>抽象为<strong>一对“事件的前后关系”</strong>\n盘子变空事件-&gt;放入水果事件：</p>\n<ul>\n  <li><strong>“盘子变空事件”既可由儿子引发，也可由女儿引发；</strong></li>\n  <li><strong>“放水果事件”既可能是父亲执行，也可能是母亲执行。</strong></li>\n</ul>\n\n<p>这样的话，就可以用一个同步信号量解决问题了。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量7.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89%E5%8D%81-%E5%A4%9A%E7%94%9F%E4%BA%A7%E8%80%85-%E5%A4%9A%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（三十）多生产者-多消费者问题'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-28T10:02:09+08:00'>Apr 28, 2022</time> </span> </div><h2 class='article__title'>操作系统（三十）多生产者-多消费者问题</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十九）生产者-消费者问题",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B9%9D-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/",
      "date"     : "Apr 28, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#pv操作问题的一般思路\" id=\"markdown-toc-pv操作问题的一般思路\">PV操作问题的一般思路：</a></li>\n  <li><a href=\"#问题描述\" id=\"markdown-toc-问题描述\">问题描述</a></li>\n  <li><a href=\"#实现原理\" id=\"markdown-toc-实现原理\">实现原理</a></li>\n  <li><a href=\"#同步和互斥的顺序\" id=\"markdown-toc-同步和互斥的顺序\">同步和互斥的顺序</a></li>\n</ol>\n\n<h2 id=\"pv操作问题的一般思路\">PV操作问题的一般思路：</h2>\n<ol>\n  <li>关系分析。找出题目中描述的各个进程，分析它们之间的同步、互斥关系。</li>\n  <li>整理思路。根据各进程的操作流程确定P、V操作的大致顺序。</li>\n  <li>设置信号量。设置需要的信号量，并根据题目条件确定信号量初值。（互斥信号量初值一般为1，同步信号量的初始值要看对应资源的初始值是多少）</li>\n</ol>\n\n<h2 id=\"问题描述\">问题描述</h2>\n\n<p>系统中有一组生产者进程和一组消费者进程。\n生产者进程每次生产一个产品放入缓冲区，消费者进程每次从缓冲区中取出一个产品并使用。（这里的“产品”理解为某种数据）</p>\n\n<p>生产者、消费者共享一个初始为空、大小为n的缓冲区。</p>\n\n<p>只有<strong>缓冲区没满</strong>时，<strong>生产者才能把产品放入缓冲区</strong>，否则必须等待。</p>\n\n<p>只有<strong>缓冲区不空</strong>时，<strong>消费者才能从中取出产品</strong>，否则必须等待。</p>\n\n<p><strong>缓冲区是临界资源</strong>，各进程必须<strong>互斥地访问</strong>。</p>\n\n<h2 id=\"实现原理\">实现原理</h2>\n\n<p>生产者-消费者问题是一个互斥、同步的综合问题。</p>\n\n<p>对于初学者来说最难的是发现题目中隐含的两对同步关系。</p>\n\n<p>有时候是消费者需要等待生产者生产，有时候是生产者要等待消费者消费。这是两个不同的“一前一后问题”，因此也需要设置两个同步信号量。</p>\n\n<p>生产者-消费者问题的前驱关系如下图所示：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量4.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>根据前驱图可编写对应代码：</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">semaphore</span> <span class=\"n\">mutex</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">//互斥信号量，实现对缓冲区的互斥访问</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">empty</span> <span class=\"o\">=</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"c1\">//同步信号量，表示空闲缓冲区的数量</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">full</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>  <span class=\"c1\">//同步信号量,表示产品的数量,也即非空缓冲区的数量</span>\n\n<span class=\"n\">Producer</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"err\">生产一个产品</span><span class=\"p\">;</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">);</span>   <span class=\"c1\">// 消耗一个空闲缓冲区</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 实现互斥是在同进程中进行一对PV操作</span>\n        <span class=\"err\">把产品放入缓冲区</span><span class=\"p\">;</span> \n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 实现互斥是在同进程中进行一对PV操作</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">full</span><span class=\"p\">);</span>    <span class=\"c1\">// 增加一个产品</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Consumer</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">full</span><span class=\"p\">);</span>    <span class=\"c1\">// 消耗一个产品（非空缓冲区）</span>\n        <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"err\">从缓冲区取出一个产品</span><span class=\"p\">;</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n        <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">);</span>   <span class=\"c1\">// 增加一个空闲缓冲区</span>\n        <span class=\"err\">使用产品</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<ul>\n  <li>mutex：实现互斥是在同进程中进行一对PV操作</li>\n  <li>empty/full：实现两进程的同步关系，是在其中一个进程中执行P，另一进程中执行V</li>\n</ul>\n\n<h2 id=\"同步和互斥的顺序\">同步和互斥的顺序</h2>\n\n<p>假设将上述代码的P操作顺序进行互换，如下所示：</p>\n\n<p>Producer：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 1.</span>\n<span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">);</span>   <span class=\"c1\">// 2.</span>\n<span class=\"err\">把产品放入缓冲区</span><span class=\"p\">;</span> \n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">full</span><span class=\"p\">);</span>   \n</code></pre></div></div>\n\n<p>Consumer：</p>\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">full</span><span class=\"p\">);</span>    <span class=\"c1\">// 3.</span>\n<span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 4.</span>\n<span class=\"err\">从缓冲区取出一个产品</span><span class=\"p\">;</span>\n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>\n<span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">empty</span><span class=\"p\">);</span>\n</code></pre></div></div>\n\n<p>若此时缓冲区内已经放满产品，则empty=0，full=n。\n则生产者进程执行1使mutex变为0，再执行2，由于已<strong>没有空闲缓冲区，因此生产者被阻塞</strong>。\n由于生产者阻塞，因此切换回消费者进程。\n消费者进程执行3，<strong>由于mutex为0</strong>，即生产者还没释放对临界资源的“锁”，因此<strong>消费者也被阻塞</strong>。</p>\n\n<p>这就造成了<strong>生产者等待消费者释放空闲缓冲区</strong>，而<strong>消费者又等待生产者释放临界区</strong>的情况。\n生产者和消费者循环等待被对方唤醒，<strong>出现“死锁”</strong>。</p>\n\n<p>同样的，若缓冲区中没有产品，即full=O，empty=n。按341的顺序执行就会发生死锁。</p>\n\n<p>因此，实现<strong>互斥的P操作一定要在实现同步的P操作之后</strong>。</p>\n\n<p>V操作不会导致进程阻塞，因此两个<strong>V操作顺序可以交换</strong>。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/28/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B9%9D-%E7%94%9F%E4%BA%A7%E8%80%85-%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十九）生产者-消费者问题'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-28T09:16:23+08:00'>Apr 28, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十九）生产者-消费者问题</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十八）信号量实现进程的同步、互斥和前驱",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E5%85%AB-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E5%92%8C%E5%89%8D%E9%A9%B1/",
      "date"     : "Apr 27, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#pv操作\" id=\"markdown-toc-pv操作\">P、V操作</a></li>\n  <li><a href=\"#实现进程互斥\" id=\"markdown-toc-实现进程互斥\">实现进程互斥</a></li>\n  <li><a href=\"#实现进程同步\" id=\"markdown-toc-实现进程同步\">实现进程同步</a></li>\n  <li><a href=\"#实现进程的前驱关系\" id=\"markdown-toc-实现进程的前驱关系\">实现进程的前驱关系</a></li>\n</ol>\n\n<h2 id=\"pv操作\">P、V操作</h2>\n\n<ul>\n  <li>信号量的值：这种<strong>资源的剩余数量</strong>（信号量的值如果小于0，说明此时有进程在等待这种资源）；</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">P(S)</code>：申请一个资源S，如果<strong>资源不够就阻塞等待</strong>；</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">V(S)</code>：释放一个资源S，如果有进程在等待该资源，则<strong>唤醒一个进程</strong>。</li>\n</ul>\n\n<h2 id=\"实现进程互斥\">实现进程互斥</h2>\n\n<ol>\n  <li>分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区）；</li>\n  <li>设置<strong>互斥信号量</strong>mutex，表示<strong>进入临界区的名额</strong>。初值为1；</li>\n  <li>在进入区<code class=\"language-plaintext highlighter-rouge\">P(mutex)</code>——申请资源；</li>\n  <li>在退出区<code class=\"language-plaintext highlighter-rouge\">V(mutex)</code>——释放资源。</li>\n</ol>\n\n<p>注意：</p>\n<ul>\n  <li>对<strong>不同的临界资源</strong>需要设置<strong>不同的互斥信号量</strong>。</li>\n  <li><strong>P、V操作必须成对出现</strong>。缺少<code class=\"language-plaintext highlighter-rouge\">P(mutex)</code>就<strong>不能保证临界资源的互斥访问</strong>。缺少<code class=\"language-plaintext highlighter-rouge\">V(mutex)</code>会导致<strong>资源永不被释放，等待进程永不被唤醒</strong>。</li>\n</ul>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/* 信号量机制实现互斥 */</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">mutex</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"n\">Process1</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n    <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 使用临界资源前加锁</span>\n    <span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n    <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 使用临界资源后解锁</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Process2</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"cm\">/* ... */</span>\n    <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 使用临界资源前加锁</span>\n    <span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n    <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">mutex</span><span class=\"p\">);</span>   <span class=\"c1\">// 使用临界资源后解锁</span>\n    <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n</code></pre></div></div>\n\n<p>不同的临界资源设置不同的互斥信号量：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量1.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"实现进程同步\">实现进程同步</h2>\n<p>进程同步：要让各并发进程按要求有序地推进。</p>\n\n<p>比如，P1、P2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。</p>\n\n<p>若<strong>P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果</strong>才能执行，那么我们就必须<strong>保证“代码4”一定是在“代码2”之后才会执行</strong>。</p>\n\n<p>这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。</p>\n\n<p>用信号量实现进程同步:</p>\n<ol>\n  <li>分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）；</li>\n  <li>设置<strong>同步信号量S,初始为0</strong>。</li>\n  <li>在<strong>“前操作”之后</strong>执行<code class=\"language-plaintext highlighter-rouge\">V(S)</code></li>\n  <li>在<strong>“后操作”之前</strong>执行<code class=\"language-plaintext highlighter-rouge\">P(S)</code></li>\n</ol>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/* 信号量机制实现同步 */</span>\n<span class=\"n\">semaphore</span> <span class=\"n\">mutex</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"n\">Process1</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"err\">代码</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"err\">代码</span><span class=\"mi\">2</span><span class=\"p\">;</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">);</span>\n  <span class=\"err\">代码</span><span class=\"mi\">3</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Process2</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">);</span>\n  <span class=\"err\">代码</span><span class=\"mi\">4</span><span class=\"p\">;</span>\n  <span class=\"err\">代码</span><span class=\"mi\">5</span><span class=\"p\">;</span>\n  <span class=\"err\">代码</span><span class=\"mi\">6</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><strong>分析：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源。</strong></p>\n\n<p>若先执行到<code class=\"language-plaintext highlighter-rouge\">V(S)</code>操作，则<code class=\"language-plaintext highlighter-rouge\">S++</code>后<code class=\"language-plaintext highlighter-rouge\">S=1</code>。\n之后当执行到<code class=\"language-plaintext highlighter-rouge\">P(S)</code>操作时，由于<code class=\"language-plaintext highlighter-rouge\">S=1</code>，表示有可用资源，会执行<code class=\"language-plaintext highlighter-rouge\">S--</code>，S的值变回0，P2进程不会执行<code class=\"language-plaintext highlighter-rouge\">block</code>原语，而是继续往下执行代码4。</p>\n\n<p>若先执行到<code class=\"language-plaintext highlighter-rouge\">P(S)</code>操作，由于<code class=\"language-plaintext highlighter-rouge\">S=0</code>，<code class=\"language-plaintext highlighter-rouge\">S--</code>后<code class=\"language-plaintext highlighter-rouge\">S=-1</code>，表示此时没有可用资源，因此P操作中会执行<code class=\"language-plaintext highlighter-rouge\">block</code>原语，主动请求阻塞。\n之后当执行完代码2，继而执行<code class=\"language-plaintext highlighter-rouge\">V(S)</code>操作，<code class=\"language-plaintext highlighter-rouge\">S++</code>，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行<code class=\"language-plaintext highlighter-rouge\">wakeup</code>原语，唤醒P2进程。\n这样P2就可以继续执行代码4了。</p>\n\n<h2 id=\"实现进程的前驱关系\">实现进程的前驱关系</h2>\n\n<p>前驱关系问题本质上是多级同步问题，假设6个进程中的代码要求按照以下前驱图所示顺序进行执行：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量2.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）,因此：</p>\n<ol>\n  <li>要为<strong>每一对前驱关系</strong>各设置<strong>一个同步信号量</strong>；</li>\n  <li>在<strong>“前操作”之后</strong>对相应的同步信号量执行<strong>V操作</strong>；</li>\n  <li>在<strong>“后操作”之前</strong>对相应的同步信号量执行<strong>Р操作</strong>。</li>\n</ol>\n\n<p><img src=\"\\images\\posts\\操作系统-信号量3.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>此时的代码为：</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">Process1</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/* ... */</span>\n  <span class=\"n\">S1</span><span class=\"p\">;</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span>\n  <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Process2</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/* ... */</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">a</span><span class=\"p\">);</span>\n  <span class=\"n\">S2</span><span class=\"p\">;</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">);</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">);</span>\n  <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Process3</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/* ... */</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">b</span><span class=\"p\">);</span>\n  <span class=\"n\">S3</span><span class=\"p\">;</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">);</span>\n  <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Process4</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/* ... */</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">);</span>\n  <span class=\"n\">S4</span><span class=\"p\">;</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span>\n  <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Process5</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/* ... */</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">);</span>\n  <span class=\"n\">S5</span><span class=\"p\">;</span>\n  <span class=\"n\">V</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span>\n  <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Process6</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"cm\">/* ... */</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">e</span><span class=\"p\">);</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"p\">);</span>\n  <span class=\"n\">P</span><span class=\"p\">(</span><span class=\"n\">g</span><span class=\"p\">);</span>\n  <span class=\"n\">S6</span><span class=\"p\">;</span>\n  <span class=\"cm\">/* ... */</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E5%85%AB-%E4%BF%A1%E5%8F%B7%E9%87%8F%E5%AE%9E%E7%8E%B0%E8%BF%9B%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5-%E4%BA%92%E6%96%A5%E5%92%8C%E5%89%8D%E9%A9%B1/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十八）信号量实现进程的同步、互斥和前驱'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2022-04-27T16:08:23+08:00'>Apr 27, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十八）信号量实现进程的同步、互斥和前驱</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十七）信号量机制",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B8%83-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/",
      "date"     : "Apr 27, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#信号量的概念\" id=\"markdown-toc-信号量的概念\">信号量的概念</a></li>\n  <li><a href=\"#整型信号量\" id=\"markdown-toc-整型信号量\">整型信号量</a></li>\n  <li><a href=\"#记录型信号量\" id=\"markdown-toc-记录型信号量\">记录型信号量</a></li>\n</ol>\n\n<h2 id=\"信号量的概念\">信号量的概念</h2>\n\n<p>用户进程可以通过使用操作系统提供的<strong>一对原语</strong>来对<strong>信号量</strong>进行操作，从而很方便地实现了进程互斥、进程同步。</p>\n\n<p><strong>信号量</strong>其实就是一个<strong>变量</strong>（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来<strong>表示系统中某种资源的数量</strong>。\n比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。</p>\n\n<p><strong>原语</strong>是一种特殊的<strong>程序段</strong>，其执行<strong>只能一气呵成，不可被中断。</strong>\n原语是由<strong>关中断/开中断指令</strong>实现的。\n软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。</p>\n\n<p><strong>一对原语</strong>：<code class=\"language-plaintext highlighter-rouge\">wait(S)</code>原语和<code class=\"language-plaintext highlighter-rouge\">signal(S)</code>原语，可以把原语理解为我们自己写的函数，函数名分别为<code class=\"language-plaintext highlighter-rouge\">wait</code>和<code class=\"language-plaintext highlighter-rouge\">signal</code>，括号里的信号量S其实就是函数调用时传入的一个参数。</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">wait</code>、<code class=\"language-plaintext highlighter-rouge\">signal</code>原语常简称为<strong>P、V操作</strong>（来自荷兰语proberen和verhogen）。</p>\n\n<h2 id=\"整型信号量\">整型信号量</h2>\n\n<p>用一个<strong>整数型的变量</strong>作为信号量，用来表示<strong>系统中某种资源的数量</strong>。</p>\n\n<p>与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"n\">S</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">// 初始化整型信号量S，表示当前系统中可用的打印机资源数。</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">S</span><span class=\"p\">)</span> <span class=\"p\">{</span>      <span class=\"c1\">// wait原语，相当于\"进入区\"</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">S</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"p\">);</span>     <span class=\"c1\">// 如果资源数不够，就一直循环等待</span>\n    <span class=\"n\">S</span><span class=\"o\">--</span><span class=\"p\">;</span>                <span class=\"c1\">// 如果资源数够，则占用一个资源</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">signal</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">S</span><span class=\"p\">)</span> <span class=\"p\">{</span>    <span class=\"c1\">// signal原语，相当于\"退出区\"</span>\n    <span class=\"n\">S</span><span class=\"o\">++</span><span class=\"p\">;</span>                <span class=\"c1\">// 使用完资源后，在退出区释放资源</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>整型信号量中，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。</p>\n\n<p>存在的问题：<strong>不满足“让权等待”原则</strong>，会发生“忙等”。</p>\n\n<h2 id=\"记录型信号量\">记录型信号量</h2>\n\n<p>整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/* 记录型信号量的定义 */</span>\n<span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">value</span><span class=\"p\">;</span>          <span class=\"c1\">// 剩余资源数</span>\n    <span class=\"n\">Struct</span> <span class=\"n\">process</span> <span class=\"o\">*</span><span class=\"n\">L</span><span class=\"p\">;</span>  <span class=\"c1\">// 等待队列</span>\n<span class=\"p\">}</span> <span class=\"n\">semaphore</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* 某进程需要使用资源时，通过wait原语申请 */</span>\n<span class=\"kt\">void</span> <span class=\"nf\">wait</span><span class=\"p\">(</span><span class=\"n\">semaphore</span> <span class=\"n\">S</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"o\">--</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">value</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">block</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">L</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n\n<span class=\"cm\">/* 进程使用完资源后，通过signal原语释放 */</span>\n<span class=\"kt\">void</span> <span class=\"nf\">signal</span><span class=\"p\">(</span><span class=\"n\">semaphore</span> <span class=\"n\">S</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">value</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">value</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">wakeup</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">.</span><span class=\"n\">L</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p>如果剩余资源数不够，使用<code class=\"language-plaintext highlighter-rouge\">block</code>原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中；\n释放资源后，若还有别的进程在等待这种资源<code class=\"language-plaintext highlighter-rouge\">wakeup</code>原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">wait(S)</code>、<code class=\"language-plaintext highlighter-rouge\">signal(S)</code>也可以记为<code class=\"language-plaintext highlighter-rouge\">P(S)</code>、<code class=\"language-plaintext highlighter-rouge\">V(S)</code>,这对原语可用于<strong>实现系统资源的“申请”和“释放”</strong>。</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">S.value</code>的初值表示系统中<strong>某种资源的数目</strong>。</p>\n\n<p>对信号量S的<strong>一次Р操作</strong>意味着进程<strong>请求一个单位的该类资源</strong>，因此需要执行<code class=\"language-plaintext highlighter-rouge\">S.value--</code>，表示资源数减1；\n当<code class=\"language-plaintext highlighter-rouge\">S.value &lt; 0</code>时表示该类资源己分配完毕，因此进程应调用<code class=\"language-plaintext highlighter-rouge\">block</code>原语进行<strong>自我阻塞</strong>（当前运行的进程从<strong>运行态-&gt;阻塞态</strong>），主动放弃处理机，并插入该类资源的等待队列<code class=\"language-plaintext highlighter-rouge\">S.L</code>中。\n可见，该机制<strong>遵循了“让权等待”原则</strong>,不会出现“忙等”现象。</p>\n\n<p>对信号量S的<strong>一次V操作</strong>意味着进程<strong>释放一个单位的该类资源</strong>，因此需要执行<code class=\"language-plaintext highlighter-rouge\">S.value++</code>，表示资源数加1；\n若加1后仍是<code class=\"language-plaintext highlighter-rouge\">S.value &lt;= 0</code>，表示依然有进程在等待该类资源，因此应调用<code class=\"language-plaintext highlighter-rouge\">wakeup</code>原语<strong>唤醒等待队列中的第一个进程</strong>（被唤醒进程从<strong>阻塞态-&gt;就绪态</strong>）。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/27/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B8%83-%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%9C%BA%E5%88%B6/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十七）信号量机制'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-27T11:12:18+08:00'>Apr 27, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十七）信号量机制</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十六）互斥锁",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E5%85%AD-%E4%BA%92%E6%96%A5%E9%94%81/",
      "date"     : "Apr 26, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#互斥锁的概念\" id=\"markdown-toc-互斥锁的概念\">互斥锁的概念</a></li>\n  <li><a href=\"#互斥锁的特性\" id=\"markdown-toc-互斥锁的特性\">互斥锁的特性</a></li>\n</ol>\n\n<h2 id=\"互斥锁的概念\">互斥锁的概念</h2>\n<p>解决临界区最简单的工具就是互斥锁（mutex lock）。\n一个进程在进入临界区时应获得锁；在退出临界区时释放锁。\n函数<code class=\"language-plaintext highlighter-rouge\">acquire()</code>获得锁，而函数<code class=\"language-plaintext highlighter-rouge\">release()</code>释放锁。</p>\n\n<p>每个互斥锁有一个布尔变量<code class=\"language-plaintext highlighter-rouge\">available</code>，表示锁是否可用。\n如果锁是可用的，调用<code class=\"language-plaintext highlighter-rouge\">acquire()</code>会成功，且锁不再可用。\n当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">acquire</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">available</span><span class=\"p\">);</span> <span class=\"c1\">// 忙等待</span>\n    <span class=\"n\">available</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>  <span class=\"c1\">// 获得锁</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">release</span> <span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">available</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>   <span class=\"c1\">// 释放锁</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><code class=\"language-plaintext highlighter-rouge\">acquire()</code>或<code class=\"language-plaintext highlighter-rouge\">release()</code>的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p>\n\n<p>互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必连续循环调用<code class=\"language-plaintext highlighter-rouge\">acquire()</code>。\n当多个进程共享同一CPU时，就浪费了CPU周期。\n因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>\n\n<p>需要连续循环忙等的互斥锁（自旋等待），都可称为自旋锁（spin lock）。\n如TS、swap指令；单标志、双标志法、Peterson算法。</p>\n\n<h2 id=\"互斥锁的特性\">互斥锁的特性</h2>\n<ul>\n  <li>需忙等，进程时间片用完才下处理机，<strong>违反“让权等待”原则</strong>；</li>\n  <li>优点：等待期间<strong>不用切换进程上下文</strong>，多处理器系统中，<strong>若上锁时间短，则等待代价很低</strong>；</li>\n  <li>常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区；</li>\n  <li><strong>不太适用于单处理机系统</strong>，忙等的过程中不可能解锁。</li>\n</ul>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">do</span> <span class=\"p\">{</span>\n    <span class=\"n\">acquire</span><span class=\"p\">();</span> <span class=\"c1\">// 进入区</span>\n    <span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 临界区</span>\n    <span class=\"n\">release</span><span class=\"p\">();</span> <span class=\"c1\">// 退出区</span>\n    <span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 剩余区</span>\n<span class=\"p\">}</span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">);</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/26/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E5%85%AD-%E4%BA%92%E6%96%A5%E9%94%81/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十六）互斥锁'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-26T09:42:34+08:00'>Apr 26, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十六）互斥锁</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十五）进程互斥的硬件实现方法",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%BA%94-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/",
      "date"     : "Apr 25, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#中断屏蔽方法\" id=\"markdown-toc-中断屏蔽方法\">中断屏蔽方法</a></li>\n  <li><a href=\"#testandset指令tstsl指令\" id=\"markdown-toc-testandset指令tstsl指令\">TestAndSet指令（TS/TSL指令）</a></li>\n  <li><a href=\"#swap指令exchangexchg指令\" id=\"markdown-toc-swap指令exchangexchg指令\">Swap指令（Exchange/XCHG指令）</a></li>\n</ol>\n\n<h2 id=\"中断屏蔽方法\">中断屏蔽方法</h2>\n<p>利用“开/关中断指令”实现。\n与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>...\n关中断指令;\n临界区;\n开中断指令;\n...\n</code></pre></div></div>\n\n<ul>\n  <li><strong>关中断指令</strong>：关中断后即不允许当前进程被中断，也必然不会发生进程切换；</li>\n  <li>\n    <p><strong>开中断指令</strong>：直到当前进程访问完临界区,再执行开中断指令，才有可能有别的进程上处理机并访问临界区。</p>\n  </li>\n  <li>优点：简单、高效</li>\n  <li>缺点：<strong>不适用于多处理机</strong>；只适用于操作系统内核进程，<strong>不适用于用户进程</strong>（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）。</li>\n</ul>\n\n<h2 id=\"testandset指令tstsl指令\">TestAndSet指令（TS/TSL指令）</h2>\n<p>TS指令是用硬件实现的，<strong>执行的过程不允许被中断</strong>，只能一气呵成。以下是用c语言描述的逻辑：</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/* 布尔型共享变量lock表示当前临界区是否被加锁\n * true表示已加锁,false表示未加锁 \n */</span>\n<span class=\"n\">bool</span> <span class=\"nf\">testAndSet</span> <span class=\"p\">(</span><span class=\"n\">bool</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">bool</span> <span class=\"n\">old</span><span class=\"p\">;</span> \n    <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">lock</span><span class=\"p\">;</span> <span class=\"c1\">// old 用来存放lock原来的值</span>\n    <span class=\"o\">*</span><span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 无论是否已加锁，都设置为true</span>\n    <span class=\"k\">return</span> <span class=\"n\">old</span><span class=\"p\">;</span> <span class=\"c1\">// 返回lock原来的值</span>\n<span class=\"p\">}</span>\n\n<span class=\"cm\">/* 使用TSL指令实现互斥的算法逻辑 */</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">testAndSet</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">lock</span><span class=\"p\">));</span> <span class=\"c1\">// 上锁并检查</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 临界区代码</span>\n<span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 解锁操作</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 剩余区代码</span>\n</code></pre></div></div>\n\n<p>若刚开始lock是false，则TS返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区；\n若刚开始lock是true，则执行TS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。\n相比软件实现方法，TS指令把<strong>“上锁”和“检查”</strong>操作<strong>用硬件的方式</strong>变成了一气呵成的<strong>原子操作</strong>。</p>\n\n<ul>\n  <li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；<strong>适用于多处理机</strong>环境；</li>\n  <li>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。</li>\n</ul>\n\n<h2 id=\"swap指令exchangexchg指令\">Swap指令（Exchange/XCHG指令）</h2>\n<p>Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用c语言描述的逻辑：</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/* Swap指令是交换两个变量的值 */</span>\n<span class=\"n\">swap</span> <span class=\"p\">(</span><span class=\"n\">bool</span> <span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"n\">bool</span> <span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">bool</span> <span class=\"n\">temp</span><span class=\"p\">;</span>\n    <span class=\"n\">temp</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">a</span><span class=\"p\">;</span>\n    <span class=\"o\">*</span><span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"o\">*</span><span class=\"n\">b</span><span class=\"p\">;</span>\n    <span class=\"o\">*</span><span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">temp</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"cm\">/* 使用Swap指令实现互斥的算法逻辑 */</span>\n<span class=\"n\">bool</span> <span class=\"n\">old</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">old</span> <span class=\"o\">==</span> <span class=\"nb\">true</span><span class=\"p\">)</span>\n    <span class=\"n\">swap</span> <span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"n\">lock</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">old</span><span class=\"p\">);</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 临界区代码</span>\n<span class=\"n\">lock</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 解锁操作</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 剩余区代码</span>\n</code></pre></div></div>\n\n<p>逻辑上来看Swap和TS并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true，最后检查old。\n如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。</p>\n\n<ul>\n  <li>优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；<strong>适用于多处理机</strong>环境；</li>\n  <li>缺点：<strong>不满足“让权等待”原则</strong>，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令，从而导致“忙等”。</li>\n</ul>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%BA%94-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E7%A1%AC%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十五）进程互斥的硬件实现方法'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-25T15:24:46+08:00'>Apr 25, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十五）进程互斥的硬件实现方法</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十四）进程互斥的软件实现方法",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/",
      "date"     : "Apr 25, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#单标志法\" id=\"markdown-toc-单标志法\">单标志法</a></li>\n  <li><a href=\"#双标志先检查法\" id=\"markdown-toc-双标志先检查法\">双标志先检查法</a></li>\n  <li><a href=\"#双标志后检查法\" id=\"markdown-toc-双标志后检查法\">双标志后检查法</a></li>\n  <li><a href=\"#peterson算法\" id=\"markdown-toc-peterson算法\">Peterson算法</a></li>\n</ol>\n\n<h2 id=\"单标志法\">单标志法</h2>\n\n<p>算法思想：两个进程中，一个进程在<strong>访问完临界区后</strong>会把使用临界区的<strong>权限转交</strong>给另一个进程。\n也就是说每个进程进入临界区的权限只能被另一个进程赋予。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c1\">// turn表示当前允许进入临界区的进程号</span>\n\n<span class=\"cm\">/* P0进程 */</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">turn</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">);</span> <span class=\"c1\">// 1.进入区</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 2.临界区</span>\n<span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">// 3.退出区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 4.剩余区</span>\n\n<span class=\"cm\">/* P1进程 */</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">turn</span> <span class=\"o\">!=</span> <span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 5.进入区</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 6.临界区</span>\n<span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c1\">// 7.退出区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 8.剩余区</span>\n</code></pre></div></div>\n\n<p>turn的初值为0，即刚开始只允许О号进程进入临界区。</p>\n\n<p>若P1先上处理机运行，则会一直卡在5。\n直到P1的时间片用完，发生调度，切换PO上处理机运行。\n代码1不会卡住PO，PO可以正常访问临界区，在PO访问临界区期间即时切换回P1, P1依然会卡在5。</p>\n\n<p>只有PO在退出区将turn改为1后，P1才能进入临界区。\n因此，该算法<strong>可以实现“同一时刻最多只允许一个进程访问临界区”</strong>。</p>\n\n<p>缺点：\n只能按PO-&gt;P1-&gt;PO-&gt;P1这样轮流访问。\n这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是PO，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</p>\n\n<p>因此，<strong>单标志法</strong>存在的主要问题是：<strong>违背“空闲让进”原则。</strong></p>\n\n<h2 id=\"双标志先检查法\">双标志先检查法</h2>\n<p>算法思想：设置一个布尔型数组<code class=\"language-plaintext highlighter-rouge\">flag[0]</code>，数组中各个元素用来<strong>标记各进程想进入临界区的意愿。</strong>\n比如<code class=\"language-plaintext highlighter-rouge\">flag[0]=ture</code>意味着0号进程P0现在想要进入临界区。\n每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志<code class=\"language-plaintext highlighter-rouge\">flag[i]</code>设为<code class=\"language-plaintext highlighter-rouge\">true</code>，之后开始访问临界区。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">bool</span> <span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span> <span class=\"c1\">// 表示进入临界区意愿的数组</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* P0进程 */</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]);</span> <span class=\"c1\">// 1.</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 2.修改标记为想要进入临界区</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 3.临界区</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 4.退出区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n\n<span class=\"cm\">/* P1进程 */</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span> <span class=\"c1\">// 5.</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 6.修改标记为想要进入临界区</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 7.临界区</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 8.退出区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n</code></pre></div></div>\n\n<p>若按照152637的顺序执行，PO和P1将会同时访问临界区。</p>\n\n<p>因此，<strong>双标志先检查法</strong>的主要问题是：<strong>违反“忙则等待”原则。</strong></p>\n\n<p>原因在于，<strong>进入区</strong>的“检查”和“上锁”<strong>两个处理不是一气呵成</strong>的。“检查”后，“上锁”前可能发生进程切换。</p>\n\n<h2 id=\"双标志后检查法\">双标志后检查法</h2>\n\n<p>算法思想：双标志先检查法的改版。\n前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。\n因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">bool</span> <span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span> <span class=\"c1\">// 表示进入临界区意愿的数组</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* P0进程 */</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 1.修改标记为想要进入临界区</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]);</span> <span class=\"c1\">// 2.如果P1也想进入临界区，则P0循环等待</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 3.临界区</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 4.退出区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n\n<span class=\"cm\">/* P1进程 */</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 5.修改标记为想要进入临界区</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]);</span> <span class=\"c1\">// 6.如果P0也想进入临界区，则P1循环等待</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 7.临界区</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 8.退出区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n</code></pre></div></div>\n\n<p>若按照1526的顺序执行，P0和P1将都无法进入临界区。</p>\n\n<p>因此，<strong>双标志后检查法</strong>虽然<strong>解决了“忙则等待”的问题</strong>，但是又<strong>违背了“空闲让进”和“有限等待”原则</strong>，会因各进程都长期无法访问临界资源而<strong>产生“饥饿”</strong>现象。</p>\n\n<h2 id=\"peterson算法\">Peterson算法</h2>\n\n<p>算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试谦让。</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">bool</span> <span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">];</span> <span class=\"c1\">// 表示进入临界区意愿的数组</span>\n<span class=\"kt\">int</span> <span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c1\">// turn 表示优先让哪个线程进入临界区</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n\n<span class=\"cm\">/* P0进程 */</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 1.进入区，表示自己想要进入临界区</span>\n<span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"c1\">// 2.进入区，表示可以优先让对方进入临界区</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">turn</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">);</span> <span class=\"c1\">// 3.进入区，如果对方想进且最后一次是自己谦让则进行循环等待</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 4.临界区</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 5.退出区，表示自己不想访问临界区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n\n<span class=\"cm\">/* P1进程 */</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">true</span><span class=\"p\">;</span> <span class=\"c1\">// 6.进入区，表示自己想要进入临界区</span>\n<span class=\"n\">turn</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"c1\">// 7.进入区，可以优先让对方进入临界区</span>\n<span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">turn</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">);</span> <span class=\"c1\">// 8.进入区，如果对方想进且最后一次是自己谦让则进行循环等待</span>\n<span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 9.临界区</span>\n<span class=\"n\">flag</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">;</span> <span class=\"c1\">// 10.退出区，表示自己不想访问临界区</span>\n<span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> \n</code></pre></div></div>\n\n<p><strong>Peterson算法</strong>用软件方法解决了进程互斥问题，<strong>遵循了空闲让进、忙则等待、有限等待三个原则</strong>，但是依然<strong>未遵循让权等待的原则。</strong></p>\n\n<p>Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E5%9B%9B-%E8%BF%9B%E7%A8%8B%E4%BA%92%E6%96%A5%E7%9A%84%E8%BD%AF%E4%BB%B6%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%B3%95/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十四）进程互斥的软件实现方法'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>3 min read <time class='article__date' datetime='2022-04-25T10:56:13+08:00'>Apr 25, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十四）进程互斥的软件实现方法</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十三）进程同步与互斥",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B8%89-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/",
      "date"     : "Apr 25, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#进程同步\" id=\"markdown-toc-进程同步\">进程同步</a></li>\n  <li><a href=\"#进程互斥\" id=\"markdown-toc-进程互斥\">进程互斥</a>    <ol>\n      <li><a href=\"#进程互斥的概念\" id=\"markdown-toc-进程互斥的概念\">进程互斥的概念</a></li>\n      <li><a href=\"#互斥访问的四个部分\" id=\"markdown-toc-互斥访问的四个部分\">互斥访问的四个部分</a></li>\n      <li><a href=\"#互斥访问临界资源的四个原则\" id=\"markdown-toc-互斥访问临界资源的四个原则\">互斥访问临界资源的四个原则</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"进程同步\">进程同步</h2>\n\n<p>进程具有异步性的特征。异步性是指，各并发执行的进程以各自独立的、不可预知的速度向前推进。</p>\n\n<p>如图，前文的管道通信可以作为一个进程同步的例子。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-管道通信.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>在管道中，读进程和写进程并发地运行，由于并发必然导致异步性，因此“写数据”和“读数据”两个操作执行的<strong>先后顺序是不确定</strong>的。\n而<strong>实际应用中</strong>，又<strong>必须</strong>按照<strong>“写数据→读数据”的顺序</strong>来执行的。\n如何解决这种异步问题，就是“进程同步”所讨论的内容。</p>\n\n<p>操作系统要提供“进程同步机制”来实现上述需求。</p>\n\n<p><strong>同步</strong>亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要<strong>在某些位置上协调它们的工作次序而产生的制约关系</strong>。\n进程间的直接制约关系就是源于它们之间的相互合作。</p>\n\n<h2 id=\"进程互斥\">进程互斥</h2>\n\n<h3 id=\"进程互斥的概念\">进程互斥的概念</h3>\n\n<p>进程的“并发”需要“共享”的支持。各个并发执行的进程不可避免的需要共享一些系统资源（比如内存，又比如打印机、摄像头这样的I/O设备）</p>\n\n<p>资源共享方式包括<strong>互斥共享方式</strong>和<strong>同时共享方式</strong>：</p>\n<ul>\n  <li>互斥共享方式：系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong>；</li>\n  <li>同时共享方式：系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong>。</li>\n</ul>\n\n<p>我们把<strong>一个时间段内只允许一个进程使用</strong>的资源称为<strong>临界资源</strong>。\n许多物理设备（比如摄像头、打印机）都属于临界资源。\n此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p>\n\n<p>对临界资源的访问，必须<strong>互斥地</strong>进行。\n互斥，亦称<strong>间接制约关系</strong>。\n<strong>进程互斥</strong>指当一个<strong>进程访问某临界资源</strong>时，<strong>另一个想要访问该临界资源的进程必须等待</strong>。\n当前访问临界资源的进程访问结束，<strong>释放该资源之后</strong>，<strong>另一个进程才能去访问临界资源</strong>。</p>\n\n<h3 id=\"互斥访问的四个部分\">互斥访问的四个部分</h3>\n\n<p>对临界资源的互斥访问，可以在逻辑上分为如下四个部分:</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">do</span> <span class=\"p\">{</span>\n    <span class=\"n\">entry</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 进入区</span>\n    <span class=\"n\">critical</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 临界区</span>\n    <span class=\"n\">exit</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 退出区</span>\n    <span class=\"n\">remainder</span> <span class=\"n\">section</span><span class=\"p\">;</span> <span class=\"c1\">// 剩余区</span>\n<span class=\"p\">}</span> <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">);</span>\n</code></pre></div></div>\n\n<ul>\n  <li><strong>进入区</strong>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（上锁），以阻止其他进程同时进入临界区；</li>\n  <li><strong>临界区</strong>是访问资源的那段代码；</li>\n  <li><strong>退出区</strong>负责解除正在访问临界资源的标志（解锁）；</li>\n  <li>剩余区做其他处理。</li>\n</ul>\n\n<p>注意:\n<strong>临界区</strong>是进程中<strong>访问临界资源</strong>的代码段。</p>\n\n<p><strong>进入区和退出区</strong>是负责<strong>实现互斥的代码段</strong>。</p>\n\n<p>临界区也可称为“临界段”。</p>\n\n<h3 id=\"互斥访问临界资源的四个原则\">互斥访问临界资源的四个原则</h3>\n\n<p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p>\n\n<ol>\n  <li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</li>\n  <li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</li>\n  <li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</li>\n  <li><strong>让权等待</strong>。当进程不能进入临界区时，应<strong>立即释放处理机</strong>，防止进程忙等待。</li>\n</ol>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/25/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B8%89-%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E4%B8%8E%E4%BA%92%E6%96%A5/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十三）进程同步与互斥'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-25T10:21:08+08:00'>Apr 25, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十三）进程同步与互斥</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十二）RR、PSA、MLFQ调度算法",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%BA%8C-RR-PSA-MLFQ%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/",
      "date"     : "Apr 24, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#简介\" id=\"markdown-toc-简介\">简介</a></li>\n  <li><a href=\"#rr算法\" id=\"markdown-toc-rr算法\">RR算法</a>    <ol>\n      <li><a href=\"#rr算法特点\" id=\"markdown-toc-rr算法特点\">RR算法特点</a></li>\n      <li><a href=\"#例子\" id=\"markdown-toc-例子\">例子</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#psa算法\" id=\"markdown-toc-psa算法\">PSA算法</a>    <ol>\n      <li><a href=\"#psa算法特点\" id=\"markdown-toc-psa算法特点\">PSA算法特点</a></li>\n      <li><a href=\"#非抢占式psa\" id=\"markdown-toc-非抢占式psa\">非抢占式PSA</a></li>\n      <li><a href=\"#抢占式psa\" id=\"markdown-toc-抢占式psa\">抢占式PSA</a></li>\n      <li><a href=\"#补充\" id=\"markdown-toc-补充\">补充</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#mlfq算法\" id=\"markdown-toc-mlfq算法\">MLFQ算法</a>    <ol>\n      <li><a href=\"#mlfq算法特点\" id=\"markdown-toc-mlfq算法特点\">MLFQ算法特点</a></li>\n      <li><a href=\"#例子-1\" id=\"markdown-toc-例子-1\">例子</a></li>\n      <li><a href=\"#补充-1\" id=\"markdown-toc-补充-1\">补充</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"简介\">简介</h2>\n\n<p>本章介绍三种适用于<strong>交互式系统</strong>的调度算法。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法</th>\n      <th>可抢占</th>\n      <th>优点</th>\n      <th>缺点</th>\n      <th>会导致饥饿</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>RR</td>\n      <td>抢占式</td>\n      <td>公平，适用于分时系统</td>\n      <td>频繁切换存在开销；不区分优先级</td>\n      <td>不会</td>\n    </tr>\n    <tr>\n      <td>PSA</td>\n      <td>有抢占式，也有非抢占式</td>\n      <td>区分优先级，适用于实时系统</td>\n      <td>可能导致饥饿</td>\n      <td>会</td>\n    </tr>\n    <tr>\n      <td>MLFQ</td>\n      <td>抢占式</td>\n      <td>平衡、优秀</td>\n      <td>可能导致饥饿</td>\n      <td>会</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>比起早期的批处理操作系统来说，由于计算机造价大幅降低 因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。\n而这几种算法恰好能较好地满足交互式系统的需求。因此<strong>这三种算法适合用于交互式系统</strong>。（比如UNIX使用的就是多级反馈队列调度算法）</p>\n\n<h2 id=\"rr算法\">RR算法</h2>\n\n<h3 id=\"rr算法特点\">RR算法特点</h3>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法名</th>\n      <th>时间片轮转（Round-Robin，RR）</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>算法思想</td>\n      <td>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</td>\n    </tr>\n    <tr>\n      <td>算法规则</td>\n      <td>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个<strong>时间片</strong>（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</td>\n    </tr>\n    <tr>\n      <td>用于作业/进程调度</td>\n      <td>用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</td>\n    </tr>\n    <tr>\n      <td>是否可抢占</td>\n      <td>若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于<strong>抢占式</strong>的算法。由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到</td>\n    </tr>\n    <tr>\n      <td>优缺点</td>\n      <td>优点：公平、响应快，适用于分时操作系统；<br />缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。</td>\n    </tr>\n    <tr>\n      <td>是否会导致饥饿</td>\n      <td>不会</td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"例子\">例子</h3>\n\n<p>各进程到达就绪队列的时间、需要的运行时间如下表所示。使用<strong>时间片轮转调度</strong>算法，分析时间片大小分别是2、5时的进程运行情况。</p>\n\n<p>注意：常用于分时操作系统，更注重响应时间，因而此处不计算周转时间。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>到达时间</th>\n      <th>运行时间</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>P1</td>\n      <td>0</td>\n      <td>5</td>\n    </tr>\n    <tr>\n      <td>P2</td>\n      <td>2</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <td>P3</td>\n      <td>4</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <td>P4</td>\n      <td>5</td>\n      <td>6</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><strong>时间片轮转调度算法</strong>轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）</p>\n\n<ul>\n  <li>时间片大小为2</li>\n</ul>\n\n<table>\n  <thead>\n    <tr>\n      <th>时刻</th>\n      <th>就绪队列</th>\n      <th>分析</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td><strong>P1(5)</strong></td>\n      <td>只有P1到达就绪队列，让P1上处理机运行一个时间片</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td><strong>P2(4)</strong>-&gt;P1(3)</td>\n      <td>P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（注意：2时刻，P1下处理机，同一时刻新进程P2到达，<strong>默认新到达的进程先进入就绪队列</strong>）</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td><strong>P1(3)</strong>-&gt;P3(1)-&gt;P2(2)</td>\n      <td>P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>P3(1)-&gt;P2(2)-&gt;P4(6)</td>\n      <td>P4到达插到就绪队尾。由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中</td>\n    </tr>\n    <tr>\n      <td>6</td>\n      <td><strong>P3(1)</strong>-&gt;P2(2)-&gt;P4(6)-&gt;P1(1)</td>\n      <td>P1时间片用完，下处理机，重新放回就绪队尾，发生调度</td>\n    </tr>\n    <tr>\n      <td>7</td>\n      <td><strong>P2(2)</strong>-&gt;P4(6)-&gt;P1(1)</td>\n      <td>虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间。运行完了会<strong>主动放弃处理机</strong>，因此也会发生调度。队头进程P2上处理机。</td>\n    </tr>\n    <tr>\n      <td>9</td>\n      <td><strong>P4(6)</strong>-&gt;P1(1)</td>\n      <td>进程P2时间片用完，并刚好运行完，发生调度，P4上处理机</td>\n    </tr>\n    <tr>\n      <td>11</td>\n      <td><strong>P1(1)</strong>-&gt;P4(4)</td>\n      <td>P4时间片用完，重新回到就绪队列。P1上处理机</td>\n    </tr>\n    <tr>\n      <td>12</td>\n      <td><strong>P4(4)</strong></td>\n      <td>P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机</td>\n    </tr>\n    <tr>\n      <td>14</td>\n      <td>-</td>\n      <td>就绪队列为空，因此让P4接着运行一个时间片</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法5.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<ul>\n  <li>时间片大小为5</li>\n</ul>\n\n<table>\n  <thead>\n    <tr>\n      <th>时刻</th>\n      <th>就绪队列</th>\n      <th>分析</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td><strong>P1(5)</strong></td>\n      <td>只有P1到达，P1上处理机</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>P2(4)</td>\n      <td>P2到达，但P1时间片尚未结束，因此<strong>暂不调度</strong></td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>P2(4)-&gt;P3(1)</td>\n      <td>P3到达，但P1时间片尚未结束，因此暂不调度</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td><strong>P2(4)</strong>-&gt;P3(1)-&gt;P4(6)</td>\n      <td>P4到达，同时，P1运行结束。发生调度，P2上处理机</td>\n    </tr>\n    <tr>\n      <td>9</td>\n      <td><strong>P3(1)</strong>-&gt;P4(6)</td>\n      <td>P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度</td>\n    </tr>\n    <tr>\n      <td>10</td>\n      <td><strong>P4(6)</strong></td>\n      <td>P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度</td>\n    </tr>\n    <tr>\n      <td>15</td>\n      <td>-</td>\n      <td>P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法6.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"psa算法\">PSA算法</h2>\n\n<h3 id=\"psa算法特点\">PSA算法特点</h3>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法名</th>\n      <th>优先级调度（Priority Scheduling Algorithm，PSA）</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>算法思想</td>\n      <td>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序</td>\n    </tr>\n    <tr>\n      <td>算法规则</td>\n      <td>每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</td>\n    </tr>\n    <tr>\n      <td>用于作业/进程调度</td>\n      <td>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后的I/O调度中</td>\n    </tr>\n    <tr>\n      <td>是否可抢占</td>\n      <td>抢占式、非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。</td>\n    </tr>\n    <tr>\n      <td>优缺点</td>\n      <td>优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。<br />缺点：若源源不断地有高优先级进程到来，则可能导致饥饿</td>\n    </tr>\n    <tr>\n      <td>是否会导致饥饿</td>\n      <td>会</td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"非抢占式psa\">非抢占式PSA</h3>\n<p>各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用<strong>非抢占式的优先级调度算法</strong>，分析进程运行情况。（注：优先数越大，优先级越高)</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>到达时间</th>\n      <th>运行时间</th>\n      <th>优先数</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>P1</td>\n      <td>0</td>\n      <td>7</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <td>P2</td>\n      <td>2</td>\n      <td>4</td>\n      <td>2</td>\n    </tr>\n    <tr>\n      <td>P3</td>\n      <td>4</td>\n      <td>1</td>\n      <td>3</td>\n    </tr>\n    <tr>\n      <td>P4</td>\n      <td>5</td>\n      <td>4</td>\n      <td>2</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><strong>非抢占式的优先级调度算法</strong>：每次调度时选择<strong>当前已到达且优先级最高</strong>的进程。当前进程<strong>主动放弃处理机时</strong>发生调度。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>时刻</th>\n      <th>就绪队列</th>\n      <th>分析</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td><strong>P1</strong></td>\n      <td>只有P1到达，P1上处理机</td>\n    </tr>\n    <tr>\n      <td>7</td>\n      <td>P2、<strong>P3</strong>、P4</td>\n      <td>P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机</td>\n    </tr>\n    <tr>\n      <td>8</td>\n      <td><strong>P2</strong>、P4</td>\n      <td>P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机</td>\n    </tr>\n    <tr>\n      <td>12</td>\n      <td><strong>P4</strong></td>\n      <td>P2完成，就绪队列只剩P4，P4上处理机</td>\n    </tr>\n    <tr>\n      <td>16</td>\n      <td>-</td>\n      <td>P4完成，所有进程都结束</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法7.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h3 id=\"抢占式psa\">抢占式PSA</h3>\n<p>抢占式的优先级调度算法：每次调度时选择<strong>当前已到达且优先级最高</strong>的进程。当前进程<strong>主动放弃处理机时</strong>发生调度。\n另外，当<strong>就绪队列发生改变</strong>时也需要检查是会发生抢占。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>时刻</th>\n      <th>就绪队列</th>\n      <th>分析</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td><strong>P1</strong></td>\n      <td>只有P1到达，P1上处理机</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>P1、<strong>P2</strong></td>\n      <td>P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>P1、P2、<strong>P3</strong></td>\n      <td>P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td>P1、<strong>P2</strong>、P4</td>\n      <td>P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机</td>\n    </tr>\n    <tr>\n      <td>7</td>\n      <td>P1、<strong>P4</strong></td>\n      <td>P2完成，就绪队列只剩P1、P4，P4上处理机。</td>\n    </tr>\n    <tr>\n      <td>11</td>\n      <td><strong>P1</strong></td>\n      <td>P4完成，P1上处理机</td>\n    </tr>\n    <tr>\n      <td>16</td>\n      <td>-</td>\n      <td>P1完成，所有进程都结束</td>\n    </tr>\n  </tbody>\n</table>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法8.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h3 id=\"补充\">补充</h3>\n\n<p>就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置；</p>\n\n<p>根据优先级是否可以动态改变，可将优先级分为<strong>静态优先级</strong>和<strong>动态优先级</strong>两种：</p>\n<ul>\n  <li>静态优先级:创建进程时确定，之后一直不变；</li>\n  <li>动态优先级:创建进程时有一个初始值，之后会根据情况动态地调整优先级。</li>\n</ul>\n\n<p>通常情况下：</p>\n<ul>\n  <li>系统进程优先级<strong>高于</strong>用户进程；</li>\n  <li>前台进程优先级<strong>高于</strong>后台进程；</li>\n  <li>操作系统更偏好I/O型进程（或称I/O繁忙型进程，I/O设备和CPU可以<strong>并行</strong>工作。如果优先让I/O繁忙型进程运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。）</li>\n</ul>\n\n<p>与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）</p>\n\n<p>可以从追求公平、提升资源利用率等角度考虑动态优先级的调整：</p>\n<ul>\n  <li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级；</li>\n  <li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级；</li>\n  <li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级。</li>\n</ul>\n\n<h2 id=\"mlfq算法\">MLFQ算法</h2>\n\n<h3 id=\"mlfq算法特点\">MLFQ算法特点</h3>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法名</th>\n      <th>多级反馈队列调度算法（Multi-Level Feedback Queue，MLFQ）</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>算法思想</td>\n      <td>对其他调度算法的折中权衡</td>\n    </tr>\n    <tr>\n      <td>算法规则</td>\n      <td>1．设置多级就绪队列，各级队列<strong>优先级从高到低，时间片从小到大</strong><br />2．新进程到达时先进入第1级队列，按<strong>FCFS原则排队等待</strong>被分配时间片，若<strong>用完时间片进程还未结束，则进程进入下一级队列队尾</strong>。 如果此时已经是在最下级的队列，则重新放回该队列队尾<br />3．只有<strong>第k级队列为空时，才会为k+1级队头的进程分配时间片</strong></td>\n    </tr>\n    <tr>\n      <td>用于作业/进程调度</td>\n      <td>用于进程调度</td>\n    </tr>\n    <tr>\n      <td>是否可抢占</td>\n      <td><strong>抢占式</strong>的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。</td>\n    </tr>\n    <tr>\n      <td>优缺点</td>\n      <td>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）</td>\n    </tr>\n    <tr>\n      <td>是否会导致饥饿</td>\n      <td>会</td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"例子-1\">例子</h3>\n<p>各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程的运行过程。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>到达时间</th>\n      <th>运行时间</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>P1</td>\n      <td>0</td>\n      <td>8</td>\n    </tr>\n    <tr>\n      <td>P2</td>\n      <td>1</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <td>P3</td>\n      <td>5</td>\n      <td>1</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>设置多级就绪队列，各级队列<strong>优先级从高到低，时间片从小到大；</strong></p>\n\n<p><strong>新进程到达时先进入第1级队列</strong>，按<strong>FCFS原则</strong>排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。\n如果此时已经在最下级的队列，则重新放回最下级队列队尾；</p>\n\n<p>只有<strong>第k级队列为空</strong>时，才会<strong>为k+1级队头的进程分配时间片</strong>；</p>\n\n<p><strong>被抢占处理机的进程</strong>重新放回<strong>原队列队尾</strong>。</p>\n\n<p>假设此时的多级反馈队列共3级，3级队列优先级从高到低，时间片分别为1、2、4。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>时刻</th>\n      <th>第1级队列（时间片1）</th>\n      <th>第2级队列（时间片2）</th>\n      <th>第3级队列（时间片4）</th>\n      <th>分析</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td><strong>P1（8）</strong></td>\n      <td>-</td>\n      <td>-</td>\n      <td>仅有P1到达，上处理机</td>\n    </tr>\n    <tr>\n      <td>1</td>\n      <td><strong>P2（4）</strong></td>\n      <td>P1（7）</td>\n      <td>-</td>\n      <td>P1<strong>时间片用完，但任务未结束，放到第2级队列</strong>，同时P2到达第1级队列，优先上处理机运行</td>\n    </tr>\n    <tr>\n      <td>2</td>\n      <td>-</td>\n      <td><strong>P1（7）</strong>-&gt;P2（3）</td>\n      <td>-</td>\n      <td>P2时间片用完，但任务未结束，放到第2级队列，此时第1级队列为空，第2级队列队头的P1上处理机运行</td>\n    </tr>\n    <tr>\n      <td>4</td>\n      <td>-</td>\n      <td><strong>P2（3）</strong></td>\n      <td>P1（5）</td>\n      <td>P1时间片用完，但任务未结束，放到第3级队列，此时第1级队列为空，P2上处理机运行</td>\n    </tr>\n    <tr>\n      <td>5</td>\n      <td><strong>P3（1）</strong></td>\n      <td>P2（2）</td>\n      <td>P1（5）</td>\n      <td>P3到达，处于更高的优先级队列，<strong>抢占处理机</strong>，P2下处理机，被<strong>重新放回原队列队尾</strong></td>\n    </tr>\n    <tr>\n      <td>6</td>\n      <td>-</td>\n      <td><strong>P2（2）</strong></td>\n      <td>P1（5）</td>\n      <td>P3运行结束，第2级队列的P2上处理机</td>\n    </tr>\n    <tr>\n      <td>8</td>\n      <td>-</td>\n      <td>-</td>\n      <td><strong>P1（5）</strong></td>\n      <td>P2运行结束，第3级队列的P1上处理机</td>\n    </tr>\n    <tr>\n      <td>12</td>\n      <td>-</td>\n      <td>-</td>\n      <td><strong>P1（1）</strong></td>\n      <td>P1时间片用完，第3级队列已经是<strong>最低级，重新放回</strong>，且队列中仅剩P1，上处理机</td>\n    </tr>\n    <tr>\n      <td>13</td>\n      <td>-</td>\n      <td>-</td>\n      <td>-</td>\n      <td>全部程序运行结束</td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"补充-1\">补充</h3>\n\n<p>MLFQ不仅可以使用固定优先级和FCFS的调度策略，还可以灵活选用别的优先级划分和调度策略。</p>\n\n<p>如图，系统中按进程类型设置多个队列，进程创建成功后插入某个队列。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法9.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>队列之间可采取固定优先级，或<strong>时间片划分</strong>：</p>\n<ul>\n  <li>固定优先级：高优先级空时低优先级进程才能被调度；</li>\n  <li>时间片划分：如三个队列分配时间50%、40%、10%</li>\n</ul>\n\n<p>各队列可采用不同的调度策略，如：</p>\n<ul>\n  <li>系统进程队列采用PSA</li>\n  <li>交互式队列采用RR</li>\n  <li>批处理队列采用FCFS</li>\n</ul>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%BA%8C-RR-PSA-MLFQ%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十二）RR、PSA、MLFQ调度算法'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>3 min read <time class='article__date' datetime='2022-04-24T11:57:12+08:00'>Apr 24, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十二）RR、PSA、MLFQ调度算法</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十一）FCFS、SJF、HRRN调度算法",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B8%80-FCFS-SJF-HRRN%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/",
      "date"     : "Apr 24, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#简介\" id=\"markdown-toc-简介\">简介</a></li>\n  <li><a href=\"#fcfs算法\" id=\"markdown-toc-fcfs算法\">FCFS算法</a>    <ol>\n      <li><a href=\"#fcfs算法特点\" id=\"markdown-toc-fcfs算法特点\">FCFS算法特点</a></li>\n      <li><a href=\"#例子\" id=\"markdown-toc-例子\">例子</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#sjf算法\" id=\"markdown-toc-sjf算法\">SJF算法</a>    <ol>\n      <li><a href=\"#sjf算法特点\" id=\"markdown-toc-sjf算法特点\">SJF算法特点</a></li>\n      <li><a href=\"#例子-1\" id=\"markdown-toc-例子-1\">例子</a></li>\n      <li><a href=\"#抢占式版本srtn算法\" id=\"markdown-toc-抢占式版本srtn算法\">抢占式版本——SRTN算法</a></li>\n      <li><a href=\"#注意\" id=\"markdown-toc-注意\">注意</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#hrrn算法\" id=\"markdown-toc-hrrn算法\">HRRN算法</a>    <ol>\n      <li><a href=\"#关于fcfs和sjf的思考\" id=\"markdown-toc-关于fcfs和sjf的思考\">关于FCFS和SJF的思考</a></li>\n      <li><a href=\"#响应比\" id=\"markdown-toc-响应比\">响应比</a></li>\n      <li><a href=\"#hrrn算法特点\" id=\"markdown-toc-hrrn算法特点\">HRRN算法特点</a></li>\n      <li><a href=\"#例子-2\" id=\"markdown-toc-例子-2\">例子</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"简介\">简介</h2>\n\n<p>本章介绍三种适用于<strong>早期批处理系统</strong>的调度算法。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法</th>\n      <th>可抢占</th>\n      <th>优点</th>\n      <th>缺点</th>\n      <th>考虑运行和等待时间</th>\n      <th>会导致饥饿</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>FCFS</td>\n      <td>非抢占</td>\n      <td>公平、实现简单</td>\n      <td>对短作业不利</td>\n      <td>等待时间√<br />运行时间×</td>\n      <td>不会</td>\n    </tr>\n    <tr>\n      <td>SJF/SPF</td>\n      <td>非抢占，也有抢占式版本最短剩余时间优先算法（SRTN）</td>\n      <td>几乎最短的平均等待时间/周转时间</td>\n      <td>对长作业不利，可能导致饥饿；<br />难以实现真正的短作业优先</td>\n      <td>等待时间×<br />运行时间√</td>\n      <td>会</td>\n    </tr>\n    <tr>\n      <td>HRRN</td>\n      <td>非抢占</td>\n      <td>FCFS和SJF算法的折中，综合考虑了等待和运行时间</td>\n      <td>-</td>\n      <td>等待时间√<br />运行时间√</td>\n      <td>不会</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度。\n因此对于用户来说，交互性很糟糕。因此过三种算法一般适合用于<strong>早期的批处理系统</strong>，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。\n而适合用于交互式系统的调度算法在下章介绍。</p>\n\n<h2 id=\"fcfs算法\">FCFS算法</h2>\n\n<h3 id=\"fcfs算法特点\">FCFS算法特点</h3>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法名</th>\n      <th>先来先服务（First Come First Serve，FCFS）</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>算法思想</td>\n      <td>主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）</td>\n    </tr>\n    <tr>\n      <td>算法规则</td>\n      <td>按照作业/进程到达的<strong>先后顺序进行服务</strong></td>\n    </tr>\n    <tr>\n      <td>用于作业/进程调度</td>\n      <td>用于<strong>作业调度</strong>时，考虑的是哪个作业先到达<strong>后备队列</strong>；<br />用于<strong>进程调度</strong>时，考虑的是哪个进程先到达<strong>就绪队列</strong></td>\n    </tr>\n    <tr>\n      <td>是否可抢占</td>\n      <td>非抢占式算法</td>\n    </tr>\n    <tr>\n      <td>优缺点</td>\n      <td>优点：公平、算法实现简单；<br />缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即<strong>FCFS算法对长作业有利，对短作业不利</strong></td>\n    </tr>\n    <tr>\n      <td>是否会导致饥饿</td>\n      <td>不会</td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"例子\">例子</h3>\n<p>各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>到达时间</th>\n      <th>运行时间</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>P1</td>\n      <td>0</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <td>P2</td>\n      <td>2</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <td>P3</td>\n      <td>4</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <td>P4</td>\n      <td>5</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>解答：</p>\n\n<p>FCFS按照<strong>到达的先后顺序调度</strong>，事实上就是<strong>等待时间越久的越优先</strong>得到服务。</p>\n\n<p>因此，调度顺序为P1&gt;P2&gt;P3&gt;P4，如图所示。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法1.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>周转时间 = 完成时间-到达时间\n带权周转时间 = 周转时间 / 运行时间\n等待时间 = 周转时间 - 运行时间</p>\n\n<p>注意：本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。\n如果是又有计算、又有I/O操作的进程，其等待时间就是周转时间 - 运行时间 - I/O操作的时间。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>P1</th>\n      <th>P2</th>\n      <th>P3</th>\n      <th>P4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>周转时间</td>\n      <td>7-0=7</td>\n      <td>11-2=9</td>\n      <td>12-4=8</td>\n      <td>16-5=11</td>\n    </tr>\n    <tr>\n      <td>带权周转时间</td>\n      <td>7/7=1</td>\n      <td>9/4=2.25</td>\n      <td>8/1=8</td>\n      <td>11/4=2.75</td>\n    </tr>\n    <tr>\n      <td>等待时间</td>\n      <td>7-7=0</td>\n      <td>9-4=5</td>\n      <td>8-1=7</td>\n      <td>11-4=7</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>平均周转时间 = (7+9+8+11) / 4 = 8.75</p>\n\n<p>平均带权周转时间 = (1+2.25+8+2.75) / 4 = 3.5</p>\n\n<p>平均等待时间 = (0+5+7+7) / 4 = 4.75</p>\n\n<h2 id=\"sjf算法\">SJF算法</h2>\n\n<h3 id=\"sjf算法特点\">SJF算法特点</h3>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法名</th>\n      <th>短作业优先（Shortest Job First，SJF）</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>算法思想</td>\n      <td>追求<strong>最少的平均等待时间、最少的平均周转时间、最少的平均平均带权周转时间</strong></td>\n    </tr>\n    <tr>\n      <td>算法规则</td>\n      <td>最短的作业/进程优先得到服务（所谓“最短”，是指<strong>要求服务时间最短</strong>）</td>\n    </tr>\n    <tr>\n      <td>用于作业/进程调度</td>\n      <td>即可用于作业调度，也可用于进程调度。用于进程调度时称为短进程优先(Shortest Process First，SPF）算法</td>\n    </tr>\n    <tr>\n      <td>是否可抢占</td>\n      <td>SJF/SPF是非抢占式的算法。但是也有抢占式的版本——<strong>最短剩余时间优先算法</strong>（Shortest Remaining Time Next，SRTN）</td>\n    </tr>\n    <tr>\n      <td>优缺点</td>\n      <td>优点：几乎最短的平均等待时间、平均周转时间；<br />缺点：不公平。<strong>对短作业有利，对长作业不利。</strong>可能产生<strong>饥饿现象</strong>。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</td>\n    </tr>\n    <tr>\n      <td>是否会导致饥饿</td>\n      <td>会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”</td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"例子-1\">例子</h3>\n<p>各进程到达就绪队列的时间、需要的运行时间如下表所示。使用非抢占式的短作业优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>到达时间</th>\n      <th>运行时间</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>P1</td>\n      <td>0</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <td>P2</td>\n      <td>2</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <td>P3</td>\n      <td>4</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <td>P4</td>\n      <td>5</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>解答：</p>\n\n<p>短作业/进程优先调度算法每次调度时选择<strong>当前已到达且运行时间最短的</strong>作业/进程。</p>\n\n<p>因此，调度顺序为P1&gt;P3&gt;P2&gt;P4</p>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法2.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>P1</th>\n      <th>P2</th>\n      <th>P3</th>\n      <th>P4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>周转时间</td>\n      <td>7-0=7</td>\n      <td>8-4=4</td>\n      <td>12-2=10</td>\n      <td>16-5=11</td>\n    </tr>\n    <tr>\n      <td>带权周转时间</td>\n      <td>7/7=1</td>\n      <td>4/1=4</td>\n      <td>10/4=2.5</td>\n      <td>11/4=2.75</td>\n    </tr>\n    <tr>\n      <td>等待时间</td>\n      <td>7-7=0</td>\n      <td>4-1=3</td>\n      <td>10-4=6</td>\n      <td>11-4=7</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>平均周转时间 = (7+4+10+11) / 4 = 8</p>\n\n<p>平均带权周转时间 = (1+4+2.5+2.75) / 4 = 2.56</p>\n\n<p>平均等待时间 = (0+3+6+7) / 4 = 4</p>\n\n<p>对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低</p>\n\n<h3 id=\"抢占式版本srtn算法\">抢占式版本——SRTN算法</h3>\n\n<p>各进程到达就绪队列的时间、需要的运行时间如下表所示。使用抢占式的短作业优先调度算法计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>到达时间</th>\n      <th>运行时间</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>P1</td>\n      <td>0</td>\n      <td>7</td>\n    </tr>\n    <tr>\n      <td>P2</td>\n      <td>2</td>\n      <td>4</td>\n    </tr>\n    <tr>\n      <td>P3</td>\n      <td>4</td>\n      <td>1</td>\n    </tr>\n    <tr>\n      <td>P4</td>\n      <td>5</td>\n      <td>4</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>解答：</p>\n\n<p><strong>最短剩余时间优先算法</strong>每当有进程加入<strong>就绪队列改变时就需要调度</strong>，如果新到达的进程<strong>剩余时间</strong>比当前运行的进程剩余时间<strong>更短</strong>，则由新进程<strong>抢占处理机</strong>，当前运行进程重新回到就绪队列。\n另外，<strong>当一个进程完成时也需要调度。</strong></p>\n\n<p>需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。\n以下Pn=m表示当前Pn进程剩余时间为m。各个时刻的情况如下：</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>时刻</th>\n      <th>不同进程剩余时间</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0（P1到达）</td>\n      <td><strong>P1=7</strong></td>\n    </tr>\n    <tr>\n      <td>2（P2到达）</td>\n      <td>P1=5、<strong>P2=4</strong></td>\n    </tr>\n    <tr>\n      <td>4（P3到达）</td>\n      <td>P1=5、P2=2、<strong>P3=1</strong></td>\n    </tr>\n    <tr>\n      <td>5（P3完成、P4到达）</td>\n      <td>P1=5、<strong>P2=2</strong>、P4=4</td>\n    </tr>\n    <tr>\n      <td>7（P2完成）</td>\n      <td>P1=5、<strong>P4=4</strong></td>\n    </tr>\n    <tr>\n      <td>11（P4完成）</td>\n      <td><strong>P1=5</strong></td>\n    </tr>\n  </tbody>\n</table>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法3.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<table>\n  <thead>\n    <tr>\n      <th>进程</th>\n      <th>P1</th>\n      <th>P2</th>\n      <th>P3</th>\n      <th>P4</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>周转时间</td>\n      <td>16-0=16</td>\n      <td>7-2=5</td>\n      <td>5-4=1</td>\n      <td>11-5=6</td>\n    </tr>\n    <tr>\n      <td>带权周转时间</td>\n      <td>16/7=2.28</td>\n      <td>5/4=1.25</td>\n      <td>1/1=1</td>\n      <td>6/4=1.5</td>\n    </tr>\n    <tr>\n      <td>等待时间</td>\n      <td>16-7=9</td>\n      <td>5-4=1</td>\n      <td>1-1=0</td>\n      <td>6-4=2</td>\n    </tr>\n  </tbody>\n</table>\n\n<p>平均周转时间 = (16+5+1+6) / 4 = 7</p>\n\n<p>平均带权周转时间 = (2.28+1.25+1+1.5) / 4 = 1.50</p>\n\n<p>平均等待时间 = (9+1+0+2) / 4 = 3</p>\n\n<p>对比SJF/SPF算法，显然抢占式的这几个指标又要更低。</p>\n\n<h3 id=\"注意\">注意</h3>\n\n<p>严格来说，“SJF调度算法的平均等待时间、平均周转时间最少”这个表述是错误的，不严谨的。\n之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少；\n应该加上一个条件“在<strong>所有进程同时可运行</strong>时，采用SIF调度算法的平均等待时间、平均周转时间最少”；\n或者说“在<strong>所有进程都几乎同时到达</strong>时，采用SJF调度算法的平均等待时间、平均周转时间最少”。</p>\n\n<p>如果不加上述前提条件，则应该说“<strong>抢占式的</strong>短作业/进程优先调度算法的平均等待时间、平均周转时间最少”。</p>\n\n<p>虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，\n但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间。</p>\n\n<h2 id=\"hrrn算法\">HRRN算法</h2>\n\n<h3 id=\"关于fcfs和sjf的思考\">关于FCFS和SJF的思考</h3>\n\n<p>FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。\n但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题；</p>\n\n<p>SJF算法是选择一个执行时间最短的作业为其服务。\n但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题；</p>\n\n<p>高响应比算法既考虑到了各个作业的等待时间，也兼顾了运行时间。</p>\n\n<h3 id=\"响应比\">响应比</h3>\n\n<p><strong>响应比</strong> = （等待时间 + 要求服务时间） / 要求服务时间</p>\n\n<p>响应比兼顾了作业的等待时间和运行时间，且响应比总是≥1。</p>\n\n<h3 id=\"hrrn算法特点\">HRRN算法特点</h3>\n\n<table>\n  <thead>\n    <tr>\n      <th>算法名</th>\n      <th>高响应比优先（Highest Response Ratio Next，HRRN）</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>算法思想</td>\n      <td>要综合考虑作业/进程的等待时间和要求服务的时间</td>\n    </tr>\n    <tr>\n      <td>算法规则</td>\n      <td>在每次调度时先计算各个作业/进程的<strong>响应比</strong>，选择<strong>响应比最高</strong>的作业/进程为其服务</td>\n    </tr>\n    <tr>\n      <td>用于作业/进程调度</td>\n      <td>即可用于作业调度，也可用于进程调度。</td>\n    </tr>\n    <tr>\n      <td>是否可抢占</td>\n      <td>非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比</td>\n    </tr>\n    <tr>\n      <td>优缺点</td>\n      <td>综合考虑了等待时间和运行时间（要求服务时间）<br />等待时间相同时，要求服务时间短的优先（SJF的优点）<br />要求服务时间相同时，等待时间长的优先（FCFS的优点）<br />对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题</td>\n    </tr>\n    <tr>\n      <td>是否会导致饥饿</td>\n      <td>不会。</td>\n    </tr>\n  </tbody>\n</table>\n\n<h3 id=\"例子-2\">例子</h3>\n<p>各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。</p>\n\n<p><strong>高响应比优先算法</strong>是<strong>非抢占式</strong>的调度算法，只有当前运行的进程<strong>主动放弃CPU</strong>时（正常/异常完成，或主动阻塞），才需要进行调度。\n调度时<strong>计算所有就绪进程的响应比，选响应比最高的进程</strong>上处理机。</p>\n\n<p>以下Pn=m表示当前Pn进程的响应比为m。各个时刻的情况如下：</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>时刻</th>\n      <th>不同进程响应比</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0（P1到达）</td>\n      <td>只有P1到达就绪队列，直接选取<strong>P1</strong></td>\n    </tr>\n    <tr>\n      <td>7（P1完成）</td>\n      <td>P2=(5+4)/4=2.25、<strong>P3=(3+1)/1=4</strong>、P4=(2+4)/4=1.5</td>\n    </tr>\n    <tr>\n      <td>8（P3完成）</td>\n      <td><strong>P2=2.5</strong>、P4=1.75</td>\n    </tr>\n    <tr>\n      <td>12（P2完成）</td>\n      <td>就绪队列中只剩<strong>P4</strong></td>\n    </tr>\n  </tbody>\n</table>\n\n<p><img src=\"\\images\\posts\\操作系统-调度算法4.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>具体计算可以参考前文，这里不再给出。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81%E4%B8%80-FCFS-SJF-HRRN%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十一）FCFS、SJF、HRRN调度算法'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>3 min read <time class='article__date' datetime='2022-04-24T11:34:45+08:00'>Apr 24, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十一）FCFS、SJF、HRRN调度算法</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二十）调度算法的评价指标",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/",
      "date"     : "Apr 24, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#cpu利用率\" id=\"markdown-toc-cpu利用率\">CPU利用率</a></li>\n  <li><a href=\"#系统吞吐量\" id=\"markdown-toc-系统吞吐量\">系统吞吐量</a></li>\n  <li><a href=\"#周转时间\" id=\"markdown-toc-周转时间\">周转时间</a>    <ol>\n      <li><a href=\"#周转时间平均周转时间\" id=\"markdown-toc-周转时间平均周转时间\">周转时间、平均周转时间</a></li>\n      <li><a href=\"#带权周转时间平均带权周转时间\" id=\"markdown-toc-带权周转时间平均带权周转时间\">带权周转时间、平均带权周转时间</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#等待时间\" id=\"markdown-toc-等待时间\">等待时间</a></li>\n  <li><a href=\"#响应时间\" id=\"markdown-toc-响应时间\">响应时间</a></li>\n</ol>\n\n<h2 id=\"cpu利用率\">CPU利用率</h2>\n\n<p>由于早期的CPU造价极其昂贵，因此人们会<strong>希望让CPU尽可能多地工作</strong>。</p>\n\n<p><strong>CPU利用率</strong>：指CPU忙碌的时间占总时间的比例。</p>\n\n<p><strong>利用率</strong> = 设备忙碌时间/总时间</p>\n\n<p>Eg. 某计算机只支持单道程序，某个作业刚开始需要在CPU上运行5秒，再用打印机打印输出5秒，之后再执行5秒，才能结束。\n在此过程中，CPU利用率、打印机利用率分别是多少？</p>\n\n<p>CPU利用率：</p>\n\n\\[\\begin{equation}\n\\dfrac {5+5} {5+5+5}=66.66\\%\n\\end{equation}\\]\n\n<p>打印机利用率：</p>\n\n\\[\\begin{equation}\n\\dfrac {5} {5+5+5}=33.33\\%\n\\end{equation}\\]\n\n<p>多道程序并发执行时，通常使用<strong>甘特图</strong>进行辅助计算。</p>\n\n<h2 id=\"系统吞吐量\">系统吞吐量</h2>\n\n<p>对于计算机来说，希望能用尽可能少的时间处理完尽可能多的作业。</p>\n\n<p><strong>系统吞吐量</strong>：单位时间内完成作业的数量</p>\n\n<p>系统吞吐量 = 总共完成作业数量 / 总共花费时间</p>\n\n<p>Eg. 某计算机系统处理完10道作业，共花费100秒，则系统吞吐量为10/100=0.1道/秒</p>\n\n<h2 id=\"周转时间\">周转时间</h2>\n\n<p>对于计算机的用户来说，他很关心自己的作业从提交到完成花了多少时间。</p>\n\n<p><strong>周转时间</strong>，是<strong>指从作业被提交给系统开始，到作业完成为止的这段时间间隔</strong>。</p>\n\n<p>总共包括四个部分：</p>\n<ol>\n  <li>作业在外存后备队列上等待作业调度（高级调度）的时间；</li>\n  <li>进程在就绪队列上等待进程调度（低级调度，就绪态）的时间；</li>\n  <li>进程在CPU上执行（运行态）的时间；</li>\n  <li>进程等待I/O操作完成（阻塞态）的时间。</li>\n</ol>\n\n<p>后三项在一个作业的整个处理过程中，可能发生多次。</p>\n\n<p>（作业）<strong>周转时间</strong> = 作业完成时间 - 作业提交时间</p>\n\n<h3 id=\"周转时间平均周转时间\">周转时间、平均周转时间</h3>\n\n<p>对于用户来说，更关心自己的单个作业的周转时间；\n但对于操作系统来说，更关心系统的整体表现，因此更关心所有作业周转时间的平均值，即平均周转时间。</p>\n\n<p><strong>平均周转时间</strong> = 各作业周转时间和 / 作业数</p>\n\n<p>有的作业运行时间短，有的作业运行时间长，因此在周转时间相同的情况下，运行时间不同的作业，给用户的感觉肯定是不一样的。</p>\n\n<h3 id=\"带权周转时间平均带权周转时间\">带权周转时间、平均带权周转时间</h3>\n\n<p><strong>带权周转时间</strong> = 作业周转时间 / 作业实际运行时间 = （作业完成时间 - 作业提交时间） / 作业实际运行时间</p>\n\n<p>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。</p>\n\n<p>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</p>\n\n<p>注意：</p>\n<ul>\n  <li>带权周转时间必定 ≥ 1；</li>\n  <li>带权周转时间与周转时间都是越小越好。</li>\n</ul>\n\n<p><strong>平均带权周转时间</strong> = 各作业带权周转时间和 / 作业数</p>\n\n<h2 id=\"等待时间\">等待时间</h2>\n\n<p>计算机的用户希望自己的作业尽可能少的等待处理机。</p>\n\n<p><strong>等待时间</strong>，指进程/作业处于<strong>等待处理机状态时间之和</strong>，等待时间越长，用户满意度越低。</p>\n\n<p>作业提交后首先进入作业后备队列（在外存中），在后备队列中<strong>等待被服务（调度）</strong>。</p>\n\n<p>作业调入内存后，<strong>建立对应的进程</strong>。这个进程会被CPU服务、会被I/O设备服务，当然也会有<strong>等待被服务</strong>的时候。</p>\n\n<p>对于<strong>进程</strong>来说，等待时间就是指进程建立后<strong>等待被服务的时间之和</strong>，\n在等待I/O完成的期间其实进程也是在被服务的，所以不计入等待时间。</p>\n\n<p>对于<strong>作业</strong>来说，不仅要考虑<strong>建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间</strong>。</p>\n\n<p>一个作业总共需要被CPU服务多久，被I/O设备服务多久一般是确定不变的，因此调度算法其实只会影响作业/进程的等待时间。\n当然，与前面指标类似，也有<strong>平均等待时间</strong>来评价整体性能。</p>\n\n<h2 id=\"响应时间\">响应时间</h2>\n\n<p>对于计算机用户来说，会希望自己的提交的请求（比如通过键盘输入了一个调试命令）尽早地开始被系统服务、回应。</p>\n\n<p><strong>响应时间</strong>，指从用户<strong>提交请求</strong>到<strong>首次产生响应</strong>所用的时间。</p>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C%E5%8D%81-%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E7%9A%84%E8%AF%84%E4%BB%B7%E6%8C%87%E6%A0%87/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（二十）调度算法的评价指标'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-24T11:05:28+08:00'>Apr 24, 2022</time> </span> </div><h2 class='article__title'>操作系统（二十）调度算法的评价指标</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十九）调度器（Scheduler）和闲逛进程",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B9%9D-%E8%B0%83%E5%BA%A6%E5%99%A8-Scheduler-%E5%92%8C%E9%97%B2%E9%80%9B%E8%BF%9B%E7%A8%8B/",
      "date"     : "Apr 24, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#调度器调度程序scheduler\" id=\"markdown-toc-调度器调度程序scheduler\">调度器/调度程序（Scheduler）</a></li>\n  <li><a href=\"#闲逛进程\" id=\"markdown-toc-闲逛进程\">闲逛进程</a></li>\n</ol>\n\n<h2 id=\"调度器调度程序scheduler\">调度器/调度程序（Scheduler）</h2>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-线程的三状态模型.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>在进程的三状态模型中，②、③过程由调度程序引起，调度程序决定：</p>\n<ul>\n  <li>让谁运行?——调度算法</li>\n  <li>运行多长时间?――时间片大小</li>\n</ul>\n\n<p>什么事件会触发<strong>调度程序</strong>（进程的调度时机）：</p>\n<ul>\n  <li><strong>创建新进程</strong>；</li>\n  <li><strong>进程退出</strong>；</li>\n  <li>运行<strong>进程阻塞</strong>；</li>\n  <li><strong>I/O中断</strong>发生（可能唤醒某些阻塞进程）。</li>\n</ul>\n\n<p>非抢占式和抢占式的区别：</p>\n<ul>\n  <li>非抢占式调度策略，只有<strong>运行进程阻塞或退出</strong>才触发调度程序工作；</li>\n  <li>抢占式调度策略，每个<strong>时钟中断或k个时钟中断</strong>会触发调度程序工作。</li>\n</ul>\n\n<p>在不支持内核级线程的操作系统中，调度程序的处理对象是进程：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-调度器1.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>支持内核级线程的操作系统，调度程序的处理对象是内核线程：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-调度器2.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"闲逛进程\">闲逛进程</h2>\n\n<p>如果就绪队列中没有其他就绪进程时，调度程序会选中闲逛进程（Idle），即实际系统中，CPU不会空闲，即便不存在就绪进程，也会运行闲逛进程。</p>\n\n<p>闲逛进程的特性：</p>\n<ul>\n  <li>优先级最低</li>\n  <li>可以是0地址指令，占一个完整的指令周期（指令周期末尾例行检查中断）</li>\n  <li>能耗低</li>\n</ul>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/24/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B9%9D-%E8%B0%83%E5%BA%A6%E5%99%A8-Scheduler-%E5%92%8C%E9%97%B2%E9%80%9B%E8%BF%9B%E7%A8%8B/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十九）调度器（Scheduler）和闲逛进程'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-24T10:26:52+08:00'>Apr 24, 2022</time> </span> </div><h2 class='article__title'>操作系统（十九）调度器（Scheduler）和闲逛进程</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十八）进程调度的时机、切换与过程、方式",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E5%85%AB-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA-%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B-%E6%96%B9%E5%BC%8F/",
      "date"     : "Apr 23, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#时机\" id=\"markdown-toc-时机\">时机</a>    <ol>\n      <li><a href=\"#需要进行进程调度与切换的情况\" id=\"markdown-toc-需要进行进程调度与切换的情况\">需要进行进程调度与切换的情况</a></li>\n      <li><a href=\"#不能进行进程调度与切换的情况\" id=\"markdown-toc-不能进行进程调度与切换的情况\">不能进行进程调度与切换的情况</a></li>\n      <li><a href=\"#操作系统内核程序临界区中不能进行调度与切换\" id=\"markdown-toc-操作系统内核程序临界区中不能进行调度与切换\">操作系统内核程序临界区中不能进行调度与切换</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#方式\" id=\"markdown-toc-方式\">方式</a>    <ol>\n      <li><a href=\"#非剥夺调度方式非抢占式\" id=\"markdown-toc-非剥夺调度方式非抢占式\">非剥夺调度方式（非抢占式）</a></li>\n      <li><a href=\"#剥夺调度方式抢占式\" id=\"markdown-toc-剥夺调度方式抢占式\">剥夺调度方式（抢占式）</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#切换与过程\" id=\"markdown-toc-切换与过程\">切换与过程</a></li>\n</ol>\n\n<h2 id=\"时机\">时机</h2>\n\n<p><strong>进程调度（低级调度）</strong>，就是按照某种算法从就绪队列中选择一个进程为其分配处理机。</p>\n\n<h3 id=\"需要进行进程调度与切换的情况\">需要进行进程调度与切换的情况</h3>\n\n<p><strong>需要进行</strong>进程调度与切换的情况主要分为两种，<strong>主动放弃</strong>和<strong>被动放弃</strong>。</p>\n\n<p>当前运行的进程<strong>主动放弃</strong>处理机：</p>\n<ul>\n  <li>进程正常终止；</li>\n  <li>运行过程中发生异常而终止；</li>\n  <li>进程主动请求阻塞（如等待I/O）。</li>\n</ul>\n\n<p>当前运行的进程<strong>被动放弃</strong>处理机：</p>\n<ul>\n  <li>分给进程的时间片用完；</li>\n  <li>有更紧急的事需要处理（如I/O中断）；</li>\n  <li>有更高优先级的进程进入就绪队列。</li>\n</ul>\n\n<h3 id=\"不能进行进程调度与切换的情况\">不能进行进程调度与切换的情况</h3>\n\n<p><strong>不能进行</strong>进程调度与切换的情况：</p>\n<ul>\n  <li>在<strong>处理中断的过程中</strong>。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换；</li>\n  <li>进程在<strong>操作系统内核程序临界区</strong>中；</li>\n  <li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如修改PCB中进程状态的标识，并把PCB放到相应队列）。</li>\n</ul>\n\n<h3 id=\"操作系统内核程序临界区中不能进行调度与切换\">操作系统内核程序临界区中不能进行调度与切换</h3>\n\n<p>临界资源：一个时间段内只允许一个进程使用的资源。各进程需要<strong>互斥地</strong>访问临界资源。</p>\n\n<p>临界区：访问临界资源的那段代码。</p>\n\n<p><strong>内核程序临界区</strong>一般是用来访问某种<strong>内核数据结构</strong>的，比如进程的就绪队列（由各就绪进程的PCB组成）</p>\n\n<p>内核程序临界区访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换。</p>\n\n<p>如图，访问进程的就绪队列时，由于就绪队列被访问，操作系统不能进行调度与切换。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程调度时机1.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>普通临界区访问的临界资源不会直接影响操作系统内核的管理工作，因此在访问普通临界区时可以进行调度与切换。</p>\n\n<p>如图，在打印机打印完成之前，进程一直处于临界区内，临界资源不会解锁。但打印机又是慢速设备，此时如果一直不允许进程调度的话就会导致CPU一直空闲。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程调度时机2.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"方式\">方式</h2>\n\n<p>有的系统中，只允许进程主动放弃处理机；</p>\n\n<p>而有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机。</p>\n\n<p>因此，可以将进程调度的方式分为<strong>非剥夺调度方式</strong>和<strong>剥夺调度方式</strong>。</p>\n\n<h3 id=\"非剥夺调度方式非抢占式\">非剥夺调度方式（非抢占式）</h3>\n\n<p><strong>非剥夺调度方式，又称非抢占方式</strong>。即，只允许进程主动放弃处理机。在运行过程中即便有更紧迫的任务到达，当前进程依然会继续使用处理机，直到该进程终止或主动要求进入阻塞态。</p>\n\n<p>非剥夺调度方式实现简单，系统开销小但是无法及时处理紧急任务，适合于早期的批处理系统。</p>\n\n<h3 id=\"剥夺调度方式抢占式\">剥夺调度方式（抢占式）</h3>\n\n<p><strong>剥夺调度方式，又称抢占方式</strong>。当一个进程正在处理机上执行时，如果有一个更重要或更紧迫的进程需要使用处理机，则立即暂停正在执行的进程，将处理机分配给更重要紧迫的那个进程。</p>\n\n<p>剥夺调度方式可以优先处理更紧急的进程,也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操作系统、实时操作系统。</p>\n\n<h2 id=\"切换与过程\">切换与过程</h2>\n\n<p>狭义的进程调度和进程切换：</p>\n\n<p><strong>狭义的进程调度</strong>指的是从就绪队列中<strong>选中一个要运行的进程</strong>。\n（这个进程可以是刚刚被暂停执行的进程，也可能是<strong>另一个进程</strong>，后一种情况就需要<strong>进程切换</strong>）</p>\n\n<p><strong>进程切换</strong>是指一个进程让出处理机，由另一个进程占用处理机的过程。</p>\n\n<p><strong>广义的进程调度</strong>包含了选择一个进程和进程切换两个步骤。</p>\n\n<p>进程切换的过程主要完成了：</p>\n\n<ol>\n  <li>对原来运行进程各种数据的保存；</li>\n  <li>对新的进程各种数据的恢复。（如:程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li>\n</ol>\n\n<p>注意：<strong>进程切换是有代价的</strong>，因此如果<strong>过于频繁的</strong>进行进程<strong>调度、切换</strong>，必然会使整个<strong>系统的效率降低</strong>，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E5%85%AB-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%9A%84%E6%97%B6%E6%9C%BA-%E5%88%87%E6%8D%A2%E4%B8%8E%E8%BF%87%E7%A8%8B-%E6%96%B9%E5%BC%8F/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十八）进程调度的时机、切换与过程、方式'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-23T20:05:19+08:00'>Apr 23, 2022</time> </span> </div><h2 class='article__title'>操作系统（十八）进程调度的时机、切换与过程、方式</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十七）调度的概念和层次",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B8%83-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1/",
      "date"     : "Apr 23, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#调度的概念\" id=\"markdown-toc-调度的概念\">调度的概念</a></li>\n  <li><a href=\"#调度的三个层次\" id=\"markdown-toc-调度的三个层次\">调度的三个层次</a>    <ol>\n      <li><a href=\"#高级调度\" id=\"markdown-toc-高级调度\">高级调度</a></li>\n      <li><a href=\"#低级调度\" id=\"markdown-toc-低级调度\">低级调度</a></li>\n      <li><a href=\"#中级调度\" id=\"markdown-toc-中级调度\">中级调度</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#进程的挂起态与七状态模型\" id=\"markdown-toc-进程的挂起态与七状态模型\">进程的挂起态与七状态模型</a></li>\n  <li><a href=\"#三层调度的联系和对比\" id=\"markdown-toc-三层调度的联系和对比\">三层调度的联系和对比</a></li>\n</ol>\n\n<h2 id=\"调度的概念\">调度的概念</h2>\n<p>背景：\n在银行取款时，普通客户一般先到先服务，但VIP客户可以优先被服务；\n假设有一群人需要使用厕所，他们可以用先排队先使用的方式，也可以经过讨论后时间短的人优先使用。</p>\n\n<p>类似的，当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定<strong>某种规则</strong>来<strong>决定</strong>处理这些任务的<strong>顺序</strong>，这就是“调度”研究的问题。</p>\n\n<h2 id=\"调度的三个层次\">调度的三个层次</h2>\n\n<h3 id=\"高级调度\">高级调度</h3>\n\n<p>作业的定义：一个具体的任务</p>\n\n<p>用户向系统提交一个作业≈用户让操作系统启动一个程序（来处理一个具体的任务）</p>\n\n<p>当用户向系统提交大量作业时，有时内存空间有限，有时无法将用户提交的作业全部放入内存，此时需要采用高级调度，即作业调度的方式，决定哪些程序该优先启动。</p>\n\n<p><strong>高级调度（作业调度）</strong>：按一定的原则从外存的作业后备队列中挑选一个作业调入内存，并创建进程。<strong>每个作业只调入一次，调出一次</strong>。作业调入时会建立PCB，调出时才撤销PCB。</p>\n\n<h3 id=\"低级调度\">低级调度</h3>\n\n<p><strong>低级调度（进程调度/处理机调度）</strong>：按照某种策略从就绪队列中选取一个进程，将处理机分配给它。</p>\n\n<p>进程调度是操作系统中<strong>最基本的一种调度</strong>，在一般的操作系统中都必须配置进程调度。进程调度的<strong>频率很高</strong>，一般几十毫秒一次。</p>\n\n<h3 id=\"中级调度\">中级调度</h3>\n\n<p>在内存不够时，可将某些进程的数据调出外存。等内存空闲或者进程需要运行时再重新调入内存。</p>\n\n<p>暂时调到外存等待的进程状态为<strong>挂起状态</strong>。被挂起的进程PCB会被组织成<strong>挂起队列</strong>。</p>\n\n<p><strong>中级调度（内存调度）</strong>：按照某种策略决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此<strong>中级调度发生的频率要比高级调度更高</strong>。</p>\n\n<h2 id=\"进程的挂起态与七状态模型\">进程的挂起态与七状态模型</h2>\n\n<p>暂时调到外存等待的进程状态为<strong>挂起状态（挂起态，suspend）</strong>，挂起态又可以进一步细分为<strong>就绪挂起</strong>、<strong>阻塞挂起</strong>两种状态。</p>\n\n<p>加入挂起态后，进程的五状态模型可以扩展到七状态模型：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-七状态模型.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>注意“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p>\n\n<p>有的操作系统会把就绪挂起、阻塞挂起分为两个挂起队列，甚至会根据阻塞原因不同再把阻塞挂起进程进一步细分为多个队列。</p>\n\n<h2 id=\"三层调度的联系和对比\">三层调度的联系和对比</h2>\n\n<table>\n  <thead>\n    <tr>\n      <th> </th>\n      <th>行为</th>\n      <th>调度位置</th>\n      <th>频率</th>\n      <th>对进程状态的影响</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>高级调度（作业调度）</td>\n      <td>按照某种规则，从后备队列中选择合适的作业将其调入内存，并为其创建进程</td>\n      <td>外存→内存（面向作业）</td>\n      <td>最低</td>\n      <td>无→创建态→就绪态</td>\n    </tr>\n    <tr>\n      <td>中级调度（内存调度）</td>\n      <td>按照某种规则，从挂起队列中选择合适的进程将其数据调回内存</td>\n      <td>外存→内存（面向进程）</td>\n      <td>中等</td>\n      <td>挂起态→就绪态（阻塞挂起→阻塞态）</td>\n    </tr>\n    <tr>\n      <td>低级调度（进程调度）</td>\n      <td>按照某种规则，从就绪队列中选择一个进程为其分配处理机</td>\n      <td>内存→CPU</td>\n      <td>最高</td>\n      <td>就绪态→运行态</td>\n    </tr>\n  </tbody>\n</table>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B8%83-%E8%B0%83%E5%BA%A6%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%B1%82%E6%AC%A1/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十七）调度的概念和层次'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-23T17:38:13+08:00'>Apr 23, 2022</time> </span> </div><h2 class='article__title'>操作系统（十七）调度的概念和层次</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十六）线程的状态与转换",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E5%85%AD-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/",
      "date"     : "Apr 23, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#线程的三状态模型\" id=\"markdown-toc-线程的三状态模型\">线程的三状态模型</a></li>\n  <li><a href=\"#线程的组织与控制\" id=\"markdown-toc-线程的组织与控制\">线程的组织与控制</a></li>\n</ol>\n\n<h2 id=\"线程的三状态模型\">线程的三状态模型</h2>\n\n<p>让线程在各种状态间来回切换叫做<strong>线程控制</strong>，线程的状态与转换和进程的状态与转换几乎一样，通常只关心<strong>线程的就绪、运行和阻塞态</strong>，即线程的三状态模型。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-线程的三状态模型.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"线程的组织与控制\">线程的组织与控制</h2>\n\n<p>与进程类似，操作系统使用<strong>线程控制块（TCB）</strong>和<strong>线程表（Thread table）</strong>完成线程的组织与控制</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-线程控制块.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>线程控制块：</p>\n<ul>\n  <li>线程标识符：TID，与PID类似</li>\n  <li>程序计数器PC：线程执行到哪里（指向下一条指令地址）</li>\n  <li>其他寄存器：线程运行的中间结果</li>\n  <li>堆栈指针：堆栈保存函数调用信息、局部变量等</li>\n  <li>线程运行状态：运行/就绪/阻塞</li>\n  <li>优先级：线程调度、资源分配的参考</li>\n</ul>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-线程表.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>线程表：\n可以在操作系统每个进程中设置一张线程表或以系统当前所有线程组成一张线程表，把各个TCB组织起来，分类管理，这叫<strong>线程组织</strong>。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E5%85%AD-%E7%BA%BF%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81%E4%B8%8E%E8%BD%AC%E6%8D%A2/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十六）线程的状态与转换'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-23T10:05:43+08:00'>Apr 23, 2022</time> </span> </div><h2 class='article__title'>操作系统（十六）线程的状态与转换</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十五）线程的实现方式和多线程模型",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%BA%94-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/",
      "date"     : "Apr 22, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#线程的背景\" id=\"markdown-toc-线程的背景\">线程的背景</a></li>\n  <li><a href=\"#线程的实现方式\" id=\"markdown-toc-线程的实现方式\">线程的实现方式</a>    <ol>\n      <li><a href=\"#用户级线程\" id=\"markdown-toc-用户级线程\">用户级线程</a></li>\n      <li><a href=\"#内核级线程\" id=\"markdown-toc-内核级线程\">内核级线程</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#多线程模型\" id=\"markdown-toc-多线程模型\">多线程模型</a>    <ol>\n      <li><a href=\"#一对一模型\" id=\"markdown-toc-一对一模型\">一对一模型</a></li>\n      <li><a href=\"#多对一模型\" id=\"markdown-toc-多对一模型\">多对一模型</a></li>\n      <li><a href=\"#多对多模型\" id=\"markdown-toc-多对多模型\">多对多模型</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"线程的背景\">线程的背景</h2>\n\n<h2 id=\"线程的实现方式\">线程的实现方式</h2>\n\n<h3 id=\"用户级线程\">用户级线程</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-用户级线程.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<ol>\n  <li>用户级线程（User-Level Thread，ULT）由应用程序通过线程库实现，所有的<strong>线程管理工作</strong>都由<strong>应用程序负责</strong>（包括线程切换）；</li>\n  <li>用户级线程中，<strong>线程切换</strong>可以在<strong>用户态下即可完成</strong>，无需操作系统干预；</li>\n  <li>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。<strong>“用户级线程”</strong>就是<strong>“从用户视角看能看到的线程”</strong>。</li>\n</ol>\n\n<p>用户级线程的优缺点：</p>\n<ul>\n  <li>优点：用户级线程的切换在用户空间即可完成，不需要切换到内核态，线程管理的系统开销小，效率高；</li>\n  <li>缺点：当一个用户级线程被阻塞后。整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。</li>\n</ul>\n\n<h3 id=\"内核级线程\">内核级线程</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-内核级线程.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<ol>\n  <li><strong>内核级线程（Kernel-Level Thread，KLT）的管理工作</strong>由<strong>操作系统内核</strong>完成；</li>\n  <li>线程调度、切换等工作都由内核负责，因此<strong>内核级线程的切换</strong>必然需要在<strong>内核态</strong>下才能完成；</li>\n  <li>操作系统会为每个内核级线程建立相应的TCB (Thread Control Block，线程控制块)，通过TCB对线程进行管理。<strong>“内核级线程”</strong>就是<strong>“从操作系统内核视角看能看到的线程”</strong>。</li>\n</ol>\n\n<p>内核级线程的优缺点：</p>\n<ul>\n  <li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行；</li>\n  <li>缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</li>\n</ul>\n\n<h2 id=\"多线程模型\">多线程模型</h2>\n\n<p>在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型。</p>\n\n<h3 id=\"一对一模型\">一对一模型</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-一对一模型.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>一对一模型：一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程。</p>\n<ul>\n  <li>优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</li>\n  <li>缺点：一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成，需要切换到内核态，因此线程管理的成本高，开销大。</li>\n</ul>\n\n<h3 id=\"多对一模型\">多对一模型</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-多对一模型.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>多对一模型：多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程。</p>\n<ul>\n  <li>优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</li>\n  <li>缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</li>\n  <li>注意：操作系统只“看得见”内核级线程，因此只有<strong>内核级线程才是处理机分配的单位</strong>。</li>\n</ul>\n\n<h3 id=\"多对多模型\">多对多模型</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-多对多模型.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>多对多模型：<strong>n用户及线程映射到m个内核级线程（n&gt;=m）</strong>。每个用户进程对应m个内核级线程。</p>\n\n<p>克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>\n\n<p>可以这么理解：用户级线程是“代码逻辑”的载体；内核级线程是“运行机会”的载体。<strong>内核级线程才是处理机分配的单位</strong>，多核CPU环境下，上图这个进程最多能被分配两个核。\n一段“代码逻辑”只有获得了“运行机会”才能被CPU执行。\n内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%BA%94-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E5%92%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十五）线程的实现方式和多线程模型'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-22T02:46:02+08:00'>Apr 22, 2022</time> </span> </div><h2 class='article__title'>操作系统（十五）线程的实现方式和多线程模型</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十四）线程的概念",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E5%9B%9B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/",
      "date"     : "Apr 22, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#为什么要引入线程\" id=\"markdown-toc-为什么要引入线程\">为什么要引入线程？</a></li>\n  <li><a href=\"#引入线程后带来的变化\" id=\"markdown-toc-引入线程后带来的变化\">引入线程后带来的变化</a></li>\n  <li><a href=\"#线程的属性\" id=\"markdown-toc-线程的属性\">线程的属性</a></li>\n</ol>\n\n<h2 id=\"为什么要引入线程\">为什么要引入线程？</h2>\n\n<p>在一个程序运行过程中，可能需要同时进行视频聊天、传输文件等多种功能，而进程是程序的一次执行，这些功能显然不能通过一个程序顺序处理就能实现。</p>\n\n<p>有的进程可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-线程概念.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>传统的进程是程序执行流的最小单位；引入线程后，线程成为程序执行流的最小单位。</p>\n\n<p>可以把线程理解为“轻量级进程”。</p>\n\n<p><strong>线程</strong>是一个<strong>基本的CPU执行单元</strong>，也是<strong>程序执行流的最小单位</strong>。\n引入线程之后，不仅是进程之间可以并发，进程内的<strong>各线程之间也可以并发</strong>，从而进一步<strong>提升了系统的并发度</strong>，使得一个进程内也可以并发处理各种任务（如QQ视频、文字聊天、传文件）。</p>\n\n<p>引入线程后，<strong>进程</strong>只作为<strong>除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的）。</p>\n\n<h2 id=\"引入线程后带来的变化\">引入线程后带来的变化</h2>\n\n<p>资源分配、调度：</p>\n<ul>\n  <li>传统进程机制中，进程是资源分配、调度的基本单位；</li>\n  <li>引入线程后，进程是资源分配的基本单位，线程是调度的基本单位。</li>\n</ul>\n\n<p>并发性：</p>\n<ul>\n  <li>传统进程机制中，只能进程间并发；</li>\n  <li>引入线程后，各线程间也能并发，提升了并发度。</li>\n</ul>\n\n<p>系统开销：</p>\n<ul>\n  <li>传统的进程间并发，需要切换进程的运行环境，系统开销很大；</li>\n  <li>线程间并发，如果是同一进程内的线程切换，则不需要切换进程环境，系统开销小；</li>\n  <li>引入线程后，并发所带来的系统开销减小。</li>\n</ul>\n\n<h2 id=\"线程的属性\">线程的属性</h2>\n\n<ol>\n  <li>线程是处理机调度的单位；</li>\n  <li>多CPU计算机中，各个线程可占用不同的CPU；</li>\n  <li>每个线程都有一个线程ID、线程控制块（TCB）；</li>\n  <li>线程也有就绪、阻塞、运行三种基本状态；</li>\n  <li>线程几乎不拥有系统资源；</li>\n  <li>同一进程的不同线程间共享进程的资源；</li>\n  <li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预；</li>\n  <li>同一进程中的线程切换，不会引起进程切换；</li>\n  <li>不同进程中的线程切换，会引起进程切换；</li>\n  <li>切换同进程内的线程，系统开销很小；</li>\n  <li>切换进程，系统开销较大。</li>\n</ol>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E5%9B%9B-%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十四）线程的概念'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-22T02:24:51+08:00'>Apr 22, 2022</time> </span> </div><h2 class='article__title'>操作系统（十四）线程的概念</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十三）进程通信",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B8%89-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/",
      "date"     : "Apr 21, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#为什么进程通信需要操作系统支持\" id=\"markdown-toc-为什么进程通信需要操作系统支持\">为什么进程通信需要操作系统支持?</a></li>\n  <li><a href=\"#共享存储\" id=\"markdown-toc-共享存储\">共享存储</a></li>\n  <li><a href=\"#消息传递\" id=\"markdown-toc-消息传递\">消息传递</a>    <ol>\n      <li><a href=\"#直接通信方式\" id=\"markdown-toc-直接通信方式\">直接通信方式</a></li>\n      <li><a href=\"#间接通信方式\" id=\"markdown-toc-间接通信方式\">间接通信方式</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#管道通信\" id=\"markdown-toc-管道通信\">管道通信</a></li>\n</ol>\n\n<h2 id=\"为什么进程通信需要操作系统支持\">为什么进程通信需要操作系统支持?</h2>\n\n<p>进程间通信（Inter-Process Communication，<strong>IPC</strong>）是指两个进程之间产生数据交互。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程间通信.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程</strong>拥有的<strong>内存地址空间相互独立</strong>。</p>\n\n<p>为了保证安全，<strong>一个进程不能直接访问另一个进程的地址空间</strong>。</p>\n\n<p>进程通信的方式主要有共享存储、消息传递和管道通信。</p>\n\n<h2 id=\"共享存储\">共享存储</h2>\n\n<p>操作系统在内存中开辟一块<strong>共享空间</strong>，允许通信进程<strong>互斥访问</strong>。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-共享存储.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>为避免出错，各个进程对共享空间的<strong>访问</strong>应该是<strong>互斥</strong>的。</p>\n\n<p>各个进程可使用操作系统内核提供的同步互斥工具（如P、V操作）。</p>\n\n<p>注：通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中。</p>\n\n<p>Linux中如何实现共享内存：</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">shm_open</span><span class=\"p\">()</span> <span class=\"p\">;</span> <span class=\"c1\">// 通过shm_open系统调用，申请一片共享内存区</span>\n<span class=\"kt\">void</span> <span class=\"o\">*</span> <span class=\"nf\">mmap</span><span class=\"p\">();</span> <span class=\"c1\">//通过mmap系统调用，将共享内存区映射到进程自己的地址空间</span>\n</code></pre></div></div>\n\n<p>共享存储包括基于数据结构的共享和基于存储区的共享：</p>\n\n<p><strong>基于数据结构</strong>的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种<strong>低级通信</strong>方式。</p>\n\n<p><strong>基于存储区</strong>的共享:操作系统在内存中划出块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种<strong>高级通信</strong>方式。</p>\n\n<h2 id=\"消息传递\">消息传递</h2>\n\n<p>进程间的数据交换以<strong>格式化的消息（Message）</strong>为单位。进程通过操作系统提供的“发送消息/接收消息”两个<strong>原语</strong>进行数据交换。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-消息传递.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>消息传递包括直接通信方式和间接通信方式。</p>\n\n<h3 id=\"直接通信方式\">直接通信方式</h3>\n\n<p>直接通信方式指的是消息发送进程要指明接收进程ID的通信方式。</p>\n\n<p>假设存在两个进程P和Q，在进程P运行过程中，进程P的地址空间存放有一条消息<code class=\"language-plaintext highlighter-rouge\">msg</code>需要发送给进程Q，我们通过描述两个进程的直接通信来展示直接通信方式的过程。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-直接通信.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<ol>\n  <li>首先，在操作系统内核的地址空间中存放着进程Q的PCB，而<strong>进程Q的PCB</strong>中存放着<strong>进程Q的消息队列</strong>；</li>\n  <li>进程P使用发送原语<code class=\"language-plaintext highlighter-rouge\">send(Q, msg);</code>，操作系统将消息<code class=\"language-plaintext highlighter-rouge\">msg</code><strong>添加到进程Q的PCB的消息队列</strong>中去；</li>\n  <li>进程Q在运行中执行了接收原语<code class=\"language-plaintext highlighter-rouge\">receive(P,&amp;msg);</code>，操作系统检查进程Q的PCB的消息队列，查看哪条消息是由进程P发来的，并把这条消息<code class=\"language-plaintext highlighter-rouge\">msg</code>移动到进程Q的地址空间。</li>\n</ol>\n\n<h3 id=\"间接通信方式\">间接通信方式</h3>\n\n<p>间接通信方式是以“信箱”作为中间实体进行消息传递，又称信箱通信方式。</p>\n\n<p>同样以上述场景为例子，我们通过描述两个进程的间接通信来展示间接通信方式的过程。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-间接通信.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<ol>\n  <li>首先，在操作系统内核的地址空间中存放着<strong>数个信箱</strong>；</li>\n  <li>进程P使用发送原语<code class=\"language-plaintext highlighter-rouge\">send(A, msg);</code>，操作系统将消息<code class=\"language-plaintext highlighter-rouge\">msg</code><strong>添加到操作系统内核的地址空间的信箱A</strong>中去；</li>\n  <li>进程Q在运行中执行了接收原语<code class=\"language-plaintext highlighter-rouge\">receive(A,&amp;msg);</code>，操作系统从信箱A中获取消息<code class=\"language-plaintext highlighter-rouge\">msg</code>移动到进程Q的地址空间。</li>\n</ol>\n\n<p>这个过程中，可以多个进程往同一个信箱send消息，也可以多个进程从同一个信箱中receive消息。</p>\n\n<h2 id=\"管道通信\">管道通信</h2>\n\n<p>“管道”是一个特殊的共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的内存缓冲区。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-管道通信.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<ol>\n  <li>管道只能采用<strong>半双工通信</strong>，某一时间段内只能实现单向的传输。如果要实现<strong>双向同时通信</strong>，则<strong>需要设置两个管道</strong>。</li>\n  <li>各进程互斥地访问管道（由操作系统实现）</li>\n  <li>当<strong>管道写满</strong>时，<strong>写进程</strong>将<strong>阻塞</strong>，直到读进程将管道中的数据取走，即可唤醒写进程。</li>\n  <li>当<strong>管道读空</strong>时，<strong>读进程</strong>将<strong>阻塞</strong>，直到写进程往管道中写入数据，即可唤醒读进程。</li>\n  <li>管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。通常的解决方案是<strong>一个管道允许多个写进程，一个读进程</strong>，但在Linux中允许进程轮流从管道中读取数据，即<strong>允许有多个写进程，多个读进程。</strong></li>\n</ol>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B8%89-%E8%BF%9B%E7%A8%8B%E9%80%9A%E4%BF%A1/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十三）进程通信'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-21T23:59:35+08:00'>Apr 21, 2022</time> </span> </div><h2 class='article__title'>操作系统（十三）进程通信</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十二）进程控制",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/",
      "date"     : "Apr 21, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#原语\" id=\"markdown-toc-原语\">原语</a>    <ol>\n      <li><a href=\"#为何进程控制状态转换的过程要一气呵成\" id=\"markdown-toc-为何进程控制状态转换的过程要一气呵成\">为何进程控制（状态转换）的过程要“一气呵成”？</a></li>\n      <li><a href=\"#原语执行原理\" id=\"markdown-toc-原语执行原理\">原语执行原理</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#进程控制原语\" id=\"markdown-toc-进程控制原语\">进程控制原语</a>    <ol>\n      <li><a href=\"#进程的创建\" id=\"markdown-toc-进程的创建\">进程的创建</a></li>\n      <li><a href=\"#进程的终止\" id=\"markdown-toc-进程的终止\">进程的终止</a></li>\n      <li><a href=\"#进程的阻塞和唤醒\" id=\"markdown-toc-进程的阻塞和唤醒\">进程的阻塞和唤醒</a></li>\n      <li><a href=\"#进程的切换\" id=\"markdown-toc-进程的切换\">进程的切换</a></li>\n      <li><a href=\"#运行环境信息\" id=\"markdown-toc-运行环境信息\">运行环境信息</a></li>\n    </ol>\n  </li>\n</ol>\n\n<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p>\n\n<p>简化理解：进程控制就是要实现进程状态转换。</p>\n\n<h2 id=\"原语\">原语</h2>\n\n<h3 id=\"为何进程控制状态转换的过程要一气呵成\">为何进程控制（状态转换）的过程要“一气呵成”？</h3>\n\n<p>假设此时进程2等待的事件发生，则操作系统中，负责进程控制的内核程序至少需要做这样两件事：</p>\n<ol>\n  <li>将PCB2的state设为1</li>\n  <li>将PCB2从阻塞队列放到就绪队列</li>\n</ol>\n\n<p>完成了第一步后收到中断信号，那么PCB2的state=1，但是它却被放在阻塞队列里。</p>\n\n<p>如果不能“一气呵成”，就有可能导致操作系统中的某些关键数据结构信息不统一的情况，这会影响操作系统进行别的管理工作。</p>\n\n<h3 id=\"原语执行原理\">原语执行原理</h3>\n\n<p><strong>原语</strong>的执行具有<strong>原子性</strong>，即执行过程只能一气呵成，期间<strong>不允许被中断</strong>。\n可以用“<strong>关中断</strong>指令”和“<strong>开中断</strong>指令”这两个<strong>特权指令</strong>实现原子性。</p>\n\n<p>在正常情况下，CPU<strong>每执行完一条指令</strong>都会例行<strong>检查是否有中断信号</strong>需要处理，\n如果有，则暂停运行当前这段程序，转而执行相应的中断处理程序。</p>\n\n<p>CPU执行了<strong>关中断指令</strong>之后，就不再例行检查中断信号，直到执行<strong>开中断指令</strong>之后才会恢复检查。</p>\n\n<p>这样，关中断、开中断之间的这些指令序列就是不可被中断的，这就实现了“原子性”。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-原语.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"进程控制原语\">进程控制原语</h2>\n\n<p>无论哪个进程控制原语，要做的无非三类事情：</p>\n<ol>\n  <li>更新PCB中的信息（修改进程状态state，保存/恢复运行环境）；</li>\n  <li>将PCB插入合适的队列；</li>\n  <li>分配/回收资源。</li>\n</ol>\n\n<h3 id=\"进程的创建\">进程的创建</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程的创建.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h3 id=\"进程的终止\">进程的终止</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程的终止.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h3 id=\"进程的阻塞和唤醒\">进程的阻塞和唤醒</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程的阻塞和唤醒.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>注意：阻塞和唤醒原语必须成对使用。</p>\n\n<h3 id=\"进程的切换\">进程的切换</h3>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程的切换.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h3 id=\"运行环境信息\">运行环境信息</h3>\n\n<p>在执行程序指令的过程中，CPU中会设置很多“寄存器”，用来存放程序运行过程中所需的某些数据，如：</p>\n<ul>\n  <li>PSW：程序状态字寄存器</li>\n  <li>PC：程序计数器，存放下一条指令地址</li>\n  <li>IR：指令寄存器，存放当前正在执行的指令</li>\n  <li>通用寄存器：存放其它一些必要信息</li>\n</ul>\n\n<p>在指令顺序执行的过程中，很多中间结果是放在各种寄存器中的。如执行如下代码时：</p>\n\n<div class=\"language-c highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"cm\">/* ... */</span>\n<span class=\"kt\">int</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"n\">x</span><span class=\"o\">++</span><span class=\"p\">;</span>\n<span class=\"cm\">/* ... */</span>\n</code></pre></div></div>\n\n<p>此时该进程在内存中结构如图：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-运行环境信息.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>当执行到指令3时，CPU寄存器中的数据如下：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-运行环境信息-寄存器.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>执行完指令3后，另一个进程开始上CPU运行。由于另一个进程在运行过程中也会使用各个寄存器，CPU寄存器数据将被覆盖。</p>\n\n<p>为了解决这个问题，在进程切换时先<strong>在PCB中保存这个进程的运行环境</strong>（保存一些必要的寄存器信息），当原来的进程再次投入运行时，可以<strong>通过PCB恢复它的运行环境</strong>。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%BA%8C-%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十二）进程控制'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-21T17:48:42+08:00'>Apr 21, 2022</time> </span> </div><h2 class='article__title'>操作系统（十二）进程控制</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十一）进程的状态、转换和组织方式",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B8%80-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81-%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/",
      "date"     : "Apr 21, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#进程的状态\" id=\"markdown-toc-进程的状态\">进程的状态</a>    <ol>\n      <li><a href=\"#创建态及就绪态\" id=\"markdown-toc-创建态及就绪态\">创建态及就绪态</a></li>\n      <li><a href=\"#运行态\" id=\"markdown-toc-运行态\">运行态</a></li>\n      <li><a href=\"#阻塞态\" id=\"markdown-toc-阻塞态\">阻塞态</a></li>\n      <li><a href=\"#终止态\" id=\"markdown-toc-终止态\">终止态</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#进程的状态转换\" id=\"markdown-toc-进程的状态转换\">进程的状态转换</a></li>\n  <li><a href=\"#进程的组织方式\" id=\"markdown-toc-进程的组织方式\">进程的组织方式</a>    <ol>\n      <li><a href=\"#链接方式\" id=\"markdown-toc-链接方式\">链接方式</a></li>\n      <li><a href=\"#索引方式\" id=\"markdown-toc-索引方式\">索引方式</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"进程的状态\">进程的状态</h2>\n\n<p>进程的状态分为运行、就绪、阻塞、创建和终止五种，其中<strong>运行、就绪和阻塞</strong>三种状态为<strong>进程的基本状态</strong>。</p>\n\n<p>进程的整个生命周期中，大部分时间都处于三种基本状态。</p>\n\n<p>单CPU情况下，同一时刻只会有一个进程处于运行态，多核CPU情况下，可能有多个进程处于运行态。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程状态.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h3 id=\"创建态及就绪态\">创建态及就绪态</h3>\n\n<p>进程正在被创建时，它的状态是“创建态”，在这个阶段操作系统会为进程分配资源、初始化PCB；</p>\n\n<p>当进程创建完成后，便进入“就绪态”；</p>\n\n<p>处于<strong>就绪态</strong>的进程已经<strong>具备运行条件</strong>，但由于<strong>没有空闲CPU</strong>，就暂时不能运行。</p>\n\n<h3 id=\"运行态\">运行态</h3>\n\n<p>系统中可能会有很多个进程都处于就绪态；</p>\n\n<p>当CPU空闲时，操作系统就会选择一个就绪进程让它上处理机运行。</p>\n\n<p>如果<strong>一个进程此时在CPU上运行</strong>，那么这个进程处于“<strong>运行态</strong>”。CPU会执行该进程对应的程序（执行指令序列）。</p>\n\n<h3 id=\"阻塞态\">阻塞态</h3>\n\n<p>在进程运行的过程中，可能会请求<strong>等待某个事件的发生（如等待某种系统资源的分配，或者等待其他进程的响应）</strong>。</p>\n\n<p>在这个事件发生之前，进程无法继续往下执行，此时<strong>操作系统会让这个进程下CPU</strong>，并让它进入“<strong>阻塞态</strong>”。</p>\n\n<p>当CPU空闲时，又会选择另一个“就绪态”进程上CPU运行。</p>\n\n<p>此后，若资源成功分配给阻塞进程，即阻塞进程所等待的事件已经发生，此时操作系统将进程转变为就绪态。</p>\n\n<h3 id=\"终止态\">终止态</h3>\n\n<p>一个进程可以执行exit系统调用，请求操作系统终止该进程。\n此时该进程会进入“终止态”，操作系统会让该进程下CPU，并回收内存空间等资源，最后还要回收该进程的PCB。</p>\n\n<p>当终止进程的工作完成之后，这个进程就彻底消失了。</p>\n\n<h2 id=\"进程的状态转换\">进程的状态转换</h2>\n\n<p>进程状态转换过程可以用进程五状态模型进行表示：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程状态转换图.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>注意：</p>\n<ul>\n  <li>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</li>\n  <li>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong>。</li>\n  <li><strong>不能由阻塞态直接转换为运行态，也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）。</li>\n</ul>\n\n<h2 id=\"进程的组织方式\">进程的组织方式</h2>\n\n<p>进程PCB中，会有一个变量state来表示进程的当前状态。如：1表示创建态、2表示就绪态、3表示运行态…\n为了对同一个状态下的各个进程进行统一的管理，操作系统会将各个进程的PCB组织起来。</p>\n\n<h3 id=\"链接方式\">链接方式</h3>\n<p>在链接方式中，操作系统按照进程状态将PCB分为<strong>多个队列</strong>；操作系统持有<strong>指向各个队列的指针</strong>。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-链接方式.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h3 id=\"索引方式\">索引方式</h3>\n<p>在索引方式中，操作系统根据进程状态的不同，建立<strong>几张索引表</strong>；操作系统持有<strong>指向各个索引表的指针</strong>。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-索引方式.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81%E4%B8%80-%E8%BF%9B%E7%A8%8B%E7%9A%84%E7%8A%B6%E6%80%81-%E8%BD%AC%E6%8D%A2%E5%92%8C%E7%BB%84%E7%BB%87%E6%96%B9%E5%BC%8F/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十一）进程的状态、转换和组织方式'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-21T16:38:00+08:00'>Apr 21, 2022</time> </span> </div><h2 class='article__title'>操作系统（十一）进程的状态、转换和组织方式</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（十）进程的概念、组成和特征",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90%E5%92%8C%E7%89%B9%E5%BE%81/",
      "date"     : "Apr 21, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#理解进程和程序的区别\" id=\"markdown-toc-理解进程和程序的区别\">理解“进程”和“程序”的区别</a></li>\n  <li><a href=\"#一个进程实体由哪些部分组成\" id=\"markdown-toc-一个进程实体由哪些部分组成\">一个进程实体由哪些部分组成</a>    <ol>\n      <li><a href=\"#进程控制块pcb\" id=\"markdown-toc-进程控制块pcb\">进程控制块（PCB）</a></li>\n      <li><a href=\"#进程实体的组成\" id=\"markdown-toc-进程实体的组成\">进程实体的组成</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#进程有哪些重要的特征\" id=\"markdown-toc-进程有哪些重要的特征\">进程有哪些重要的特征</a></li>\n</ol>\n\n<h2 id=\"理解进程和程序的区别\">理解“进程”和“程序”的区别</h2>\n\n<p>程序：是<strong>静态的</strong>，就是个存放在磁盘里的可执行文件，就是一系列的指令集合。</p>\n\n<p>进程（Process）：是<strong>动态的</strong>，是程序的一次执行过程（同一个程序多次执行会对应多个进程）。</p>\n\n<h2 id=\"一个进程实体由哪些部分组成\">一个进程实体由哪些部分组成</h2>\n\n<h3 id=\"进程控制块pcb\">进程控制块（PCB）</h3>\n\n<p>当进程被创建时，操作系统会为该进程分配一个<strong>唯一的、不重复的</strong>“身份证号”——进程ID（Process ID，<strong>PID</strong>）。</p>\n\n<p>操作系统要记录PID、进程所属用户ID（UID）等基本的进程描述信息，以让操作系统区分各个进程。</p>\n\n<p>还要记录给进程分配了哪些资源（如分配了多少内存、正在使用哪些I/O设备、正在使用哪些文件），用于实现操作系统对资源的管理。</p>\n\n<p>还要记录进程的运行情况（如CPU使用时间、磁盘使用情况、网络流量使用情况等），用于实现操作系统对进程的控制、调度。</p>\n\n<p>这些信息都被保存在一个数据结构<strong>PCB（Process Control Block）</strong>中，即<strong>进程控制块</strong>。PCB是进程存在的唯一标志，当进程被创建时，操作系统为其创建PCB，当进程结束时，会回收其PCB。</p>\n\n<p>操作系统需要对各个并发运行的进程进行管理，<strong>但凡管理时所需要的信息，都会被放在PCB中。</strong></p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程控制块.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h3 id=\"进程实体的组成\">进程实体的组成</h3>\n\n<p>在进程的组成部分中，PCB是给操作系统用的。程序段、数据段是给进程自己用的。PCB、程序段及数据段在内存中的位置如下图：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程组成.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:80%;\" /></p>\n\n<p>一个<strong>进程实体（进程映像）</strong>由<strong>PCB、程序段、数据段</strong>组成。<strong>进程</strong>是<strong>动态</strong>的，<strong>进程实体（进程映像）</strong>是<strong>静态</strong>的，类似于进程的一个快照。</p>\n\n<p>进程实体反映了进程在某一时刻的状态（如x++后，x=2）。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-进程-进程实体.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<ul>\n  <li>PCB是给操作系统使用的；</li>\n  <li>程序段、数据段是给进程自己用的，与进程自身的运行逻辑有关。</li>\n</ul>\n\n<p><strong>程序段、数据段、PCB</strong>三部分组成了<strong>进程实体（进程映像）</strong>。</p>\n\n<p>引入进程实体的概念后，可把进程定义为：\n<strong>进程</strong>是进程实体的<strong>运行过程</strong>，是系统进行<strong>资源分配和调度</strong>的一个独立单位。</p>\n\n<p>注意：PCB是进程存在的唯一标志。</p>\n\n<h2 id=\"进程有哪些重要的特征\">进程有哪些重要的特征</h2>\n\n<p>程序是静态的，进程是动态的，相比于程序，进程拥有以下特征：</p>\n\n<ol>\n  <li><strong>动态性</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的；</li>\n  <li>并发性：内存中有多个进程实体，各进程可并发执行；</li>\n  <li>独立性：进程是能独立运行、独立获得资源、独立接受调度的基本单位；</li>\n  <li>异步性：各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制”来解决异步问题；</li>\n  <li>结构性：每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成。</li>\n</ol>\n\n<p>其中，<strong>动态性是进程最基本的特征</strong>，异步性会导致并发程序执行结果的不确定性。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/21/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%8D%81-%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%A6%82%E5%BF%B5-%E7%BB%84%E6%88%90%E5%92%8C%E7%89%B9%E5%BE%81/'> <img src='/images/covers/操作系统-cover2.png' alt='操作系统（十）进程的概念、组成和特征'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-21T03:22:32+08:00'>Apr 21, 2022</time> </span> </div><h2 class='article__title'>操作系统（十）进程的概念、组成和特征</h2> <p class='article__excerpt'>进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（九）虚拟机",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B9%9D-%E8%99%9A%E6%8B%9F%E6%9C%BA/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#虚拟机的定义\" id=\"markdown-toc-虚拟机的定义\">虚拟机的定义</a></li>\n  <li><a href=\"#第一类虚拟机\" id=\"markdown-toc-第一类虚拟机\">第一类虚拟机</a></li>\n  <li><a href=\"#第二类虚拟机\" id=\"markdown-toc-第二类虚拟机\">第二类虚拟机</a></li>\n  <li><a href=\"#两类虚拟机的对比\" id=\"markdown-toc-两类虚拟机的对比\">两类虚拟机的对比</a></li>\n  <li><a href=\"#更多指令等级\" id=\"markdown-toc-更多指令等级\">更多指令等级</a></li>\n</ol>\n\n<h2 id=\"虚拟机的定义\">虚拟机的定义</h2>\n\n<p>在同一台操作系统上并发运行某些进程，可能存在安全隐患；如果将其运行在不同硬件上，则会浪费大量硬件资源。</p>\n\n<p>虚拟机：使用虚拟化技术，将一台物理机器虚拟化为多台虚拟机器（Virtual Machine，VM），每个虚拟机器都可以独立运行一个操作系统。</p>\n\n<p>同义术语：虚拟机管理程序/虚拟机监控程序/Virtual Machine Monitor/Hypervisor</p>\n\n<h2 id=\"第一类虚拟机\">第一类虚拟机</h2>\n<p>第一类虚拟机管理程序直接运行在硬件上。虚拟机管理程序将一个物理机器虚拟化为多台虚拟机器。\n第一类虚拟机管理程序会把一个总的硬件资源划分为多个部分，每一台虚拟机上可以安装各自的操作系统，如下图所示：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-第一类虚拟机.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>在运行过程中，CPU的时间片被分给若干个虚拟机器，在上层操作系统看来自己分配的是独立的CPU；而磁盘和内存这些则是按空间进行划分。每台机器都拥有自己独立的资源。</p>\n\n<p>在第一类虚拟机中，<strong>只有虚拟机管理程序是运行在内核态</strong>的，可以使用那些最高特权的指令。\n上层<strong>虚拟内核空间运行在用户态</strong>，但它以为自己运行在内核态，会执行特权指令，此时这个<strong>特权指令会被虚拟机管理程序截获并进行等价转换</strong>。</p>\n\n<h2 id=\"第二类虚拟机\">第二类虚拟机</h2>\n<p>第二类虚拟机管理程序运行在宿主操作系统（Host OS）上。</p>\n\n<p>常用第二类虚拟机：VirtualBox、VMWare</p>\n\n<p>第二类虚拟机想要为虚拟机器分配硬件资源时，需要请求操作系统为其分配。<strong>硬件资源的管理者依旧是宿主操作系统</strong>。</p>\n\n<p>注意：在第二类虚拟机中，<strong>部分虚拟机管理程序运行在内核态</strong>，这部分是<strong>以虚拟机驱动程序的方式加载到操作系统内核</strong>当中的。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-第二类虚拟机.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"两类虚拟机的对比\">两类虚拟机的对比</h2>\n\n<table>\n  <thead>\n    <tr>\n      <th> </th>\n      <th>第一类VMM</th>\n      <th>第二类VMM</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>对物理资源的控制权</td>\n      <td>直接运行在硬件之上，能直接控制和分配物理资源。</td>\n      <td>运行在Host OS之上，依赖于Host OS为其分配物理资源。</td>\n    </tr>\n    <tr>\n      <td>资源分配方式</td>\n      <td>在安装Guest OS时，VMM要在原本的硬盘上自行分配存储空间，类似于”外核“的分配方式，分配未经抽象的物理硬件。</td>\n      <td>Guest OS拥有自己的虚拟磁盘，该盘实际上是Host OS文件系统中的一个大文件。Guest OS分配到的内存是虚拟内存。</td>\n    </tr>\n    <tr>\n      <td>性能</td>\n      <td>性能较好。</td>\n      <td>性能更差，需要Host OS作为”中介“。</td>\n    </tr>\n    <tr>\n      <td>可支持的虚拟机数量</td>\n      <td>更多，不需要和Host OS竞争资源，相同的硬件资源可以支持更多的虚拟机。</td>\n      <td>更少，Host OS本身需要使用物理资源，Host OS上运行的其他进程也需要物理资源。</td>\n    </tr>\n    <tr>\n      <td>虚拟机的可迁移性</td>\n      <td>更差。</td>\n      <td>更好，只需导出虚拟机镜像文件即可迁移到另一台Host OS 上，商业化应用更广泛。</td>\n    </tr>\n    <tr>\n      <td>运行模式</td>\n      <td>第一类VMM运行在最高特权级（Ring 0），可以执行最高特权的指令。</td>\n      <td>第二类VMM部分运行在用户态、部分运行在内核态。Guest OS发出的系统调用会被VMM截获，并转化为VMM对Host OS的系统调用。</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"更多指令等级\">更多指令等级</h2>\n<p>支持虚拟化的CPU通常分为更多的指令等级，如下图所示：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-虚拟化CPU指令等级.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>其中，Ring 0表示最高特权级指令；Ring 3表示最低特权级指令。</p>\n\n<p>在第一类虚拟机中，可以使VMM运行在Ring 0，虚拟内核空间运行在Ring 1，虚拟用户空间运行在Ring 2。这样可以保证在运行特权指令Ring 1和Ring 2时，虚拟机管理程序无需介入，提升运行效率。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B9%9D-%E8%99%9A%E6%8B%9F%E6%9C%BA/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（九）虚拟机'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T22:39:30+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（九）虚拟机</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（八）操作系统引导（Boot）",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%AB-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC-Boot/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#什么是操作系统引导\" id=\"markdown-toc-什么是操作系统引导\">什么是操作系统引导</a></li>\n  <li><a href=\"#与开机相关的数据\" id=\"markdown-toc-与开机相关的数据\">与开机相关的数据</a></li>\n  <li><a href=\"#操作系统引导的过程\" id=\"markdown-toc-操作系统引导的过程\">操作系统引导的过程</a></li>\n</ol>\n\n<h2 id=\"什么是操作系统引导\">什么是操作系统引导</h2>\n\n<p>开机的时候，怎么让操作系统运行起来？</p>\n\n<h2 id=\"与开机相关的数据\">与开机相关的数据</h2>\n\n<p><img src=\"\\images\\posts\\操作系统-磁盘数据.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:80%;\" /></p>\n\n<ul>\n  <li>ROM（Basic Input/Output System，BIOS）引导程序：指示CPU将磁盘的主引导记录读入RAM；</li>\n  <li>主引导记录（MBR）：CPU可以执行其中的磁盘引导程序，判断主分区的位置，读入分区引导记录；</li>\n  <li>分区引导记录（PBR）：执行引导程序，在分区根目录下的某个位置找到并读入启动管理器；</li>\n  <li>启动管理器：执行启动管理器，完成操作系统初始化的一系列工作。</li>\n</ul>\n\n<h2 id=\"操作系统引导的过程\">操作系统引导的过程</h2>\n\n<ol>\n  <li>CPU从一个特定主存地址开始取指令，执行<strong>ROM（BIOS）中的引导程序</strong>（先进行硬件自检，再开机）；</li>\n  <li>将磁盘的第一块——<strong>主引导记录（MBR）</strong>读入内存，执行磁盘引导程序，扫描分区表；</li>\n  <li>从活动分区（又称主分区，即安装了操作系统的分区）读入<strong>分区引导记录（PBR）</strong>，执行其中的程序；</li>\n  <li>从根目录下找到完整的<strong>操作系统初始化程序（即启动管理器）</strong>并执行，完成“开机”的一系列动作。</li>\n</ol>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%AB-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%BC%95%E5%AF%BC-Boot/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（八）操作系统引导（Boot）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T20:24:43+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（八）操作系统引导（Boot）</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（七）操作系统体系结构",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%83-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#操作系统的内核\" id=\"markdown-toc-操作系统的内核\">操作系统的内核</a></li>\n  <li><a href=\"#宏内核大内核单内核和微内核\" id=\"markdown-toc-宏内核大内核单内核和微内核\">宏内核（大内核/单内核）和微内核</a></li>\n  <li><a href=\"#分层结构\" id=\"markdown-toc-分层结构\">分层结构</a></li>\n  <li><a href=\"#模块化\" id=\"markdown-toc-模块化\">模块化</a></li>\n  <li><a href=\"#外核\" id=\"markdown-toc-外核\">外核</a></li>\n</ol>\n\n<h2 id=\"操作系统的内核\">操作系统的内核</h2>\n\n<p>操作系统内部的层次结构可以进一步划分，如下图所示：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-操作系统分层.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<ul>\n  <li>非内核部分：Ubuntu、CentOS的开发团队，其主要工作是实现非内核功能，而内核都是用了Linux内核。</li>\n  <li>时钟中断：利用时钟中断实现计时功能；</li>\n  <li>原语：原语是一种特殊的程序，具有原子性。也就是说，这段程序的运行必须一气呵成，不可被“中断”。</li>\n</ul>\n\n<p>操作系统内部可以划分为内核和非内核部分，<strong>内核</strong>是操作系统最基本、最核心的部分，实现操作系统内核功能的程序是内核程序。</p>\n\n<p>其中，<strong>时钟管理、中断处理和原语等</strong>部分是<strong>与硬件关联较紧密的模块</strong>；而<strong>管理模块</strong>负责的管理工作更多的是<strong>对数据结构的操作，不会直接涉及硬件</strong>。</p>\n\n<p><strong>操作系统内核</strong>需要运行在<strong>内核态</strong>；</p>\n\n<p><strong>操作系统的非内核功能</strong>运行在<strong>用户态</strong>。</p>\n<h2 id=\"宏内核大内核单内核和微内核\">宏内核（大内核/单内核）和微内核</h2>\n\n<p>把所有功能都包含在内的体系结构叫做宏内核；</p>\n\n<p><img src=\"\\images\\posts\\操作系统-宏内核体系结构.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>内核当中只保留与硬件关联最紧密部分的体系结构叫微内核。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-微内核体系结构.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>现在，应用程序想要请求操作系统的服务，这个服务的处理同时涉及到进程管理、存储管理、设备管理。</p>\n\n<p>此时使用宏内核结构需要进行两次变态，而使用微内核结构需要进行六次变态。</p>\n\n<p><strong>变态的过程是有成本的</strong>，要消耗不少时间，<strong>频繁地变态会降低系统性能</strong>。</p>\n\n<p>宏内核的特点</p>\n\n<p>所有的系统功能都放在内核里（宏内核结构的OS通常也采用了”模块化”的设计思想）。</p>\n\n<p>宏内核的优点</p>\n\n<p>性能高，内核内部各种功能都可以直接相互调用。</p>\n\n<p>宏内核的缺点</p>\n\n<ol>\n  <li>内核庞大功能复杂，难以维护；</li>\n  <li>内核中某个功能模块出错，就可能导致整个系统崩溃。</li>\n</ol>\n\n<p>微内核的特点</p>\n\n<p>只把中断、原语、进程通信等最核心的功能放入内核。进程管理、文件管理、设备管理等功能以用户进程的形式运行在用户态。</p>\n\n<p>微内核的优点</p>\n\n<ol>\n  <li>内核小功能少、易于维护，内核可靠性高；</li>\n  <li>内核外的某个功能模块出错不会导致整个系统崩溃。</li>\n</ol>\n\n<p>微内核的缺点</p>\n\n<ol>\n  <li>性能低，需要频繁的切换用户态/核心态。用户态下的各功能模块不可以直接相互调用，只能通过内核的”消息传递“来间接通信；</li>\n  <li>用户态下的各功能模块不可以直接相互调用，只能通过内核的”消息传递“来间接通信。</li>\n</ol>\n\n<h2 id=\"分层结构\">分层结构</h2>\n\n<p>分层结构的特点</p>\n\n<p><img src=\"\\images\\posts\\操作系统-分层结构.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>内核分多层，每层可单向调用更低一层提供的接口。</p>\n\n<p>分层结构的优点</p>\n\n<ol>\n  <li>便于调试和验证，自底向上逐层调试验证；</li>\n  <li>易扩充和易维护，各层之间调用接口清晰固定。</li>\n</ol>\n\n<p>分层结构的缺点</p>\n\n<ol>\n  <li>仅可调用相邻低层，难以合理定义各层的边界；</li>\n  <li>效率低，不可跨层调用，系统调用执行时间长。</li>\n</ol>\n\n<h2 id=\"模块化\">模块化</h2>\n\n<p>模块化是将操作系统按功能划分为若干个具有一定独立性的模块。每个模块具有某方面的管理功能，并<strong>规定好各模块间的接口</strong>，使各模块之间能通过接口进行通信。\n还可以进一步将各模块细分为若干个具有一定功能的子模块，同样也<strong>规定好各子模块之间的接口</strong>。\n把这种设计方法称为<strong>模块-接口法</strong>，下图为由模块、子模块等组成的模块化操作系统结构：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-模块化.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>模块化的特点</p>\n\n<p>将内核划分为多个模块，各模块之间相互协作。</p>\n\n<p>内核=主模块+可加载内核模块；</p>\n\n<p>主模块︰只负责核心功能，如进程调度、内存管理；</p>\n\n<p>可加载内核模块︰可以动态加载新模块到内核，而无需重新编译整个内核。</p>\n\n<p>模块化的优点</p>\n\n<ol>\n  <li>模块间逻辑清晰易于维护，确定模块间接口后即可多模块同时开发；</li>\n  <li>支持动态加载新的内核模块（如：安装设备驱动程序、安装新的文件系统模块到内核），增强OS适应性；</li>\n  <li>任何模块都可以直接调用其他模块，无需采用消息传递进行通信，效率高。</li>\n</ol>\n\n<p>模块化的缺点</p>\n\n<ol>\n  <li>模块间的接口定义未必合理、实用；</li>\n  <li>模块间相互依赖，更难调试和验证。</li>\n</ol>\n\n<h2 id=\"外核\">外核</h2>\n\n<p>外核的特点</p>\n\n<p>内核负责进程调度、进程通信等功能，外核负责为用户进程分配未经抽象的硬件资源，且由外核负责保证资源使用安全。</p>\n\n<p>外核的优点</p>\n\n<ol>\n  <li>外核可直接给用户进程分配”不虚拟、不抽象“的硬件资源，使用户进程可以更灵活地使用硬件资源；</li>\n  <li>减少了虚拟硬件资源的”映射层“，提升效率。</li>\n</ol>\n\n<p>外核的缺点</p>\n\n<ol>\n  <li>降低了系统的一致性；</li>\n  <li>使系统变得更复杂。</li>\n</ol>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%83-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（七）操作系统体系结构'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T19:29:07+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（七）操作系统体系结构</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（六）系统调用",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%AD-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#什么是系统调用系统调用的作用\" id=\"markdown-toc-什么是系统调用系统调用的作用\">什么是系统调用？系统调用的作用</a></li>\n  <li><a href=\"#系统调用与库函数的区别\" id=\"markdown-toc-系统调用与库函数的区别\">系统调用与库函数的区别</a></li>\n  <li><a href=\"#为什么系统调用是必须的\" id=\"markdown-toc-为什么系统调用是必须的\">为什么系统调用是必须的？</a></li>\n  <li><a href=\"#什么功能要用系统调用实现\" id=\"markdown-toc-什么功能要用系统调用实现\">什么功能要用系统调用实现</a></li>\n  <li><a href=\"#系统调用的过程\" id=\"markdown-toc-系统调用的过程\">系统调用的过程</a>    <ol>\n      <li><a href=\"#陷入指令系统调用\" id=\"markdown-toc-陷入指令系统调用\">陷入指令系统调用</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"什么是系统调用系统调用的作用\">什么是系统调用？系统调用的作用</h2>\n<p>操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中程序接口由一组<strong>系统调用</strong>组成。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-系统调用的作用1.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>“系统调用”是操作系统提供给应用程序（程序员/编程人员）使用的接口，可以理解为一种可供应用程序调用的特殊函数，<strong>应用程序可以通过系统调用来请求获得操作系统内核的服务</strong>。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-系统调用的作用2.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h2 id=\"系统调用与库函数的区别\">系统调用与库函数的区别</h2>\n\n<table>\n  <thead>\n    <tr>\n      <th>普通应用程序</th>\n      <th>可直接进行系统调用，也可使用库函数。有的库函数涉及系统调用，有的不涉及。</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>编程语言</td>\n      <td>向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使程序员编程更加方便。</td>\n    </tr>\n    <tr>\n      <td>操作系统</td>\n      <td>向上提供系统调用，使得上层程序能请求内核的服务。</td>\n    </tr>\n    <tr>\n      <td>裸机</td>\n      <td> </td>\n    </tr>\n  </tbody>\n</table>\n\n<p><img src=\"\\images\\posts\\操作系统-系统调用和库函数1.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>不涉及系统调用的库函数：如“取绝对值”的函数；</p>\n\n<p>涉及系统调用的库函数：如“创建一个新文件”的函数。</p>\n\n<h2 id=\"为什么系统调用是必须的\">为什么系统调用是必须的？</h2>\n\n<p>生活场景：去学校打印店打印论文，你按下了WPS的“打印”选项，打印机开始工作。</p>\n\n<p>你的论文打印到一半时，另一位同学按下了Word的“打印”按钮，开始打印他自己的论文。</p>\n\n<p>如果两个进程可以随意地、并发地共享打印机资源，打印机设备交替地收到WPS和Word两个进程发来的打印请求，两篇论文的内容混杂在一起了…</p>\n\n<p>解决方法：<strong>由操作系统内核对共享资源进行统一管理</strong>，并向上提供“系统调用”用户进程想要使用打印机这种共享资源，只能通过系统调用向操作系统内核发出请求。内核会对各个请求进行协调处理。</p>\n\n<h2 id=\"什么功能要用系统调用实现\">什么功能要用系统调用实现</h2>\n\n<p>应用程序通过系统调用请求操作系统的服务。\n而系统中的各种共享资源都由操作系统内核统一掌管，因此<strong>凡是与共享资源有关的操作(如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统内核提出服务请求</strong>，由操作系统内核代为完成。\n这样可以<strong>保证系统的稳定性和安全性</strong>，防止用户进行非法操作。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-系统调用的功能.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h2 id=\"系统调用的过程\">系统调用的过程</h2>\n\n<h3 id=\"陷入指令系统调用\">陷入指令系统调用</h3>\n<ol>\n  <li>应用程序执行传参指令，<strong>将传递的参数（参数1、参数2…）存放于CPU寄存器</strong>，参数可以指明系统调用类型；</li>\n  <li>应用程序执行<strong>陷入指令</strong>，引发一个内中断信号。该中断由陷入指令引发，因此转入相应中断处理程序，即系统调用的入口程序；</li>\n  <li>处理器转变为内核态运行，执行<strong>系统调用入口程序</strong>，根据寄存器中的参数判断用户需要哪种系统调用服务；</li>\n  <li>运行<strong>系统调用所对应的处理程序</strong>；</li>\n  <li>完成系统调用，CPU转变为用户态。</li>\n</ol>\n\n<p>即传递系统调用参数→执行陷入指令（用户态）→执行相应的内请求核程序处理系统调用（内核态）→返回应用程序。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-系统调用的过程1.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:80%;\" /></p>\n\n<p>注意：</p>\n<ol>\n  <li><strong>陷入指令</strong>是在<strong>用户态</strong>执行的，执行陷入指令之后立即<strong>引发一个内中断</strong>，使CPU<strong>进入内核态</strong>；</li>\n  <li><strong>发出系统调用请求是在用户态</strong>，而<strong>对系统调用的相应处理在核心态</strong>下进行。</li>\n</ol>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%85%AD-%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（六）系统调用'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T18:35:40+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（六）系统调用</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（五）中断和异常",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%94-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#中断的作用\" id=\"markdown-toc-中断的作用\">中断的作用</a></li>\n  <li><a href=\"#中断的类型\" id=\"markdown-toc-中断的类型\">中断的类型</a>    <ol>\n      <li><a href=\"#内中断异常类型\" id=\"markdown-toc-内中断异常类型\">内中断（异常）类型：</a></li>\n      <li><a href=\"#外中断类型\" id=\"markdown-toc-外中断类型\">外中断类型：</a></li>\n      <li><a href=\"#内中断异常示例\" id=\"markdown-toc-内中断异常示例\">内中断（异常）示例</a></li>\n      <li><a href=\"#外中断示例\" id=\"markdown-toc-外中断示例\">外中断示例</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#中断机制的基本原理\" id=\"markdown-toc-中断机制的基本原理\">中断机制的基本原理</a></li>\n</ol>\n\n<h2 id=\"中断的作用\">中断的作用</h2>\n<p>CPU上会运行两种程序，一种是<strong>操作系统内核程序</strong>，一种是<strong>应用程序</strong>。</p>\n\n<p>在合适的情况下，操作系统内核会把CPU的使用权主动让给应用程序。</p>\n\n<p>“中断”是<strong>让操作系统内核夺回CPU使用权的唯一途径</strong>。</p>\n\n<p>如果没有“中断”机制，那么一旦应用程序上CPU运行，CPU就会一直运行这个应用程序（没有中断，就没有并发）。</p>\n\n<h2 id=\"中断的类型\">中断的类型</h2>\n\n<p>广义上中断包括内中断（又称异常）和外中断（狭义上的中断）两种。</p>\n\n<p>内中断与当前执行的<strong>指令有关</strong>，中断信号来源于<strong>CPU内部</strong>。</p>\n\n<p>外中断与当前执行的<strong>指令无关</strong>，中断信号来源于<strong>CPU外部</strong>。</p>\n\n<h3 id=\"内中断异常类型\">内中断（异常）类型：</h3>\n<ol>\n  <li>陷入（trap）：由陷入指令引发，是应用程序故意引发的；</li>\n  <li>故障（fault）：由错误条件引起的，可能被内核程序修复。内核程序修复故障后会把CPU使用权还给应用程序，让它继续执行下去。如缺页故障等；</li>\n  <li>终止（abort）：由致命错误引起，内核程序无法修复该错误，因此一般不再将CPU使用权还给引发终止的应用程序，而是直接终止该应用程序。如整数除0、非法使用特权指令等。</li>\n</ol>\n\n<h3 id=\"外中断类型\">外中断类型：</h3>\n<p>包括时钟中断、I/O中断等。</p>\n\n<h3 id=\"内中断异常示例\">内中断（异常）示例</h3>\n\n<p><strong>终止指令</strong>：若当前执行的指令是非法的，则会引发一个中断信号。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 试图在用户态下执行特权指令\n2. 执行除法指令时发现除数为0\n</code></pre></div></div>\n\n<p><strong>陷入指令</strong>：有时候应用程序想请求操作系统内核的服务，此时会执行一条特殊的指令――陷入指令，该指令会引发一个内部中断信号。</p>\n\n<p>执行“陷入指令”，意味着应用程序主动地将CPU控制权还给操作系统内核。“系统调用”就是通过陷入指令完成的。</p>\n\n<h3 id=\"外中断示例\">外中断示例</h3>\n\n<p><strong>每一条指令执行结束时</strong>，CPU都会例行检查是否有外中断信号。</p>\n\n<p>时钟中断：时钟部件每隔一个时间片（如50ms）会给CPU发送一个时钟中断信号。时钟中断的过程如下：</p>\n\n<ol>\n  <li>在应用程序1的执行过程中，执行时间达到一个时间片，CPU分给该应用程序的时间耗尽。</li>\n  <li>此时时钟部件向CPU发送一个时钟中断信号，CPU转变为内核态并执行处理时钟中断的内核程序。操作系统内核决定接下来让应用程序2在上CPU运行。</li>\n  <li>接下来切换为用户态执行应用程序2，如此往复。</li>\n</ol>\n\n<p>I/O中断：由输入/输出设备发来的中断信号。当输入/输出任务完成后，向CPU发送中断信号。</p>\n\n<h2 id=\"中断机制的基本原理\">中断机制的基本原理</h2>\n\n<p>不同的中断信号，需要用不同的中断处理程序来处理。当CPU检测到中断信号后，会根据中断信号的类型去查询“<strong>中断向量表</strong>”，以此来找到相应的中断处理程序在内存中的存放位置。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-中断向量表示例.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p><strong>中断处理程序一定是内核程序</strong>，因此需要运行在“内核态”。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%94-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（五）中断和异常'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T18:09:49+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（五）中断和异常</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（四）操作系统的运行机制",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9B%9B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#程序是如何运行的\" id=\"markdown-toc-程序是如何运行的\">程序是如何运行的</a></li>\n  <li><a href=\"#内核程序和应用程序\" id=\"markdown-toc-内核程序和应用程序\">内核程序和应用程序</a></li>\n  <li><a href=\"#特权指令和非特权指令\" id=\"markdown-toc-特权指令和非特权指令\">特权指令和非特权指令</a></li>\n  <li><a href=\"#处理器的内核态和用户态\" id=\"markdown-toc-处理器的内核态和用户态\">处理器的内核态和用户态</a>    <ol>\n      <li><a href=\"#内核态和用户态之间的转换\" id=\"markdown-toc-内核态和用户态之间的转换\">内核态和用户态之间的转换</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"程序是如何运行的\">程序是如何运行的</h2>\n<p>在完成代码编写后，编译器将高级语言“翻译”成二进制的机器指令，<strong>程序运行的过程其实就是CPU执行一条一条机器指令的过程</strong>。</p>\n\n<p>“指令”就是处理器（CPU）能识别、执行的最基本命令。</p>\n\n<p>很多人习惯把Linux、Windows、MacOS的“小黑框”中使用的命令也称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令。</p>\n\n<h2 id=\"内核程序和应用程序\">内核程序和应用程序</h2>\n<p>普通程序员写的程序就是“<strong>应用程序</strong>”；</p>\n\n<p>微软、苹果有一帮人负责实现操作系统，他们写的是“<strong>内核程序</strong>”由很多内核程序组成了“<strong>操作系统内核</strong>”，或简称“<strong>内核（Kernel）</strong>”，内核是操作系统最重要最核心的部分，也是<strong>最接近硬件的部分</strong>。</p>\n\n<p>一个操作系统只要有内核就够了（比如Docker仅需Linux内核）。操作系统的功能未必都在内核中，如GUI。</p>\n\n<h2 id=\"特权指令和非特权指令\">特权指令和非特权指令</h2>\n<p>操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如内存清零指令。这些指令影响重大，只允许“管理者”，即操作系统内核来使用。</p>\n\n<p>应用程序只能使用“非特权指令”，如加法指令、减法指令等。</p>\n\n<p>在<strong>CPU设计和生产的时候就划分了特权指令和非特权指令</strong>，因此CPU执行一条指令前就能判断出其类型。</p>\n\n<h2 id=\"处理器的内核态和用户态\">处理器的内核态和用户态</h2>\n<p>虽然CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序还是应用程序?</p>\n\n<p>CPU有两种状态，“<strong>内核态</strong>”和“<strong>用户态</strong>”</p>\n\n<p>处于内核态时，说明此时<strong>正在运行的是内核程序</strong>，此时<strong>可以执行特权指令</strong>；</p>\n\n<p>处于用户态时，说明此时<strong>正在运行的是应用程序</strong>，此时<strong>只能执行非特权指令</strong>。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”。\n</code></pre></div></div>\n\n<h3 id=\"内核态和用户态之间的转换\">内核态和用户态之间的转换</h3>\n\n<ol>\n  <li>刚开机时，CPU为“内核态”，操作系统内核程序先上CPU运行；</li>\n  <li>开机完成后，用户可以启动某个应用程序；</li>\n  <li>操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行（操作系统内核在让出CPU之前，会<strong>用一条特权指令把PSW的标志位设置为“用户态”</strong>）；</li>\n  <li>应用程序运行在“用户态”；</li>\n  <li>应用程序中植入了一条特权指令，CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”；</li>\n  <li>因此，这个事件会引发一个<strong>中断信号</strong>（<strong>CPU检测到中断信号后</strong>，会立即<strong>变为“内核态”</strong>，并停止运行当前的应用程序，转而运行处理中断信号的内核程序）；</li>\n  <li>“中断”使操作系统再次夺回CPU的控制权；</li>\n  <li>操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序。</li>\n</ol>\n\n<p>内核态→用户态：执行一条<strong>特权指令——修改PSW</strong>的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权。</p>\n\n<p>用户态→内核态：由“<strong>中断</strong>”引发，<strong>硬件自动完成变态过程</strong>，触发中断信号意味着操作系统将强行夺回CPU的使用权（除了非法使用特权指令之外，还有很多事件会触发中断信号。一个共性是，<strong>但凡需要操作系统介入的地方，都会触发中断信号</strong>）。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9B%9B-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9C%BA%E5%88%B6/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（四）操作系统的运行机制'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T17:45:27+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（四）操作系统的运行机制</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（三）操作系统的发展和分类",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#手工操作阶段\" id=\"markdown-toc-手工操作阶段\">手工操作阶段</a></li>\n  <li><a href=\"#批处理阶段\" id=\"markdown-toc-批处理阶段\">批处理阶段</a>    <ol>\n      <li><a href=\"#单道批处理系统\" id=\"markdown-toc-单道批处理系统\">单道批处理系统</a></li>\n      <li><a href=\"#多道批处理系统\" id=\"markdown-toc-多道批处理系统\">多道批处理系统</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#分时操作系统\" id=\"markdown-toc-分时操作系统\">分时操作系统</a></li>\n  <li><a href=\"#实时操作系统\" id=\"markdown-toc-实时操作系统\">实时操作系统</a></li>\n  <li><a href=\"#其它操作系统\" id=\"markdown-toc-其它操作系统\">其它操作系统</a></li>\n</ol>\n\n<p>操作系统的发展主要包含以下发展阶段及分类：</p>\n\n<p><img src=\"\\images\\posts\\操作系统-操作系统的分类.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h2 id=\"手工操作阶段\">手工操作阶段</h2>\n\n<p>在操作系统的手工操作阶段，由于大量时间被消耗在纸带的装取及读写上，计算机的计算效率极低。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-手工操作.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>手工操作阶段的主要缺点是<strong>用户独占全机、人机速度矛盾导致资源利用率极低</strong>。</p>\n\n<h2 id=\"批处理阶段\">批处理阶段</h2>\n\n<h3 id=\"单道批处理系统\">单道批处理系统</h3>\n\n<p>引入脱机输入/输出技术（用外围机+磁带完成），并由监督程序负责控制作业的输入、输出。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-单道批处理示意.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>用户通过外围机把程序提前存到磁带里，磁带的读写速度比纸带快很多。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-单道批处理.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>主要优点：缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p>\n\n<p>主要缺点：<strong>内存中仅能有一道程序运行</strong>，只有该程序运行结束之后才能调入下一道程序。<strong>CPU有大量的时间是在空闲等待I/O完成</strong>，资源利用率依然很低。</p>\n\n<h3 id=\"多道批处理系统\">多道批处理系统</h3>\n\n<p>每次往内存中读入多道程序，此时操作系统正式诞生，用于支持多道程序并发运行。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-多道批处理.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>主要优点：多道程序<strong>并发</strong>执行，<strong>共享</strong>计算机资源。<strong>资源利用率大幅提升</strong>，CPU和其他资源更能保持“忙碌”状态，系统吞吐量增大。</p>\n\n<p>主要缺点：用户响应时间长，<strong>没有人机交互功能</strong>（用户提交自己的作业之后就只能等待计算机处理完成，中间不能控制自己的作业执行。比如无法调试程序/无法在程序运行过程中输入一些参数）</p>\n\n<h2 id=\"分时操作系统\">分时操作系统</h2>\n\n<p>分时操作系统的计算机以<strong>时间片</strong>为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-分时操作系统示意.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<p>主要优点：用户请求可以被即时响应，<strong>解决了人机交互问题</strong>。允许多个用户同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p>\n\n<p>主要缺点：<strong>不能优先处理一些紧急任务</strong>。操作系统对各个用户/作业都是完全公平的，循环地为每个用户/作业服务一个时间片，不区分任务的紧急性。</p>\n\n<h2 id=\"实时操作系统\">实时操作系统</h2>\n\n<p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p>\n\n<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并且<strong>要在严格的时限内处理完事件</strong>。实时操作系统的主要特点是<strong>及时性和可靠性</strong>。</p>\n\n<p>实时操作系统主要包含硬实时系统和软实时系统。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 硬实时系统必须在绝对严格的规定时间内完成处理（如导弹控制系统、自动驾驶系统）；\n2. 软实时系统能接收偶尔违反时间规定（如抢票系统）。\n</code></pre></div></div>\n\n<h2 id=\"其它操作系统\">其它操作系统</h2>\n\n<p>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，<strong>实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信</strong>。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</p>\n\n<p>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，<strong>任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务</strong>。</p>\n\n<p>个人计算机操作系统：如Windows XP、Mac OS，方便个人使用。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%89-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E5%8F%91%E5%B1%95%E5%92%8C%E5%88%86%E7%B1%BB/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（三）操作系统的发展和分类'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T16:26:17+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（三）操作系统的发展和分类</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（二）操作系统的特征",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#并发\" id=\"markdown-toc-并发\">并发</a></li>\n  <li><a href=\"#共享\" id=\"markdown-toc-共享\">共享</a>    <ol>\n      <li><a href=\"#互斥共享方式\" id=\"markdown-toc-互斥共享方式\">互斥共享方式</a></li>\n      <li><a href=\"#同时共享方式\" id=\"markdown-toc-同时共享方式\">同时共享方式</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#并发和共享的关系\" id=\"markdown-toc-并发和共享的关系\">并发和共享的关系</a></li>\n  <li><a href=\"#虚拟\" id=\"markdown-toc-虚拟\">虚拟</a></li>\n  <li><a href=\"#异步\" id=\"markdown-toc-异步\">异步</a></li>\n</ol>\n\n<p>操作系统主要包括并发、共享、虚拟及异步四个特征。其中并发和共享二者互为存在条件，且没有并发和共享，就谈不上虚拟和异步，因此<strong>并发和共享是操作系统的两个最基本的特征</strong>。</p>\n\n<h2 id=\"并发\">并发</h2>\n\n<p><strong>并发</strong>：指两个或多个事件在同一时间间隔内发生。这些事件宏观上是同时发生的，但微观上是交替发生的。</p>\n\n<p><strong>并行</strong>：指两个或多个事件在同一时刻同时发生。</p>\n\n<p><strong>操作系统的并发性</strong>指计算机系统中“同时”运行着多个程序，这些程序宏观上看是同时运行着的，而微观上看是交替运行的。</p>\n\n<p>操作系统是伴随着“多道程序技术”而出现的。因此操作系统和程序并发是一起诞生的。</p>\n\n<p>单核CPU同一时刻只能执行一个程序，各个程序只能并发执行；多核CPU同一时刻可以同时执行多个程序，多个程序可以并行执行。</p>\n\n<p>Intel第八代i3处理器就是4核CPU，意味着可以并行地执行4个程序。但即使是对于4核CPU来说，只要有4个以上的程序需要“同时”运行，那么并发性依然是必不可少的，因此并发性是操作系统一个最基本的特性。</p>\n\n<h2 id=\"共享\">共享</h2>\n<p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>\n\n<p>共享主要包括互斥共享和同时共享两种共享方式。</p>\n\n<h3 id=\"互斥共享方式\">互斥共享方式</h3>\n<p>系统中的某些资源，虽然可以提供给多个进程使用，但<strong>一个时间段内只允许一个进程访问该资源</strong>。</p>\n\n<p>比如使用QQ和微信进行视频通话，同一时间段摄像头只能分配给其中一个进程。</p>\n\n<h3 id=\"同时共享方式\">同时共享方式</h3>\n<p>系统中的某些资源，<strong>允许一个时间段内由多个进程“同时”对它们进行访问</strong>。但所谓的“同时”往往是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问的（即分时共享）。</p>\n\n<p>比如使用QQ发送文件A，同时使用微信发送文件B。宏观上看，两边都在同时读取并发送文件，说明两个进程都在访问硬盘资源，从中读取数据。微观上看，两个进程是交替着访问硬盘的。</p>\n\n<h2 id=\"并发和共享的关系\">并发和共享的关系</h2>\n<p><strong>并发性</strong>指计算机系统中同时存在着多个运行着的程序。</p>\n\n<p><strong>共享性</strong>是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>\n\n<p>在比如使用QQ发送文件A，同时使用微信发送文件B这一过程中，</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 两个进程正在并发执行（并发性）\n2. 需要共享地访问硬盘资源（共享性）\n</code></pre></div></div>\n\n<p>如果失去并发性，则系统中只有一个程序正在运行，则共享性失去存在的意义；如果失去共享性，则QQ和微信不能同时访问硬盘资源，就无法实现同时发送文件，也就无法并发。</p>\n\n<h2 id=\"虚拟\">虚拟</h2>\n<p>虚拟是指把一个物理上的实体变为若干个逻辑上的对应物。物理实体（前者）是实际存在的，而逻辑上对应物（后者)是用户感受到的。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>GTA5需要4GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存......\n我的电脑:4GB内存\n问题:这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢?\n答:这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB\n</code></pre></div></div>\n\n<p>虚拟存储器技术用到了<strong>空分复用技术</strong>。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>某用户在单核CPU的电脑上同时打开了6个应用程序。\n问题:既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU的电脑中能同时运行这么多个程序呢?\n答:这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务\n</code></pre></div></div>\n\n<p>这里用到虚拟技术中的<strong>时分复用技术</strong>。微观上处理机在各个微小的时间段内交替为各个进程服务。</p>\n\n<p>显然，如果失去了并发性，则<strong>一个时间段内系统中只需运行一道程序，那么就失去了实现虚拟性的意义了</strong>。因此，<strong>没有并发性，就谈不上虚拟性</strong>。</p>\n\n<h2 id=\"异步\">异步</h2>\n<p>异步是指，在多道程序环境下，允许多个程序并发执行，但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，这就是进程的异步性。</p>\n\n<p>由于并发运行的程序会争抢着使用系统资源，而系统中的资源有限，因此进程的执行不是一贯到底的，而是走走停停的，以不可预知的速度向前推进。</p>\n\n<p>如果失去了并发性，即系统只能串行地运行各个程序，那么每个程序的执行会一贯到底。<strong>只有系统拥有并发性，才有可能导致异步性</strong>。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%BA%8C-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%89%B9%E5%BE%81/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（二）操作系统的特征'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T03:45:10+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（二）操作系统的特征</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "操作系统（一）操作系统的概念和功能",
      "category" : "",
      "tags"     : "操作系统",
      "url"      : "/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8A%9F%E8%83%BD/",
      "date"     : "Apr 20, 2022",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#声明\" id=\"markdown-toc-声明\">声明</a></li>\n  <li><a href=\"#操作系统的定义\" id=\"markdown-toc-操作系统的定义\">操作系统的定义</a></li>\n  <li><a href=\"#操作系统的功能和目标\" id=\"markdown-toc-操作系统的功能和目标\">操作系统的功能和目标</a>    <ol>\n      <li><a href=\"#作为系统资源的管理者\" id=\"markdown-toc-作为系统资源的管理者\">作为系统资源的管理者</a></li>\n      <li><a href=\"#向上层提供方便易用的服务\" id=\"markdown-toc-向上层提供方便易用的服务\">向上层提供方便易用的服务</a>        <ol>\n          <li><a href=\"#封装思想\" id=\"markdown-toc-封装思想\">封装思想</a></li>\n          <li><a href=\"#操作系统提供的服务示例\" id=\"markdown-toc-操作系统提供的服务示例\">操作系统提供的服务示例</a></li>\n        </ol>\n      </li>\n      <li><a href=\"#作为最接近硬件的层次\" id=\"markdown-toc-作为最接近硬件的层次\">作为最接近硬件的层次</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"声明\">声明</h2>\n<p>本系列主要参考了\n<a href=\"https://www.bilibili.com/video/BV1YE411D7nH\">王道计算机考研 操作系统</a>\n完成，准确来说是作者的学习笔记，读者可以视频为主，以本文为辅进行学习。</p>\n\n<h2 id=\"操作系统的定义\">操作系统的定义</h2>\n\n<p>在了解操作系统的定义前，为了方便起见，我们可以将计算机系统抽象为包含如下四层的层次结构。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-计算机系统层次结构2.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<p>明确操作系统在计算机系统所在位置后，可以给出操作系统的定义</p>\n\n<p>操作系统（Operating System，OS）是指控制和<strong>管理</strong>整个计算机系统的<strong>硬件和软件</strong>资源，并合理地组织调度计算机的工作和资源的分配；以<strong>提供给用户和其他软件方便的接口和环境</strong>；它是计算机系统中最基本的、最接近系统硬件的<strong>系统软件</strong>。</p>\n\n<p>在任务管理器中可以看到操作系统对应用程序使用的管理及对硬件资源的监控。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-任务管理器.jpg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:50%;\" /></p>\n\n<h2 id=\"操作系统的功能和目标\">操作系统的功能和目标</h2>\n\n<h3 id=\"作为系统资源的管理者\">作为系统资源的管理者</h3>\n\n<p>操作系统作为系统资源的管理者，其提供的四种功能包括<strong>处理机管理、存储器管理、文件管理及设备管理</strong>。其主要目标包括<strong>安全和高效</strong>。</p>\n\n<p>使用QQ进行视频聊天时，操作系统的工作主要包含四步：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1. 在各个文件夹中找到QQ安装的位置；（逐层打开文件夹，找到QQ的可执行文件存放位置。）\n2. 用户双击打开QQ；（将该程序相关数据放入内存，执行一个程序前**需要将该程序放到内存中**，才能被CPU处理。）\n3. QQ程序正常运行；（对应进程被处理机（CPU）处理。）\n4. 开始视频聊天。（需要将摄像头设备分配给进程。）\n</code></pre></div></div>\n\n<h3 id=\"向上层提供方便易用的服务\">向上层提供方便易用的服务</h3>\n\n<h4 id=\"封装思想\">封装思想</h4>\n\n<p>操作系统把一些丑陋的硬件功能封装成简单易用的服务，使用户能更方便地使用计算机,用户无需关心底层硬件的原理，只需要对操作系统发出命令即可。</p>\n\n<p>硬件只听得懂二进制指令，如：<code class=\"language-plaintext highlighter-rouge\">01010111101110111010101</code>，对外暴露了“丑陋”、不友好的交互接口。</p>\n\n<p>在硬件之上安装了操作系统，操作系统对外暴露了“美丽”、友好的交互接口。</p>\n\n<h4 id=\"操作系统提供的服务示例\">操作系统提供的服务示例</h4>\n\n<p>操作系统提供的服务包括图形化用户接口、命令接口及程序接口，其中命令接口和程序接口统称用户接口。</p>\n\n<p>（1）图形化用户接口(Graphical User Interface，GUI)</p>\n\n<p>用户可以使用形象的图形界面进行操作，而不再需要记忆复杂的命令、参数。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>比如在Windows操作系统中，删除一个文件只需要把文件“拖拽”到回收站即可。\n</code></pre></div></div>\n\n<p>（2）联机命令接口(交互式命令接口)</p>\n\n<p>由一组键盘操作命令及命令解释程序组成（通过命令解释程序对用户从键盘输入的命令进行检查命令格式、完成命令的执行）。</p>\n\n<p>即用户说一句，系统做一句。</p>\n\n<p>（3）脱机命令接口(批处理命令接口)</p>\n\n<p>由一组作业控制语言（JCL）组成。</p>\n\n<p>比如.bat、.sh等批处理文件。即用户说一堆，系统做一堆。</p>\n\n<p>（4）程序接口</p>\n\n<p>可以在程序中进行系统调用来使用程序接口。普通用户不能直接使用程序接口，只能通过程序代码间接使用。</p>\n\n<p><img src=\"\\images\\posts\\操作系统-系统调用.svg\" style=\"     display: block;     margin-left: auto;     margin-right: auto;      zoom:100%;\" /></p>\n\n<h3 id=\"作为最接近硬件的层次\">作为最接近硬件的层次</h3>\n\n<p>操作系统作为最接近硬件的层次，需要实现<strong>对硬件机器的拓展</strong>。</p>\n\n<p>没有任何软件支持的计算机称为<strong>裸机</strong>。在裸机上安装的操作系统，可以提供资源管理功能和方便用户的服务功能，将裸机改造成功能更强、使用更方便的机器。</p>\n\n<p>通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong>。</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>类比于汽车，硬件级别的发动机和轮胎无法直接衔接，使用传动系统让发动机带动轮子，即完成了对原始硬件机器的拓展。\n</code></pre></div></div>\n\n<p>操作系统对硬件机器的拓展：将CPU、内存、磁盘、显示器、键盘等硬件合理地组织起来，让各种硬件能够相互协调配合，实现更多更复杂的功能。</p>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2022/04/20/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E4%B8%80-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%8A%9F%E8%83%BD/'> <img src='/images/covers/操作系统-cover1.png' alt='操作系统（一）操作系统的概念和功能'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2022-04-20T02:17:03+08:00'>Apr 20, 2022</time> </span> </div><h2 class='article__title'>操作系统（一）操作系统的概念和功能</h2> <p class='article__excerpt'>操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/操作系统' class='article__tag'>操作系统</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "双指针问题（二）滑动窗口",
      "category" : "",
      "tags"     : "算法, 指针, 链表, and 数据结构",
      "url"      : "/2021/10/19/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%BA%8C-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
      "date"     : "Oct 19, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a></li>\n  <li><a href=\"#209-长度最小的子数组\" id=\"markdown-toc-209-长度最小的子数组\">209. 长度最小的子数组</a></li>\n  <li><a href=\"#713-乘积小于k的子数组\" id=\"markdown-toc-713-乘积小于k的子数组\">713. 乘积小于K的子数组</a></li>\n  <li><a href=\"#3-无重复字符的最长子串\" id=\"markdown-toc-3-无重复字符的最长子串\">3. 无重复字符的最长子串</a></li>\n  <li><a href=\"#438-找到字符串中所有字母异位词\" id=\"markdown-toc-438-找到字符串中所有字母异位词\">438. 找到字符串中所有字母异位词</a></li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>滑动窗口是在数组上通过双指针同向移动而解决问题的方法。这样的问题我们不必为它们专门命名一个名字，它们的解法其实是很自然的。</p>\n\n<p>滑动窗口通常是暴力解法的优化，掌握这一类问题最好的办法就是练习，然后思考清楚为什么可以使用滑动窗口。</p>\n\n<h2 id=\"209-长度最小的子数组\"><a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/\">209. 长度最小的子数组</a></h2>\n\n<p>该题是最基本的滑动窗口问题，我们可以用两个指针\\(l\\)和\\(r\\)表示窗口的左右段，然后让指针\\(r\\)持续向右移动，同时用一个变量\\(sum\\)记录\\([l,r]\\)的区间和，若\\(sum\\)满足条件，则记录\\(l\\)和\\(r\\)的差作为答案，并移动指针\\(l\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">minSubArrayLen</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">INT_MAX</span><span class=\"p\">,</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">];</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">&gt;=</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">min</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n                <span class=\"n\">sum</span> <span class=\"o\">-=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">];</span>\n                <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span> <span class=\"o\">==</span> <span class=\"n\">INT_MAX</span> <span class=\"o\">?</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h2 id=\"713-乘积小于k的子数组\"><a href=\"https://leetcode-cn.com/problems/subarray-product-less-than-k/\">713. 乘积小于K的子数组</a></h2>\n\n<p>这道题的解法与上道题非常相似，但求的不再是区间长度而是连续子区间数量。</p>\n\n<p>对于子区间数量，我们可以发现，若\\([l,r]\\)是一个符合条件的窗口，则\\([l+i,r],(0&lt;i≤r-l)\\)也必然是符合条件的窗口</p>\n\n<p>即对于任何符合条件的区间\\([l,r]\\)，以\\(r\\)结尾的子集个数永远是\\(r-l+1\\)，因此我们要在每次更新\\(r\\)之前为答案加上\\(r-l+1\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numSubarrayProductLessThanK</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">*=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">];</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">sum</span> <span class=\"o\">/=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">];</span>\n                <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h2 id=\"3-无重复字符的最长子串\"><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3. 无重复字符的最长子串</a></h2>\n\n<p>与前面的连续子序列不同的是，这道题要求的是连续子串的长度，因此我们需要修改一下判定条件，若窗口区间内出现重复字符，则更新\\(l\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">lengthOfLongestSubstring</span><span class=\"p\">(</span><span class=\"n\">string</span> <span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"n\">map</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">cnt</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">cnt</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]]</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">cnt</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">cnt</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]]</span><span class=\"o\">--</span><span class=\"p\">;</span>\n                <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n            <span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n\n<h2 id=\"438-找到字符串中所有字母异位词\"><a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></h2>\n\n<p>这道题解法与上一题大同小异，是把字符的判据改为了字符串的比较。同时，该题的窗口长度始终保持不变，为\\(p\\)的长度</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">findAnagrams</span><span class=\"p\">(</span><span class=\"n\">string</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">string</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">(</span><span class=\"mi\">26</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"mi\">26</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">())</span> <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"n\">target</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">++</span><span class=\"p\">,</span> <span class=\"n\">sum</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">();</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">--</span><span class=\"p\">;</span>\n            <span class=\"n\">sum</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">)</span>\n                <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/19/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%BA%8C-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/'> <img src='https://api.dujin.org/bing/1920.php' alt='双指针问题（二）滑动窗口'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-19T21:41:33+08:00'>Oct 19, 2021</time> </span> </div><h2 class='article__title'>双指针问题（二）滑动窗口</h2> <p class='article__excerpt'>双指针是在遍历的过程中，使用两个方向相同或相反的指针进行扫描，从而达到相应目的的算法。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/指针' class='article__tag'>指针</a>  <a href='/tag/链表' class='article__tag'>链表</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "二分查找（Binary Search）",
      "category" : "",
      "tags"     : "算法",
      "url"      : "/2021/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search/",
      "date"     : "Oct 15, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a>    <ol>\n      <li><a href=\"#模板\" id=\"markdown-toc-模板\">模板</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#题目\" id=\"markdown-toc-题目\">题目</a>    <ol>\n      <li><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置\" id=\"markdown-toc-34-在排序数组中查找元素的第一个和最后一个位置\">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>\n      <li><a href=\"#74-搜索二维矩阵\" id=\"markdown-toc-74-搜索二维矩阵\">74. 搜索二维矩阵</a></li>\n      <li><a href=\"#33-搜索旋转排序数组\" id=\"markdown-toc-33-搜索旋转排序数组\">33. 搜索旋转排序数组</a></li>\n      <li><a href=\"#153-寻找旋转排序数组中的最小值\" id=\"markdown-toc-153-寻找旋转排序数组中的最小值\">153. 寻找旋转排序数组中的最小值</a></li>\n      <li><a href=\"#162-寻找峰值\" id=\"markdown-toc-162-寻找峰值\">162. 寻找峰值</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>二分查找是对已排好序的数组查找特定值的常用方法，二分查找不必遍历整个序列，只需关注序列的边界及中间值即可，因此时间复杂度可以达到\\(O(logn)\\)</p>\n\n<h3 id=\"模板\">模板</h3>\n\n<p>在一个有序序列中查找关键字\\(key\\)的模板代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n            <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h2 id=\"题目\">题目</h2>\n\n<p>二分的题目模板一般都是固定的，主要是能否想到的对什么进行二分，怎样二分。</p>\n\n<h3 id=\"34-在排序数组中查找元素的第一个和最后一个位置\"><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3>\n\n<p>该题不仅要求元素出现的第一个位置，还要求出元素出现的最后一个位置。在模板代码中，若<code class=\"language-plaintext highlighter-rouge\">nums[i] &lt; key</code>，才会继续查找左边，如果我们想在已经找到元素后继续查找，则需要修改为<code class=\"language-plaintext highlighter-rouge\">nums[i] &lt;= key</code>。这样查找的结果是大于\\(key\\)的第一个元素的位置。因此该题的代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"kt\">bool</span> <span class=\"n\">next</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">last</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">key</span><span class=\"p\">))</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">searchRange</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"nb\">false</span><span class=\"p\">),</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">};</span>\n        <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h3 id=\"74-搜索二维矩阵\"><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix/\">74. 搜索二维矩阵</a></h3>\n\n<p>依题可知待查找元素必大于或等于该行第一个元素，因此我们先对列进行一次二分查找，寻找不大于\\(target\\)的最大元素</p>\n\n<p>之后对该行进行基本的二分查找，即可得到结果。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">searchMatrix</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">matrix</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(),</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"c1\">// 先找小于target的第一个数的位置</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>  \t\t\t\t\t     <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ans</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">ans</span> <span class=\"o\">&gt;=</span> <span class=\"n\">matrix</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">())</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">][</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>\t\t\t\t\t\t   <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">][</span><span class=\"n\">res</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h3 id=\"33-搜索旋转排序数组\"><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">33. 搜索旋转排序数组</a></h3>\n\n<p>该题只保证了数组的局部有序，但对数组进行二分后，会发现总有一半的数组是有序的，此时可以继续对有序的数组进行二分查找，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">ans</span> <span class=\"o\">&lt;</span> <span class=\"n\">t</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"o\">?</span> <span class=\"n\">ans</span> <span class=\"o\">:</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">search</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">])</span> <span class=\"p\">{</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ans</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n\n<h3 id=\"153-寻找旋转排序数组中的最小值\"><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\">153. 寻找旋转排序数组中的最小值</a></h3>\n\n<p>该题要查找的是上一题中旋转的排序数组的最小值，也即旋转点的值，我们依然利用部分有序的性质，二分查找数组最小值，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">findMin</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">])</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h3 id=\"162-寻找峰值\"><a href=\"https://leetcode-cn.com/problems/find-peak-element/\">162. 寻找峰值</a></h3>\n\n<p>我们可以用\\([l,r]\\)来存储可能存在峰值的区间，根据\\(mid\\)进行二分，若<code class=\"language-plaintext highlighter-rouge\">nums[mid] &lt; nums[mid + 1]</code>则说明在区间\\([mid+1,r]\\)存在峰值，反之则说明在区间[l,mid]存在峰值，因此代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">findPeakElement</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 用l,r表示可能存在峰值的区间</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">l</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"c1\">//mid+1-r更大</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span><span class=\"c1\">//l-mid更大</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search/'> <img src='/images/covers/blackrock2.jpg' alt='二分查找（Binary Search）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2021-10-15T20:51:55+08:00'>Oct 15, 2021</time> </span> </div><h2 class='article__title'>二分查找（Binary Search）</h2> <p class='article__excerpt'>二分查找是对已排好序的数组查找特定值的常用方法，二分查找不必遍历整个序列，只需关注序列的边界及中间值即可，因此时间复杂度可以达到 O(log n)</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（四）最长上升子序列（LIS）",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/10/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9B%9B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-LIS/",
      "date"     : "Oct 11, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#动态规划\" id=\"markdown-toc-动态规划\">动态规划</a></li>\n  <li><a href=\"#树状数组\" id=\"markdown-toc-树状数组\">树状数组</a></li>\n</ol>\n\n<p><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">300.最长递增子序列</a></p>\n\n<h2 id=\"动态规划\">动态规划</h2>\n<p>我们可以定义\\(dp[i]\\)为以\\(i\\)结尾的递增子序列长度的最大值（数组\\(dp\\)的常用套路），则我们可以写出状态转移方程为\n\\(dp[i]=max(dp[j])+1,(0≤j&lt;i, nums[j]&lt;nums[i])\\)</p>\n\n<p>最后，此题的结果便是\\(max(dp[i])\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">lengthOfLIS</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">dp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n                <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>该解法时间复杂度为\\(O(n^2)\\)</p>\n\n<h2 id=\"树状数组\">树状数组</h2>\n<p>LIS问题的本质是偏序问题，我们之前在二维偏序问题中提到过，树状数组可以轻松的解决这类问题。但之前的问题中，我们求的是数对的数量，而不是序列的长度。为了能够求得序列长度，我们要对树状数组进行修改。</p>\n\n<p>我们可以用树状数组存储以\\(i\\)结尾的递增子序列最大值，修改树状数组结构如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">N</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">int</span> <span class=\"nf\">sum</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">sum</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"n\">i</span> <span class=\"o\">-=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>随后用和\\(dp\\)同样的方式进行遍历，可以得出正确结果，同时要注意数据的离散化，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Fenwick</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"p\">;</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">node</span><span class=\"p\">;</span>\n\n    <span class=\"n\">Fenwick</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">),</span> <span class=\"n\">node</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n\n    <span class=\"kt\">int</span> <span class=\"nf\">lowbit</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"o\">-</span><span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">N</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    \n    <span class=\"kt\">int</span> <span class=\"nf\">sum</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">sum</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n            <span class=\"n\">i</span> <span class=\"o\">-=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">lengthOfLIS</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">;</span>\n        <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n        <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">erase</span><span class=\"p\">(</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n        <span class=\"n\">Fenwick</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Fenwick</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">lower_bound</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">(),</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">-</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>\n            <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n            <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n            <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<p>该解法时间复杂度为\\(O(nlogn)\\)</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/10/11/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9B%9B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-LIS/'> <img src='/images/covers/village.jpg' alt='动态规划（四）最长上升子序列（LIS）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-11T21:19:19+08:00'>Oct 11, 2021</time> </span> </div><h2 class='article__title'>动态规划（四）最长上升子序列（LIS）</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "二叉树基础（三） 线段树（Segment Tree）",
      "category" : "",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree/",
      "date"     : "Oct 9, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a>    <ol>\n      <li><a href=\"#结构\" id=\"markdown-toc-结构\">结构</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#基本操作\" id=\"markdown-toc-基本操作\">基本操作</a>    <ol>\n      <li><a href=\"#线段树的建立\" id=\"markdown-toc-线段树的建立\">线段树的建立</a></li>\n      <li><a href=\"#区间查询\" id=\"markdown-toc-区间查询\">区间查询</a></li>\n      <li><a href=\"#区间修改\" id=\"markdown-toc-区间修改\">区间修改</a></li>\n      <li><a href=\"#懒惰标记\" id=\"markdown-toc-懒惰标记\">懒惰标记</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#整体代码\" id=\"markdown-toc-整体代码\">整体代码</a></li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>线段树是常用于<strong>维护区间信息</strong>的数据结构</p>\n\n<p>线段树可以在$O(logn)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作</p>\n\n<h3 id=\"结构\">结构</h3>\n\n<p>线段树将每个长度不为$1$的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p>\n\n<p>假设以线段树存储数组$a=[6,7,8,9,10]$，设线段树的根节点编号为$1$，用数组$node$来保存线段树，$node[i]$用来保存线段树上编号为$i$的节点的值</p>\n\n<p>该线段树的结构如下</p>\n\n<p><img src=\"/images/posts/segmenttree1.png\" alt=\"在这里插入图片描述\" />\n代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">node</span><span class=\"p\">;</span> <span class=\"c1\">// 线段树下标从1开始</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">;</span> <span class=\"c1\">// 辅助建树</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"p\">;</span>\n</code></pre></div></div>\n\n<h2 id=\"基本操作\">基本操作</h2>\n<h3 id=\"线段树的建立\">线段树的建立</h3>\n\n<p>对于节点$i$，其子节点的编号为$2i$以及$2i+1$，若节点$i$存储的区间为$[a,b]$，则节点$2i$存储的区间应该是$[a,\\frac{a+b}{2}]$，相应地，节点$2i+1$存储的区间为$[\\frac{a+b}{2}+1,b]$。我们可以采用递归的方式建树，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">build</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// i表示当前节点, l表示左边界, r表示右边界</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">];</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span>\n    <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">);</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"区间查询\">区间查询</h3>\n<p>若查询的区间为$[1,5]$，我们只需直接返回$node[1]$，但如果我们查询的是$[3,5]$，则需要合并$[3,3]$和$[4,5]$的答案，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">//i表示当前节点, [l,r]是查询区间, [s,t]表示当前节点包含区间</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接返回</span>\n        <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归查询存在交集的子区间</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询左字串</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询右字串</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h3 id=\"区间修改\">区间修改</h3>\n<p>和区间查询相同，若区间存在包含关系，我们可以为其直接加上所需要更新的值，而当区间存在交集时，进行递归更新，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">add</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接更新</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">add</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归更新存在交集的子区间</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新左字串</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新右字串</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h3 id=\"懒惰标记\">懒惰标记</h3>\n<p>当我们按照上面的方法对$[6,7,8,9,10]$的区间$[3,5]$加上$2$后，更新后的线段树结构如下\n<img src=\"/images/posts/segmenttree2.png\" alt=\"在这里插入图片描述\" />\n我们会发现，在进行递归更新时，递归执行到节点$3$时就已经结束了，因此节点$3$的两个子节点没有被更新</p>\n\n<p>遇到这种情况，我们需要给递归结束的节点打上一个标记，在下一次查询操作时将没有更新的子节点更新，这个标记被称为懒惰标记，这样更新时效果如图</p>\n\n<p><img src=\"/images/posts/segmenttree3.png\" alt=\"在这里插入图片描述\" /></p>\n\n<p>而查询后的效果如下</p>\n\n<p><img src=\"/images/posts/segmenttree4.png\" alt=\"在这里插入图片描述\" />\n我们可以用<code class=\"language-plaintext highlighter-rouge\">vector&lt;int&gt; lazy</code>来存储懒惰标记，下方懒惰标记的代码如下</p>\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">push_down</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>             <span class=\"c1\">// 下放懒惰标记</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span> <span class=\"c1\">// 将懒惰标记的值加给子树</span>\n    <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>然后在查询和更新函数中调用<code class=\"language-plaintext highlighter-rouge\">push_down()</code>即可</p>\n\n<h2 id=\"整体代码\">整体代码</h2>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">SegmentTree</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">node</span><span class=\"p\">;</span> <span class=\"c1\">// 线段树下标从1开始</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">lazy</span><span class=\"p\">;</span> <span class=\"c1\">// 懒惰标记</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">;</span> <span class=\"c1\">// 辅助建树</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n    <span class=\"n\">SegmentTree</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">nums</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">build</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// i表示当前节点, l表示左边界, r表示右边界</span>\n        <span class=\"n\">N</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n        <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span>\n        <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">);</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">push_down</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n        <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>             <span class=\"c1\">// 下放懒惰标记</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span> <span class=\"c1\">// 将懒惰标记的值加给子树</span>\n        <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">int</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">//i表示当前节点, [l,r]是查询区间, [s,t]表示当前节点包含区间</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接返回</span>\n            <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">push_down</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归查询存在交集的子区间</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询左字串</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询右字串</span>\n        <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">add</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接更新</span>\n            <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">add</span><span class=\"p\">;</span>\n            <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">add</span><span class=\"p\">;</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">push_down</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归更新存在交集的子区间</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新左字串</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新右字串</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree/'> <img src='/images/covers/数据结构-cover1.png' alt='二叉树基础（三） 线段树（Segment Tree）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>9 min read <time class='article__date' datetime='2021-10-09T19:00:50+08:00'>Oct 9, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（三） 线段树（Segment Tree）</h2> <p class='article__excerpt'>二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "双指针问题（一）对撞指针和快慢指针",
      "category" : "",
      "tags"     : "算法, 指针, 链表, and 数据结构",
      "url"      : "/2021/10/08/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%B8%80-%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88%E5%92%8C%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/",
      "date"     : "Oct 8, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a></li>\n  <li><a href=\"#双指针问题\" id=\"markdown-toc-双指针问题\">双指针问题</a>    <ol>\n      <li><a href=\"#对撞指针\" id=\"markdown-toc-对撞指针\">对撞指针</a></li>\n      <li><a href=\"#快慢指针\" id=\"markdown-toc-快慢指针\">快慢指针</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>双指针是在遍历的过程中，使用两个方向相同或相反的指针进行扫描，从而达到相应目的的算法。</p>\n\n<p>广义上来说，双指针是指用两个变量在线性结构上遍历而解决的问题。</p>\n\n<p>狭义上说：</p>\n\n<ul>\n  <li>对于数组，指两个变量在数组上相向移动解决的问题；</li>\n  <li>对于链表，指两个变量在链表上同向移动解决的问题，也称为「快慢指针」问题。</li>\n</ul>\n\n<h2 id=\"双指针问题\">双指针问题</h2>\n<h3 id=\"对撞指针\">对撞指针</h3>\n<p>对撞指针将最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，从两头向中间进行数组遍历</p>\n\n<p>对撞指针适用于<strong>有序的数组和字符串</strong></p>\n\n<p>对撞指针的时间复杂度为\\(O(n)\\)</p>\n\n<p><a href=\"https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\">剑指 Offer 21</a></p>\n\n<p>此题要求分奇偶调整数组的顺序，我们可以用左指针寻找奇数，右指针寻找偶数，当左指针找到偶数且右指针找到奇数时，对调两数。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">exchange</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">r</span><span class=\"o\">--</span><span class=\"p\">;</span>\n        <span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">],</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><a href=\"https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/\">剑指 Offer 57</a></p>\n\n<p>此题要求寻找和为\\(target\\)数对，由于此题数组已经做好排序，我们可以确定</p>\n\n<p>若数对\\((nums[i+1],nums[j])&lt;target\\)</p>\n\n<p>则必有\\((nums[i],nums[j])&lt;target\\)</p>\n\n<p>同理，若数对\\((nums[i],nums[j])&gt;target\\)</p>\n\n<p>则\\((nums[i+1],nums[j])&gt;target\\)</p>\n\n<p>因此这道题也可以用对撞指针求解，当\\(nums[l]+nums[r]&lt;target\\)时，\\(l\\)向右移动，反之，\\(nums[l]+nums[r]&gt;target\\)时，r向左移动，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">twoSum</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">&lt;</span><span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">&lt;</span><span class=\"n\">r</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span><span class=\"o\">&lt;</span><span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">&lt;</span><span class=\"n\">r</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">r</span><span class=\"o\">--</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span><span class=\"o\">==</span><span class=\"n\">target</span><span class=\"p\">){</span>\n            <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]);</span>\n            <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]);</span>\n            <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"快慢指针\">快慢指针</h3>\n<p>快慢指针在序列中定义了一对不同速度的指针，以进行单向序列问题的求解。</p>\n\n<p>快慢指针的时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)</p>\n\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">141. 环形链表</a></p>\n\n<p>此题要判断链表是否有环，可以定义一个快指针和一个慢指针，随后进行移动，若快指针可以追上慢指针，则表示链表一定有环，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">bool</span> <span class=\"nf\">hasCycle</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"k\">do</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n            <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">!=</span> <span class=\"n\">p2</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">142. 环形链表 II</a></p>\n\n<p>此题需要在求出是否成环的同时找到入环的第一个节点，我们可以根据快指针速度始终是慢指针的两倍这一条件进行推理</p>\n\n<p><img src=\"/images/posts/doublepoint1.png\" alt=\"在这里插入图片描述\" /></p>\n\n<p>假设快慢指针在\\(bc\\)交点相遇，此时慢指针走的距离应该是\\(a+b\\)，而快指针已经走了\\(a+b+k(b+c)\\)\n又有快指针的速度是慢指针的两倍，因此</p>\n\n<p>\\(a+b+k(b+c)=2(a+b)\\)，</p>\n\n<p>即\\(a=k(b+c)-b=(k-1)(b+c)+c\\)</p>\n\n<p>因此，当快慢指针相遇时，相遇点距离入环节点的距离总是\\(a\\)，因此我们可以再用一个指针\\(cur\\)寻找入环节点，同时更新\\(cur\\)和慢指针，当二者相遇时，相遇节点即入环节点。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"nf\">detectCycle</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"k\">do</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n            <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">!=</span> <span class=\"n\">p2</span><span class=\"p\">);</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">cur</span> <span class=\"o\">!=</span> <span class=\"n\">p1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">cur</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/08/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%B8%80-%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88%E5%92%8C%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/'> <img src='https://api.dujin.org/bing/1920.php' alt='双指针问题（一）对撞指针和快慢指针'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>3 min read <time class='article__date' datetime='2021-10-08T21:14:13+08:00'>Oct 8, 2021</time> </span> </div><h2 class='article__title'>双指针问题（一）对撞指针和快慢指针</h2> <p class='article__excerpt'>双指针是在遍历的过程中，使用两个方向相同或相反的指针进行扫描，从而达到相应目的的算法。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/指针' class='article__tag'>指针</a>  <a href='/tag/链表' class='article__tag'>链表</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "二叉树基础（二）二叉搜索树（BST）",
      "category" : "",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/2021/10/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/",
      "date"     : "Oct 5, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a>    <ol>\n      <li><a href=\"#性质\" id=\"markdown-toc-性质\">性质</a></li>\n      <li><a href=\"#结构\" id=\"markdown-toc-结构\">结构</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#代码\" id=\"markdown-toc-代码\">代码</a>    <ol>\n      <li><a href=\"#基本操作\" id=\"markdown-toc-基本操作\">基本操作</a>        <ol>\n          <li><a href=\"#find\" id=\"markdown-toc-find\">$find()$</a></li>\n          <li><a href=\"#insert\" id=\"markdown-toc-insert\">$insert()$</a></li>\n          <li><a href=\"#delete\" id=\"markdown-toc-delete\">$delete()$</a></li>\n        </ol>\n      </li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p><strong>二叉搜索树（Binary Search Tree）</strong>（又：二叉查找树，二叉排序树），它或者是一棵空树，或者是具有下列性质的二叉树：\n若它的左子树非空，则左子树上所有结点的值均小于它的根结点的值； \n若它的右子树非空，则右子树上所有结点的值均大于它的根结点的值；\n它的左、右子树也分别是二叉搜索树。\n二叉搜索树作为一种经典的数据结构，既有快速插入与删除操作的特点，又有快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p>\n<h3 id=\"性质\">性质</h3>\n<p>二叉搜索树有以下性质：</p>\n<ul>\n  <li>若左子树非空，则左子树上的所有节点值均小于根节点的值。</li>\n  <li>若右子树非空，则右子树上的所有节点值均小于根节点的值。</li>\n  <li>左右子树是二叉搜索树。</li>\n</ul>\n\n<h3 id=\"结构\">结构</h3>\n<p>BST是以二叉树来构建的，除了key和位置数据之外，每个结点还包含属性lchild、rchild，如果某个孩子结点不存在，则相应属性的值为空。</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">;</span>                               <span class=\"c1\">// 数据</span>\n    <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"o\">*</span><span class=\"n\">lchild</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">rchild</span><span class=\"p\">;</span>  \t\t\t<span class=\"c1\">// 左右子树</span>\n<span class=\"p\">}</span> <span class=\"o\">*</span> <span class=\"n\">BST</span><span class=\"p\">,</span> <span class=\"n\">BSTNode</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<h2 id=\"代码\">代码</h2>\n<h3 id=\"基本操作\">基本操作</h3>\n\n<p>BST的构造和析构与普通二叉树相同，这里不多赘述。相比于普通二叉树，BST的主要功能增加了查找，插入和删除</p>\n\n<h4 id=\"find\">$find()$</h4>\n<p>$find()$函数的作用是查找某一个数据值已知的节点是否在树中，并返回节点值。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">BST</span> <span class=\"nf\">find</span><span class=\"p\">(</span><span class=\"n\">BST</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">){</span>\n    <span class=\"n\">BST</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h4 id=\"insert\">$insert()$</h4>\n<p>$insert()$函数的作用是在树中插入一个节点。BST中所有的节点都是作为叶子节点插入的，因此在创建节点$p$后，要找到合适的父节点$f$并插入其中。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">bool</span> <span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"n\">BST</span><span class=\"o\">&amp;</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">BST</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>                  <span class=\"c1\">// 记录f为p的父节点</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>                           <span class=\"c1\">// 查找data是否已经在树中</span>\n\n    <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">BST</span><span class=\"p\">)</span> <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">BSTNode</span><span class=\"p\">));</span>\n    <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">;</span>             <span class=\"c1\">// 创建节点</span>\n\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h4 id=\"delete\">$delete()$</h4>\n<p>二叉搜索树进行删除操作后，仍然要保证它的排序正确，因此我们的删除操作分为三种情况：</p>\n\n<ul>\n  <li>待删除节点无左孩子，则用右孩子代替其位置</li>\n  <li>待删除节点无右孩子，则用左孩子代替其位置</li>\n  <li>待删除节点拥有左右孩子，则用左子树最大节点或右子树最小节点代替其位置</li>\n</ul>\n\n<p>代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">bool</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"n\">BST</span><span class=\"o\">&amp;</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"n\">BST</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>                  <span class=\"c1\">// 记录f为p的父节点</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>                           <span class=\"c1\">// 查找data的位置</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">p</span><span class=\"p\">)</span>  <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>       <span class=\"c1\">// 若未找到，则返回false</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"c1\">// 情况1</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">tree</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"nf\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">){</span>        <span class=\"c1\">// 情况2</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">tree</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span><span class=\"p\">{</span>                       <span class=\"c1\">// 情况3</span>\n        <span class=\"n\">BST</span> <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">,</span> <span class=\"n\">fl</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">)</span> <span class=\"n\">fl</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"p\">,</span><span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">==</span> <span class=\"n\">tmp</span><span class=\"p\">)</span> <span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">==</span> <span class=\"n\">tmp</span><span class=\"p\">)</span> <span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2021/10/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/'> <img src='/images/covers/数据结构-cover1.png' alt='二叉树基础（二）二叉搜索树（BST）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-05T01:14:28+08:00'>Oct 5, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（二）二叉搜索树（BST）</h2> <p class='article__excerpt'>二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（三）股票问题系列",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 29, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#121-买卖股票的最佳时机\" id=\"markdown-toc-121-买卖股票的最佳时机\">121. 买卖股票的最佳时机</a>    <ol>\n      <li><a href=\"#状态转移方程\" id=\"markdown-toc-状态转移方程\">状态转移方程</a>        <ol>\n          <li><a href=\"#如何表示price_min\" id=\"markdown-toc-如何表示price_min\">如何表示$price_{min}$</a></li>\n          <li><a href=\"#边界条件\" id=\"markdown-toc-边界条件\">边界条件</a></li>\n        </ol>\n      </li>\n      <li><a href=\"#代码\" id=\"markdown-toc-代码\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#122-买卖股票的最佳时机-ii\" id=\"markdown-toc-122-买卖股票的最佳时机-ii\">122. 买卖股票的最佳时机 II</a>    <ol>\n      <li><a href=\"#状态转移方程-1\" id=\"markdown-toc-状态转移方程-1\">状态转移方程</a></li>\n      <li><a href=\"#代码-1\" id=\"markdown-toc-代码-1\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#714-买卖股票的最佳时机含手续费\" id=\"markdown-toc-714-买卖股票的最佳时机含手续费\">714. 买卖股票的最佳时机含手续费</a>    <ol>\n      <li><a href=\"#状态转移方程-2\" id=\"markdown-toc-状态转移方程-2\">状态转移方程</a></li>\n      <li><a href=\"#代码-2\" id=\"markdown-toc-代码-2\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#309-最佳买卖股票时机含冷冻期\" id=\"markdown-toc-309-最佳买卖股票时机含冷冻期\">309. 最佳买卖股票时机含冷冻期</a>    <ol>\n      <li><a href=\"#状态转移方程-3\" id=\"markdown-toc-状态转移方程-3\">状态转移方程</a></li>\n      <li><a href=\"#代码-3\" id=\"markdown-toc-代码-3\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#123-买卖股票的最佳时机-iii\" id=\"markdown-toc-123-买卖股票的最佳时机-iii\">123. 买卖股票的最佳时机 III</a>    <ol>\n      <li><a href=\"#思路\" id=\"markdown-toc-思路\">思路</a></li>\n      <li><a href=\"#代码-4\" id=\"markdown-toc-代码-4\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#188-买卖股票的最佳时机-iv\" id=\"markdown-toc-188-买卖股票的最佳时机-iv\">188. 买卖股票的最佳时机 IV</a></li>\n  <li><a href=\"#股票问题的一般通解\" id=\"markdown-toc-股票问题的一般通解\">股票问题的一般通解</a>    <ol>\n      <li><a href=\"#状态转移方程-4\" id=\"markdown-toc-状态转移方程-4\">状态转移方程</a>        <ol>\n          <li><a href=\"#边界条件-1\" id=\"markdown-toc-边界条件-1\">边界条件</a></li>\n        </ol>\n      </li>\n    </ol>\n  </li>\n  <li><a href=\"#结束语\" id=\"markdown-toc-结束语\">结束语</a></li>\n</ol>\n\n<h2 id=\"121-买卖股票的最佳时机\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">121. 买卖股票的最佳时机</a></h2>\n<h3 id=\"状态转移方程\">状态转移方程</h3>\n<p>我们可以用$dp[i]$来表示，在前$i$日我们可以得到的最大利润，那么我们第$i$日的操作有两种选择：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.我们在第i日卖出得到的利润可能比之前的利润（dp[i-1]）更高\n2.我们之前的利润要比现在更高，不用进行任何操作\n</code></pre></div></div>\n\n<p>对于情况1，我们得到状态转移方程$dp[i]=prices[i]-price_{min}$\n而对于情况2，我们有$dp[i]=dp[i-1]$\n综合两种情况，也就得到此题的状态转移方程：</p>\n\n<p>$dp[i]=max(dp[i-1],prices[i]-price_{min})$</p>\n\n<p>那么剩下的问题就在于如何表示$price_{min}$。</p>\n\n<h4 id=\"如何表示price_min\">如何表示$price_{min}$</h4>\n<p>我们发现，$price_{min}$的计算也是一个无后效性的问题，我们同样可以通过动态规划来求解，用$dp_{price_{min}}[i]$来表示前i日股票的最低价格，则$dp_{price_{min}}[i]$的状态转移方程可以写成：</p>\n\n<p>$dp_{price_{min}}[i]$ = $min(prices[i],dp_{price_{min}}[i-1])$</p>\n\n<p>可能这时候你就要说了，你这不是脱了裤子放屁吗？那我们不妨换一个思维方式，还是上面的状态转移方程不变，<strong>我们用$dp[i][j]$表示前$i$天手上有$j$个股票时我们的最大利润。</strong> 这时候你不妨停下来思考一会，该如何写出状态转移方程呢？</p>\n\n<p>联立上面两个转移方程，得到$dp[i][j]$的状态转移方程：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$\n$dp[i][1] = max(-prices[i], dp[i - 1][1]);$</p>\n\n<p>没错，此时的$dp[i][1]$就是之前我们的开销，用来辅助我们计算第$i$天的最大利润，也就是$dp[i][0]$</p>\n\n<h4 id=\"边界条件\">边界条件</h4>\n<p>$dp[0][0]$表示在第0天我们手上有0支股票时的最大利润，因此$dp[0][0]=0$</p>\n\n<p>$dp[0][1]$表示在第0天我们手上有1支股票时的最大利润，因此$dp[0][0]=-prices[0]$</p>\n\n<h3 id=\"代码\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> \n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>篇幅关系，空间复杂度的优化留给读者自己思考，我这里不作展开</p>\n\n<h2 id=\"122-买卖股票的最佳时机-ii\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\">122. 买卖股票的最佳时机 II</a></h2>\n<h3 id=\"状态转移方程-1\">状态转移方程</h3>\n<p>122.题与121.题的不同点在于，122.是可以无限进行购买操作的，相应的，我们的状态转移方程也有所改变。</p>\n\n<p>根据我们第一题的状态转移方程，在第一题里，一但我们前面卖出了股票，下次再想购买股票时，总利润便会变成$-prices[i]$，但在这道题中，由于我们不再受购买次数的限制，因此我们的利润就可以一直累计下去，如何理解这种累计呢？</p>\n\n<p>在前$i-1$天，我们的最大利润达到了$dp[i-1][0]$，而在第$i$天我们要购入股票，此时的利润就会变为$dp[i-1][0]-prices[i]$</p>\n\n<p>即$dp[i][1]$的状态转移方程变为：</p>\n\n<p>$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$</p>\n\n<p>读者应该也注意到，在我们把状态转移方程分成两部分后，我们对转移方程的解读方式也转变了，这里我再次阐述一遍，$dp[i][0]$表示手上没有股票时的最大利润，$dp[i][1]$表示手上有一枚股票时的最大利润。</p>\n\n<p>综上，状态转移方程为：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$\n$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$</p>\n\n<p>边界条件与之前相同。</p>\n\n<h3 id=\"代码-1\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"714-买卖股票的最佳时机含手续费\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\">714. 买卖股票的最佳时机含手续费</a></h2>\n<h3 id=\"状态转移方程-2\">状态转移方程</h3>\n<p>如果你认真阅读了题714.并理解了题122.那这道题你其实可以直接过的，因为这道题和题122.的不同之处就在于，它在售卖时多了手续费这个固定消耗，因此在决定卖出股票的第$i$天里，如果收益不足以抵消掉手续费，那我们会选择之前的利润作为最优解，即：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$</p>\n\n<p>整体的转移方程表示为：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$\n$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$</p>\n\n<p>边界条件仍与之前相同</p>\n\n<h3 id=\"代码-2\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">fee</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fee</span><span class=\"p\">),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"309-最佳买卖股票时机含冷冻期\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">309. 最佳买卖股票时机含冷冻期</a></h2>\n<h3 id=\"状态转移方程-3\">状态转移方程</h3>\n<p>这道题的变化在于，之前我们只有$(0)$卖出、$(1)$买入两种状态，但这道题引入了一个新的新的状态$(2)$冷冻期，而这个冷冻期状态是在卖出操作后出现，如果我们用$dp[i][2]$来表示当我们在第$i$天的冷冻期收益，则$dp[i][2]$可以用$dp$表示为：</p>\n\n<p>$dp[i][2] = dp[i-1][0]$</p>\n\n<p>买入状态的转移方程也有所变化，因为此题中买入状态必须由冷冻期状态进入，也就是：</p>\n\n<p>$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$</p>\n\n<p>最后，综合三式就可以得到我们新的状态转移方程：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])$\n$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$\n$dp[i][2] = dp[i - 1][0]$</p>\n\n<p>边界条件仍然不变</p>\n\n<h3 id=\"代码-3\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">3</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"c1\">//</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"123-买卖股票的最佳时机-iii\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/\">123. 买卖股票的最佳时机 III</a></h2>\n<h3 id=\"思路\">思路</h3>\n<p>如果没有前面的铺垫直接来看这道题，难度瞬间就高起来了。但现在带着前面的经验再来对比这道题，我们会发现这道题和题121. 题122.有着很大的关联。</p>\n\n<p>假设在第$i$天卖出了股票，当我们是第一次或第二次操作时，我们的利润是可以积累的。但如果是在第三次操作，那么我们就要重新累计利润了。</p>\n\n<p>我们不妨将$dp$升到三维数组，用第三维来区分第一次操作和第二次操作，即得到代码如下：</p>\n<h3 id=\"代码-4\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n    <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>这个代码并不优雅，但对于问题的解决无疑是直接而有效的</p>\n\n<h2 id=\"188-买卖股票的最佳时机-iv\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/\">188. 买卖股票的最佳时机 IV</a></h2>\n\n<p>当问题扩充到$k$时，我们解决题123.的思路仍然有效，我们可以用初始化边界为$0$，再用一个$for$循环写出结果。</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span> <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">1100</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"mi\">110</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">};</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">k</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span>  <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">k</span> <span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span>\n            <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]),</span>\n            <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]);</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">k</span><span class=\"p\">];</span>\n <span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"股票问题的一般通解\">股票问题的一般通解</h2>\n<h3 id=\"状态转移方程-4\">状态转移方程</h3>\n<p>股票问题的三个限定条件是</p>\n\n<ul>\n  <li>当前天数$i$</li>\n  <li>手持股票$j$</li>\n  <li>允许的最大操作次数$k$</li>\n</ul>\n\n<p>我们设在第$i$天，手持股票为$j$，操作次数为$k$时我们的利润为$dp[i][j][k]$，视每次购买股票为进行一次操作，则我们的状态转移方程为：</p>\n\n<p>$dp[i][0][k] = max(dp[i-1][1][k] + prices[i], dp[i-1][0][k])$\n$dp[i][1][k] = max(dp[i-1][0][k-1] - prices[i], dp[i-1][1][k])$</p>\n\n<h4 id=\"边界条件-1\">边界条件</h4>\n<p>$dp[0][1][k] = -prices[0]$\n其余值都为0</p>\n\n<h2 id=\"结束语\">结束语</h2>\n<p>股票问题系列和打家劫舍系列的不同点在于，股票问题的每一个系列问题都对状态转移方程进行了改动。面临一道动态规划问题时，要想迅速找到子问题并写出状态转移方程，关键还是要多了解不同的动归题型。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/'> <img src='/images/covers/village.jpg' alt='动态规划（三）股票问题系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2021-09-29T20:29:46+08:00'>Sep 29, 2021</time> </span> </div><h2 class='article__title'>动态规划（三）股票问题系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "二叉树基础（一）二叉树的概念",
      "category" : "数据结构基础",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/",
      "date"     : "Sep 28, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a>    <ol>\n      <li><a href=\"#二叉树的定义\" id=\"markdown-toc-二叉树的定义\">二叉树的定义</a></li>\n      <li><a href=\"#基本形态\" id=\"markdown-toc-基本形态\">基本形态</a></li>\n      <li><a href=\"#特殊类型\" id=\"markdown-toc-特殊类型\">特殊类型</a></li>\n      <li><a href=\"#相关术语\" id=\"markdown-toc-相关术语\">相关术语</a></li>\n      <li><a href=\"#性质\" id=\"markdown-toc-性质\">性质</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#二叉树的c实现\" id=\"markdown-toc-二叉树的c实现\">二叉树的C++实现</a>    <ol>\n      <li><a href=\"#二叉树的顺序存储\" id=\"markdown-toc-二叉树的顺序存储\">二叉树的顺序存储</a>        <ol>\n          <li><a href=\"#实现代码\" id=\"markdown-toc-实现代码\">实现代码</a></li>\n        </ol>\n      </li>\n      <li><a href=\"#二叉树的链式存储\" id=\"markdown-toc-二叉树的链式存储\">二叉树的链式存储</a>        <ol>\n          <li><a href=\"#实现代码-1\" id=\"markdown-toc-实现代码-1\">实现代码</a></li>\n        </ol>\n      </li>\n      <li><a href=\"#二叉树的递归遍历\" id=\"markdown-toc-二叉树的递归遍历\">二叉树的递归遍历</a>        <ol>\n          <li><a href=\"#先序遍历dlr\" id=\"markdown-toc-先序遍历dlr\">先序遍历（DLR）</a></li>\n          <li><a href=\"#中序遍历ldr\" id=\"markdown-toc-中序遍历ldr\">中序遍历（LDR）</a></li>\n          <li><a href=\"#后序遍历lrd\" id=\"markdown-toc-后序遍历lrd\">后序遍历（LRD）</a></li>\n        </ol>\n      </li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>二叉树（Binary tree）是树形结构的一个重要类型。许多实际问题抽象出来的数据结构往往是二叉树形式，即使是一般的树也能简单地转换为二叉树，而且二叉树的存储结构及其算法都较为简单，因此二叉树显得特别重要。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。</p>\n\n<h3 id=\"二叉树的定义\">二叉树的定义</h3>\n<p>二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。二叉树的递归定义为：二叉树是一棵空树，或者是一棵由一个根节点和两棵互不相交的，分别称作根的左子树和右子树组成的非空树；左子树和右子树又同样都是二叉树</p>\n\n<h3 id=\"基本形态\">基本形态</h3>\n<p><img src=\"/images/posts/tree1.png\" alt=\"在这里插入图片描述\" /></p>\n<ul>\n  <li>空二叉树</li>\n  <li>只有一个根节点的二叉树</li>\n  <li>根节点只有左子树的二叉树</li>\n  <li>根节点只有右子树的二叉树</li>\n  <li>根节点既有左子树，又有右子树的<strong>完全二叉树</strong>\n    <h3 id=\"特殊类型\">特殊类型</h3>\n  </li>\n  <li>满二叉树：只有度为0和2的节点，且度为0的结点在同一层上</li>\n  <li>完全二叉树：深度为k且每一个节点都与深度为k的满二叉树中编号从1到n的结点一一对应\n<img src=\"/images/posts/tree2.png\" alt=\"在这里插入图片描述\" />\n    <h3 id=\"相关术语\">相关术语</h3>\n  </li>\n  <li>节点：包含一个数据元素及若干指向子树分支的信息</li>\n  <li>节点的度：一个节点拥有子树的数目</li>\n  <li>叶节点：也称为终端节点，没有子树的节点或度为0的节点</li>\n  <li>分支节点：也称为非终端节点，度不为0的节点</li>\n  <li>树的度：树中所有节点度的最大值</li>\n  <li>节点的层次：从根节点开始，根节点为第0层，根节点的子节点为第1层，依此类推</li>\n  <li>树的深度：也称树的高度，树中所有节点层次的最大值</li>\n  <li>有序树：如果树中各棵子树的次序有先后次序，则该树为有序树</li>\n  <li>无序树：如果树中各棵子树的次序没有先后次序，则该树为无序树</li>\n  <li>森林：由m（m≥0）棵互不相交的树构成一片森林。如果把一棵非空的树的根结点删除，则该树就变成了一片森林，森林中的树由原来根结点的各棵子树构成\n    <h3 id=\"性质\">性质</h3>\n  </li>\n  <li>一棵二叉树的第i层最多有$2^i$个节点 $(i≥0)$</li>\n  <li>深度为k的二叉树最多有$2^{k+1}-1$个节点 $(k≥0)$</li>\n  <li>对于1棵二叉树，度为0的节点为$n_0$，度为2的节点为$n_2$，则$n_0=n_2+1$</li>\n  <li>满二叉树定理：非空满二叉树的叶子节点数等于分支节点数$+1$</li>\n  <li>满二叉树定理推论：在一棵具有$n$个结点的二叉树中,所有结点的空子树等于$n+1$</li>\n  <li>$n$个节点的完全二叉树高度为$log_2(n+1)$，深度为$log_2(n+1)-1$</li>\n</ul>\n\n<h2 id=\"二叉树的c实现\">二叉树的C++实现</h2>\n\n<h3 id=\"二叉树的顺序存储\">二叉树的顺序存储</h3>\n\n<p>我们可以使用一个数组来存储所有的节点，按数组下标进行存储，根节点存储在下标\\(0\\)处，\n其左孩子存储于下标\\(2*0+1\\)，右孩子存储于下标\\(2*0+2\\)….依此类推，对于下标为\\(i\\)的节点，左右孩子分别存储于下标为\\({2*i+1}\\)和\\({2*i+2}\\)处。</p>\n<h4 id=\"实现代码\">实现代码</h4>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"kt\">int</span> <span class=\"n\">BinaryTree</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">];</span>\n<span class=\"kt\">void</span> <span class=\"nf\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">MAX</span><span class=\"p\">)</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"n\">cin</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"二叉树的链式存储\">二叉树的链式存储</h3>\n<p>二叉树的顺序存储结构一般适用于完全二叉树，通常我们使用链式存储结构表示二叉树。</p>\n<h4 id=\"实现代码-1\">实现代码</h4>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">;</span>                     <span class=\"c1\">// 数据</span>\n    <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"o\">*</span><span class=\"n\">lchild</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">rchild</span><span class=\"p\">;</span> <span class=\"c1\">// 左右子树</span>\n<span class=\"p\">}</span> <span class=\"o\">*</span> <span class=\"n\">BinaryTree</span><span class=\"p\">,</span> <span class=\"n\">BtNode</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"o\">&amp;</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"n\">cin</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">input</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BtNode</span><span class=\"p\">;</span>\n    <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h3 id=\"二叉树的递归遍历\">二叉树的递归遍历</h3>\n<h4 id=\"先序遍历dlr\">先序遍历（DLR）</h4>\n<p>若二叉树为空，则空操作，否则：</p>\n\n<ol>\n  <li>访问当前节点</li>\n  <li>先序遍历左子树</li>\n  <li>先序遍历右子树</li>\n</ol>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">DLR</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"n\">DLR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n        <span class=\"n\">DLR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4 id=\"中序遍历ldr\">中序遍历（LDR）</h4>\n<p>若二叉树为空，则空操作，否则：</p>\n\n<ol>\n  <li>中序遍历左子树</li>\n  <li>访问当前节点</li>\n  <li>中序遍历右子树</li>\n</ol>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">LDR</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">LDR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"n\">LDR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4 id=\"后序遍历lrd\">后序遍历（LRD）</h4>\n<p>若二叉树为空，则空操作，否则：</p>\n\n<ol>\n  <li>后序遍历左子树</li>\n  <li>后序遍历右子树</li>\n  <li>访问当前节点</li>\n</ol>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">LRD</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">LRD</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n        <span class=\"n\">LRD</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9F%BA%E7%A1%80/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/'> <img src='/images/covers/数据结构-cover1.png' alt='二叉树基础（一）二叉树的概念'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2021-09-28T13:58:19+08:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（一）二叉树的概念</h2> <p class='article__excerpt'>二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（二）最优子序列系列",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 28, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#动态规划核心思想\" id=\"markdown-toc-动态规划核心思想\">动态规划核心思想</a></li>\n  <li><a href=\"#198-打家劫舍\" id=\"markdown-toc-198-打家劫舍\">198. 打家劫舍</a></li>\n</ol>\n\n<h2 id=\"动态规划核心思想\">动态规划核心思想</h2>\n<p>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p>\n\n<p>动态规划基础</p>\n\n<p>我们可以举个例子：</p>\n\n<blockquote>\n  <p>A: 1+1+1+1+1+1+1+1 = ?</p>\n\n  <p>B ( 计算 ) : 8</p>\n\n  <p>A: 在上面等式的左边写上 “1+” 呢？</p>\n\n  <p>B (脱口而出): 9</p>\n\n  <p>A: 你怎么这么快就得到答案了？</p>\n\n  <p>B: 只要在8的基础上加1就好了</p>\n\n  <p>A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间</p>\n</blockquote>\n\n<h2 id=\"198-打家劫舍\"><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. 打家劫舍</a></h2>\n\n<ol>\n  <li>只有一间房屋时，我们选择偷这间房屋</li>\n  <li>存在两间房屋时，选择偷两间中较大的那间</li>\n  <li>如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间</li>\n  <li>将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：\n    <ol>\n      <li>偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和</li>\n      <li>不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额</li>\n    </ol>\n  </li>\n</ol>\n\n<p>我们总会选择1、2中可以得到更高金额的选项，这时我们用$d[i]$来表示偷窃前i间房子的总金额，并且用$d[i]$来表示选项1、2:</p>\n\n\\[\\begin{equation}\n\\left\\{\n\\begin{aligned}\n%\\nonumber\n&amp;d[i] = d[i-2] + nums[i], \\\\\n&amp;d[i] = d[i-1].\n\\end{aligned}\n\\right.\n\\end{equation}\\]\n\n<p>hello</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/'> <img src='/images/covers/village.jpg' alt='动态规划（二）最优子序列系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-28T11:12:38+08:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>动态规划（二）最优子序列系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（一）打家劫舍系列",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 27, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#动态规划核心思想\" id=\"markdown-toc-动态规划核心思想\">动态规划核心思想</a></li>\n  <li><a href=\"#198-打家劫舍\" id=\"markdown-toc-198-打家劫舍\">198. 打家劫舍</a></li>\n</ol>\n\n<h2 id=\"动态规划核心思想\">动态规划核心思想</h2>\n<p>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p>\n\n<p>我们可以举个例子：</p>\n\n<blockquote>\n  <p>A: 1+1+1+1+1+1+1+1 = ?</p>\n\n  <p>B (计算) : 8</p>\n\n  <p>A: 在上面等式的左边写上 “1+” 呢？</p>\n\n  <p>B (脱口而出): 9</p>\n\n  <p>A: 你怎么这么快就得到答案了？</p>\n\n  <p>B: 只要在8的基础上加1就好了</p>\n\n  <p>A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间</p>\n</blockquote>\n\n<h2 id=\"198-打家劫舍\"><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. 打家劫舍</a></h2>\n\n<ol>\n  <li>只有一间房屋时，我们选择偷这间房屋</li>\n  <li>存在两间房屋时，选择偷两间中较大的那间</li>\n  <li>如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间</li>\n  <li>将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：\n    <ol>\n      <li>偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和</li>\n      <li>不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额</li>\n    </ol>\n  </li>\n</ol>\n\n<p>我们总会选择1、2中可以得到更高金额的选项，这时我们用\\(d[i]\\)来表示偷窃前i间房子的总金额，并且用\\(d[i]\\)来表示选项1、2:</p>\n\n\\[\\begin{equation}\n\\left\\{\n\\begin{aligned}\n%\\nonumber\n&amp;d[i] = d[i-2] + nums[i], \\\\\n&amp;d[i] = d[i-1].\n\\end{aligned}\n\\right.\n\\end{equation}\\]\n\n<p>hello</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/'> <img src='/images/covers/village.jpg' alt='动态规划（一）打家劫舍系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-27T20:12:45+08:00'>Sep 27, 2021</time> </span> </div><h2 class='article__title'>动态规划（一）打家劫舍系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/算法' class='article__tag'>算法</a>  <a href='/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "阳光体育一键汉姆",
      "category" : "",
      "tags"     : "计算机网络",
      "url"      : "/2019/10/11/%E9%98%B3%E5%85%89%E4%BD%93%E8%82%B2%E4%B8%80%E9%94%AE%E6%B1%89%E5%A7%86/",
      "date"     : "Oct 11, 2019",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#登录过程\" id=\"markdown-toc-登录过程\">登录过程</a></li>\n  <li><a href=\"#申请跑步\" id=\"markdown-toc-申请跑步\">申请跑步</a></li>\n  <li><a href=\"#结束跑步\" id=\"markdown-toc-结束跑步\">结束跑步</a></li>\n  <li><a href=\"#密码表\" id=\"markdown-toc-密码表\">密码表</a></li>\n</ol>\n\n<p>这篇博客介绍了一种阳光体育平台下基于HTTP请求完成汉姆的方式，与虚拟定位方式相比，该种方式速度更快，使用更加便捷</p>\n\n<p>此博客基于李叶学长的项目启发完成，<a href=\"https://github.com/HackerLiye/fuckhanmu\">点此链接</a>传送至该项目</p>\n\n<h2 id=\"登录过程\">登录过程</h2>\n\n<p>登录过程是<strong>获取<code class=\"language-plaintext highlighter-rouge\">token</code>的过程</strong>，在这个过程中需要用到用户的<code class=\"language-plaintext highlighter-rouge\">IMEI</code></p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">IMEI</code>是一个<strong>32位16进制数</strong>，可以在阳光体育平台的登录过程进行抓包获得</p>\n\n<p>登录过程中，我们要将<code class=\"language-plaintext highlighter-rouge\">IMEI</code>作为参数代入，如下：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://client3.aipao.me/api/{token}/QM_Users/Login_AndroidSchool?IMEICode=00000000000000000000000000000000\n</code></pre></div></div>\n\n<p>同时，我们需要在header中加入当前的<strong>乐跑版本号<code class=\"language-plaintext highlighter-rouge\">version</code></strong>，<code class=\"language-plaintext highlighter-rouge\">version</code>一般为2.40即可</p>\n\n<p>该http请求会获取一个<code class=\"language-plaintext highlighter-rouge\">json</code>，其中<code class=\"language-plaintext highlighter-rouge\">Data</code>下的<code class=\"language-plaintext highlighter-rouge\">token</code>即为我们需要获取的值</p>\n\n<h2 id=\"申请跑步\">申请跑步</h2>\n\n<p>跑步过程用到的请求基于上文的<code class=\"language-plaintext highlighter-rouge\">token</code>，请求的链接及参数如下</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://client3.aipao.me/api/{token}/QM_Runs/SRS?S1=30.534737&amp;S2=114.367785&amp;S3=2000\n</code></pre></div></div>\n\n<p>可以注意到，其存在三个参数S1、S2和S3，分别代表着跑步所在的<strong>经纬度</strong>和<strong>路程</strong></p>\n\n<p>上述链接中所采用的参数为武汉大学信息学部操场及2000米路程</p>\n\n<p>发送该请求后，即可<strong>获得<code class=\"language-plaintext highlighter-rouge\">RunId</code>并进入跑步状态</strong></p>\n\n<h2 id=\"结束跑步\">结束跑步</h2>\n\n<p>在李叶学长的代码中，是存在等待跑步结束这一过程的，这是为了保证数据的准确性和一致性。\n而在实测中发现，我们其实不必等待跑步的过程，直接请求跑步结束即可提交汉姆成绩。</p>\n\n<p>此时请求的链接如下</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://client3.aipao.me/api/{token}/QM_Runs/ES\n</code></pre></div></div>\n\n<p>此时需要提交的参数较多，我们逐一讲解</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>参数</th>\n      <th>含义</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>S1</td>\n      <td>RunId，由申请跑步时获得</td>\n    </tr>\n    <tr>\n      <td>S4</td>\n      <td>跑步消耗时间，合理即可</td>\n    </tr>\n    <tr>\n      <td>S5</td>\n      <td>实际跑步距离，一般比理论距离多1到2米</td>\n    </tr>\n    <tr>\n      <td>S5</td>\n      <td>实际跑步距离，一般比理论距离多1到2米</td>\n    </tr>\n    <tr>\n      <td>S8</td>\n      <td>密码表，后文会介绍</td>\n    </tr>\n    <tr>\n      <td>S9</td>\n      <td>步数，合理即可</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"密码表\">密码表</h2>\n\n<p>在结束跑步的参数中，凡是整数类参数都以密码表的方式进行加密。\n其原理类似凯撒密码，将数字和字母一一对应，提交时同时提交密文和密码表</p>\n\n<p>提交时，我们要<strong>保证密码表与数值正确对应</strong>，方可提交成功</p>\n\n<p>跑步距离加密示范</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>实际值</th>\n      <th>加密值</th>\n      <th>密码表</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>2000</td>\n      <td>caaa</td>\n      <td>abcdefghijklmnopqrstuvwxyz</td>\n    </tr>\n    <tr>\n      <td>246</td>\n      <td>oqs</td>\n      <td>mnopqrstuvwxyzabcdefghijkl</td>\n    </tr>\n  </tbody>\n</table>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/2019/10/11/%E9%98%B3%E5%85%89%E4%BD%93%E8%82%B2%E4%B8%80%E9%94%AE%E6%B1%89%E5%A7%86/'> <img src='https://src.onlinedown.net/images/h_imges/wdj/3/logo/c76a697a57cfc446c777513a033e19b1_256_256.png' alt='阳光体育一键汉姆'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2019-10-11T11:59:11+08:00'>Oct 11, 2019</time> </span> </div><h2 class='article__title'>阳光体育一键汉姆</h2> <p class='article__excerpt'>这篇博客介绍了一种阳光体育平台下基于HTTP请求完成汉姆的方式，与虚拟定位方式相比，该种方式速度更快，使用更加便捷</p><div class='article__bottom'><div class='article__author'> <a href='/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/tag/计算机网络' class='article__tag'>计算机网络</a> </span></div></div></div></div></div>"
       } 
  
]
