[
  
    {
      "title"    : "Edit-xlsx Development Log (Part 1)",
      "category" : "Edit-xlsx",
      "tags"     : "rust",
      "url"      : "/en/edit-xlsx/2024/01/30/Edit-xlsx%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97-%E4%B8%80/",
      "date"     : "Jan 30, 2024",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#genesis\" id=\"markdown-toc-genesis\">Genesis</a></li>\n  <li><a href=\"#introduction-to-openxml-and-xlsx\" id=\"markdown-toc-introduction-to-openxml-and-xlsx\">Introduction to OpenXml and Xlsx</a></li>\n  <li><a href=\"#processing-xlsx-files\" id=\"markdown-toc-processing-xlsx-files\">Processing XLSX Files</a>    <ol>\n      <li><a href=\"#introduction-to-zip\" id=\"markdown-toc-introduction-to-zip\">Introduction to Zip</a></li>\n      <li><a href=\"#introduction-to-walkdir\" id=\"markdown-toc-introduction-to-walkdir\">Introduction to Walkdir</a></li>\n      <li><a href=\"#introduction-to-serde\" id=\"markdown-toc-introduction-to-serde\">Introduction to Serde</a></li>\n      <li><a href=\"#introduction-to-quick-xml\" id=\"markdown-toc-introduction-to-quick-xml\">Introduction to Quick-xml</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#conclusion\" id=\"markdown-toc-conclusion\">Conclusion</a></li>\n</ol>\n\n<h2 id=\"genesis\">Genesis</h2>\n<p>When I encountered a Java library called POI during my work, I began to ponder: why can’t I find a Rust library like POI that can edit XLSX files? This question sparked the idea of developing a Rust library named edit-xlsx.</p>\n\n<p>During my work, I realized that while there are Rust libraries available for reading and writing XLSX files, there isn’t one specifically tailored for editing them. That’s why I decided to embark on developing the edit-xlsx library.</p>\n\n<p>The goal of edit-xlsx is simple: to provide users with a convenient and easy-to-use tool to effortlessly edit existing XLSX files. This means users can modify, add, or delete content from files without manually handling the complex details of the XLSX format.</p>\n\n<p>Through the development of the edit-xlsx library, I aim to fill this gap in the Rust ecosystem and provide developers with a handy tool to more easily handle XLSX files without relying on other languages or platforms. This project is driven by my passion for the Rust language and my desire to solve real-world problems.</p>\n\n<p>By the time you read this blog post, I have already released the <a href=\"https://crates.io/crates/edit-xlsx\">edit-xlsx</a> project on crates.io. Additionally, I will periodically document its updates.</p>\n\n<h2 id=\"introduction-to-openxml-and-xlsx\">Introduction to OpenXml and Xlsx</h2>\n\n<p>OpenXML is an open file format based on XML (eXtensible Markup Language) used for creating and managing electronic documents such as documents, spreadsheets, and presentations. It was introduced by Microsoft in 2006 and became part of the Office Open XML (OOXML) standard. XLSX files are one of the spreadsheet file formats created using the OpenXML standard.</p>\n\n<p>The OpenXML standard defines the structure and content of XLSX files, enabling them to be read and edited by different applications without the need for specific software such as Office, LibreOffice, Numbers, or WPS. XLSX files are compressed XML files containing data, formatting, charts, metadata, and other information related to the file.</p>\n\n<p>An XLSX file is essentially a compressed package containing multiple files and folders, collectively forming the structure and content of the spreadsheet.</p>\n\n<p>To facilitate understanding the structure of XLSX files, let’s create an XLSX document containing the most basic content.\nNote: An XLSX file may contain more than just these files. Furthermore, a document containing only the following files may not necessarily function properly (depending on the processing software and version of the XLSX document).</p>\n\n<div class=\"language-bash highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>- new_excel.xlsx\n    - _rels/\n        .rels\n    - <span class=\"o\">[</span>Content_Types].xml\n    - docProps/\n        - app.xml\n        - core.xml\n    - xl/\n            - _rels/\n            - workbook.xml\n            - styles.xml\n            - worksheets/\n                - sheet1.xml\n</code></pre></div></div>\n\n<p>Subsequently, we can gradually understand the purpose of each file:</p>\n\n<ul>\n  <li><code class=\"language-plaintext highlighter-rouge\">_rels</code>: Contains XML files defining relationships between files. The <code class=\"language-plaintext highlighter-rouge\">.rels</code> file specifies the relationships between the workbook and worksheets.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">Content_Types.xml</code>: Defines the types of all XML files contained in the XLSX file. It informs applications about the content type of each XML file for proper parsing and handling.</li>\n  <li><code class=\"language-plaintext highlighter-rouge\">docProps</code>: Contains document property information, typically metadata describing the document’s author, creation date, last modification date, etc. It includes the following files:\n    <ul>\n      <li><code class=\"language-plaintext highlighter-rouge\">app.xml</code>: Contains application-related metadata such as the document’s title, author, subject, etc.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">core.xml</code>: Contains core metadata such as the document’s creator, creation date, last modifier, last modification date, etc.</li>\n    </ul>\n  </li>\n  <li><code class=\"language-plaintext highlighter-rouge\">xl</code>: This folder contains the main content.\n    <ul>\n      <li><code class=\"language-plaintext highlighter-rouge\">_rels</code>: Contains XML files defining relationships between different sections of the workbook. For example, the <code class=\"language-plaintext highlighter-rouge\">workbook.xml.rels</code> file defines relationships between worksheets and shared string files (shared strings will be introduced later).</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">worksheets</code>: Contains data for each worksheet. In our example, there is only one file named <code class=\"language-plaintext highlighter-rouge\">sheet1.xml</code>, which contains data and formatting information for the worksheet.\n        <ul>\n          <li><code class=\"language-plaintext highlighter-rouge\">sheet1.xml</code>: Contains data, cell styles, and formatting information for the worksheet.</li>\n        </ul>\n      </li>\n      <li><code class=\"language-plaintext highlighter-rouge\">workbook.xml</code>: Defines the structure of the workbook, including worksheets, names, and external links. It describes information such as the names and positions of all worksheets contained in the workbook.</li>\n      <li><code class=\"language-plaintext highlighter-rouge\">styles.xml</code>: Defines styles in the workbook, including fonts, colors, number formats, etc.</li>\n    </ul>\n  </li>\n</ul>\n\n<h2 id=\"processing-xlsx-files\">Processing XLSX Files</h2>\n<p>We know that XLSX files are essentially compressed packages of XML files (and folders). Therefore, processing XLSX files mainly involves handling compressed packages (decompression and compression) and XML processing (serialization and deserialization).</p>\n\n<p>Below, I list the libraries I currently depend on to accomplish these tasks. There may be additions or reductions in the dependencies in the future, and I will document these modifications.</p>\n\n<h4 id=\"introduction-to-zip\">Introduction to Zip</h4>\n<p><a href=\"https://crates.io/crates/zip\">Zip</a> is the most downloaded compression library on crates.io (probably due to its name). This library supports the deflate algorithm used by XLSX files, making it suitable for our needs. Therefore, we use the zip library to compress and decompress XLSX files.</p>\n\n<h4 id=\"introduction-to-walkdir\">Introduction to Walkdir</h4>\n<p><a href=\"https://crates.io/crates/walkdir\">Walkdir</a> is a Rust library for recursively traversing directory structures and listing files and subdirectories within them. Importantly, this library is recommended by Zip for implementing compression methods. Thus, we combine this library with Zip to achieve compression functionality for XLSX files.</p>\n\n<h4 id=\"introduction-to-serde\">Introduction to Serde</h4>\n<p><a href=\"https://crates.io/crates/serde\">Serde</a> is one of the most popular serialization and deserialization libraries in Rust. Its name is derived from the combination of “serialize” and “deserialize,” aiming to provide a simple and flexible way to convert Rust data structures to and from various data formats.</p>\n\n<p>In our project, we primarily use its derive feature to quickly implement serialization and deserialization for structures and enums.</p>\n\n<h4 id=\"introduction-to-quick-xml\">Introduction to Quick-xml</h4>\n<p><a href=\"https://crates.io/crates/quick-xml\">Quick-xml</a> is the XML serialization/deserialization tool I experimented with extensively and found most suitable for XLSX XML formats. Compared to projects like fast-xml, this project supports a more comprehensive range of features, such as reading XML structure attributes, values, etc., using <code class=\"language-plaintext highlighter-rouge\">@</code>, <code class=\"language-plaintext highlighter-rouge\">$</code>, and other methods. Moreover, this project is still maintained, and I look forward to it adding more user-friendly features in the future.</p>\n\n<h2 id=\"conclusion\">Conclusion</h2>\n<p>This blog post documented the reasons behind the development of the edit-xlsx project and the expected technology stack. If time and resources permit, I will continue to document my development progress in this section.</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/edit-xlsx/2024/01/30/Edit-xlsx%E5%BC%80%E5%8F%91%E6%97%A5%E5%BF%97-%E4%B8%80/'> <img src='/en/images/covers/edit-xlsx-cover.png' alt='Edit-xlsx Development Log (Part 1)'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>5 min read <time class='article__date' datetime='2024-01-30T18:20:05+11:00'>Jan 30, 2024</time> </span> </div><h2 class='article__title'>Edit-xlsx Development Log (Part 1)</h2> <p class='article__excerpt'></p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/rust' class='article__tag'>rust</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "双指针问题（二）滑动窗口",
      "category" : "",
      "tags"     : "算法, 指针, 链表, and 数据结构",
      "url"      : "/en/2021/10/20/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%BA%8C-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/",
      "date"     : "Oct 20, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a></li>\n  <li><a href=\"#209-长度最小的子数组\" id=\"markdown-toc-209-长度最小的子数组\">209. 长度最小的子数组</a></li>\n  <li><a href=\"#713-乘积小于k的子数组\" id=\"markdown-toc-713-乘积小于k的子数组\">713. 乘积小于K的子数组</a></li>\n  <li><a href=\"#3-无重复字符的最长子串\" id=\"markdown-toc-3-无重复字符的最长子串\">3. 无重复字符的最长子串</a></li>\n  <li><a href=\"#438-找到字符串中所有字母异位词\" id=\"markdown-toc-438-找到字符串中所有字母异位词\">438. 找到字符串中所有字母异位词</a></li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>滑动窗口是在数组上通过双指针同向移动而解决问题的方法。这样的问题我们不必为它们专门命名一个名字，它们的解法其实是很自然的。</p>\n\n<p>滑动窗口通常是暴力解法的优化，掌握这一类问题最好的办法就是练习，然后思考清楚为什么可以使用滑动窗口。</p>\n\n<h2 id=\"209-长度最小的子数组\"><a href=\"https://leetcode-cn.com/problems/minimum-size-subarray-sum/\">209. 长度最小的子数组</a></h2>\n\n<p>该题是最基本的滑动窗口问题，我们可以用两个指针\\(l\\)和\\(r\\)表示窗口的左右段，然后让指针\\(r\\)持续向右移动，同时用一个变量\\(sum\\)记录\\([l,r]\\)的区间和，若\\(sum\\)满足条件，则记录\\(l\\)和\\(r\\)的差作为答案，并移动指针\\(l\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">minSubArrayLen</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">INT_MAX</span><span class=\"p\">,</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">];</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">&gt;=</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">min</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n                <span class=\"n\">sum</span> <span class=\"o\">-=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">];</span>\n                <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span> <span class=\"o\">==</span> <span class=\"n\">INT_MAX</span> <span class=\"o\">?</span> <span class=\"mi\">0</span> <span class=\"o\">:</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h2 id=\"713-乘积小于k的子数组\"><a href=\"https://leetcode-cn.com/problems/subarray-product-less-than-k/\">713. 乘积小于K的子数组</a></h2>\n\n<p>这道题的解法与上道题非常相似，但求的不再是区间长度而是连续子区间数量。</p>\n\n<p>对于子区间数量，我们可以发现，若\\([l,r]\\)是一个符合条件的窗口，则\\([l+i,r],(0&lt;i≤r-l)\\)也必然是符合条件的窗口</p>\n\n<p>即对于任何符合条件的区间\\([l,r]\\)，以\\(r\\)结尾的子集个数永远是\\(r-l+1\\)，因此我们要在每次更新\\(r\\)之前为答案加上\\(r-l+1\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">numSubarrayProductLessThanK</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">k</span> <span class=\"o\">&lt;=</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">*=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">];</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">&gt;=</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">sum</span> <span class=\"o\">/=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">];</span>\n                <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">ans</span> <span class=\"o\">+=</span> <span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h2 id=\"3-无重复字符的最长子串\"><a href=\"https://leetcode-cn.com/problems/longest-substring-without-repeating-characters/\">3. 无重复字符的最长子串</a></h2>\n\n<p>与前面的连续子序列不同的是，这道题要求的是连续子串的长度，因此我们需要修改一下判定条件，若窗口区间内出现重复字符，则更新\\(l\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">lengthOfLongestSubstring</span><span class=\"p\">(</span><span class=\"n\">string</span> <span class=\"n\">s</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"n\">map</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">cnt</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">cnt</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]]</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">cnt</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]]</span> <span class=\"o\">&gt;</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">cnt</span><span class=\"p\">[</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]]</span><span class=\"o\">--</span><span class=\"p\">;</span>\n                <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n            <span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n\n<h2 id=\"438-找到字符串中所有字母异位词\"><a href=\"https://leetcode-cn.com/problems/find-all-anagrams-in-a-string/\">438. 找到字符串中所有字母异位词</a></h2>\n\n<p>这道题解法与上一题大同小异，是把字符的判据改为了字符串的比较。同时，该题的窗口长度始终保持不变，为\\(p\\)的长度</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">findAnagrams</span><span class=\"p\">(</span><span class=\"n\">string</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">string</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">(</span><span class=\"mi\">26</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"mi\">26</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">);</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">()</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">())</span> <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"n\">target</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">++</span><span class=\"p\">,</span> <span class=\"n\">sum</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">();</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&lt;</span> <span class=\"n\">s</span><span class=\"p\">.</span><span class=\"n\">length</span><span class=\"p\">())</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">--</span><span class=\"p\">;</span>\n            <span class=\"n\">sum</span><span class=\"p\">[(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">(</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"o\">++</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"sc\">'a'</span><span class=\"p\">)]</span><span class=\"o\">++</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">sum</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">)</span>\n                <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/2021/10/20/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%BA%8C-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3/'> <img src='/enhttps://api.dujin.org/bing/1920.php' alt='双指针问题（二）滑动窗口'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-20T00:41:33+11:00'>Oct 20, 2021</time> </span> </div><h2 class='article__title'>双指针问题（二）滑动窗口</h2> <p class='article__excerpt'>双指针是在遍历的过程中，使用两个方向相同或相反的指针进行扫描，从而达到相应目的的算法。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/指针' class='article__tag'>指针</a>  <a href='/en/tag/链表' class='article__tag'>链表</a>  <a href='/en/tag/数据结构' class='article__tag'>数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "二分查找（Binary Search）",
      "category" : "",
      "tags"     : "算法",
      "url"      : "/en/2021/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search/",
      "date"     : "Oct 15, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a>    <ol>\n      <li><a href=\"#模板\" id=\"markdown-toc-模板\">模板</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#题目\" id=\"markdown-toc-题目\">题目</a>    <ol>\n      <li><a href=\"#34-在排序数组中查找元素的第一个和最后一个位置\" id=\"markdown-toc-34-在排序数组中查找元素的第一个和最后一个位置\">34. 在排序数组中查找元素的第一个和最后一个位置</a></li>\n      <li><a href=\"#74-搜索二维矩阵\" id=\"markdown-toc-74-搜索二维矩阵\">74. 搜索二维矩阵</a></li>\n      <li><a href=\"#33-搜索旋转排序数组\" id=\"markdown-toc-33-搜索旋转排序数组\">33. 搜索旋转排序数组</a></li>\n      <li><a href=\"#153-寻找旋转排序数组中的最小值\" id=\"markdown-toc-153-寻找旋转排序数组中的最小值\">153. 寻找旋转排序数组中的最小值</a></li>\n      <li><a href=\"#162-寻找峰值\" id=\"markdown-toc-162-寻找峰值\">162. 寻找峰值</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>二分查找是对已排好序的数组查找特定值的常用方法，二分查找不必遍历整个序列，只需关注序列的边界及中间值即可，因此时间复杂度可以达到\\(O(logn)\\)</p>\n\n<h3 id=\"模板\">模板</h3>\n\n<p>在一个有序序列中查找关键字\\(key\\)的模板代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">key</span><span class=\"p\">)</span>\n            <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span>\n            <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h2 id=\"题目\">题目</h2>\n\n<p>二分的题目模板一般都是固定的，主要是能否想到的对什么进行二分，怎样二分。</p>\n\n<h3 id=\"34-在排序数组中查找元素的第一个和最后一个位置\"><a href=\"https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/\">34. 在排序数组中查找元素的第一个和最后一个位置</a></h3>\n\n<p>该题不仅要求元素出现的第一个位置，还要求出元素出现的最后一个位置。在模板代码中，若<code class=\"language-plaintext highlighter-rouge\">nums[i] &lt; key</code>，才会继续查找左边，如果我们想在已经找到元素后继续查找，则需要修改为<code class=\"language-plaintext highlighter-rouge\">nums[i] &lt;= key</code>。这样查找的结果是大于\\(key\\)的第一个元素的位置。因此该题的代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"kt\">bool</span> <span class=\"n\">next</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">key</span> <span class=\"o\">||</span> <span class=\"p\">(</span><span class=\"n\">last</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;=</span> <span class=\"n\">key</span><span class=\"p\">))</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">searchRange</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"nb\">false</span><span class=\"p\">),</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span>\n            <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">};</span>\n        <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"p\">{</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">};</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h3 id=\"74-搜索二维矩阵\"><a href=\"https://leetcode-cn.com/problems/search-a-2d-matrix/\">74. 搜索二维矩阵</a></h3>\n\n<p>依题可知待查找元素必大于或等于该行第一个元素，因此我们先对列进行一次二分查找，寻找不大于\\(target\\)的最大元素</p>\n\n<p>之后对该行进行基本的二分查找，即可得到结果。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">bool</span> <span class=\"n\">searchMatrix</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">matrix</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">(),</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"c1\">// 先找小于target的第一个数的位置</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>  \t\t\t\t\t     <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ans</span> <span class=\"o\">&lt;</span> <span class=\"mi\">0</span> <span class=\"o\">||</span> <span class=\"n\">ans</span> <span class=\"o\">&gt;=</span> <span class=\"n\">matrix</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">())</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">].</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">][</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>\t\t\t\t\t\t   <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">matrix</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">][</span><span class=\"n\">res</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h3 id=\"33-搜索旋转排序数组\"><a href=\"https://leetcode-cn.com/problems/search-in-rotated-sorted-array/\">33. 搜索旋转排序数组</a></h3>\n\n<p>该题只保证了数组的局部有序，但对数组进行二分后，会发现总有一半的数组是有序的，此时可以继续对有序的数组进行二分查找，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">key</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">t</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">ans</span> <span class=\"o\">&lt;</span> <span class=\"n\">t</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">key</span><span class=\"p\">)</span> <span class=\"o\">?</span> <span class=\"n\">ans</span> <span class=\"o\">:</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"nf\">search</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">==</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">])</span> <span class=\"p\">{</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n                <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">binarySearch</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"n\">target</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n            <span class=\"p\">}</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">ans</span> <span class=\"o\">&gt;=</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n\n<h3 id=\"153-寻找旋转排序数组中的最小值\"><a href=\"https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/\">153. 寻找旋转排序数组中的最小值</a></h3>\n\n<p>该题要查找的是上一题中旋转的排序数组的最小值，也即旋转点的值，我们依然利用部分有序的性质，二分查找数组最小值，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">findMin</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">])</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">ans</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">ans</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<h3 id=\"162-寻找峰值\"><a href=\"https://leetcode-cn.com/problems/find-peak-element/\">162. 寻找峰值</a></h3>\n\n<p>我们可以用\\([l,r]\\)来存储可能存在峰值的区间，根据\\(mid\\)进行二分，若<code class=\"language-plaintext highlighter-rouge\">nums[mid] &lt; nums[mid + 1]</code>则说明在区间\\([mid+1,r]\\)存在峰值，反之则说明在区间[l,mid]存在峰值，因此代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">findPeakElement</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 用l,r表示可能存在峰值的区间</span>\n            <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">l</span><span class=\"p\">;</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">])</span>\n                <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">;</span><span class=\"c1\">//mid+1-r更大</span>\n            <span class=\"k\">else</span>\n                <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">mid</span><span class=\"p\">;</span><span class=\"c1\">//l-mid更大</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/2021/10/15/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE-Binary-Search/'> <img src='/en/images/covers/blackrock2.jpg' alt='二分查找（Binary Search）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2021-10-15T23:51:55+11:00'>Oct 15, 2021</time> </span> </div><h2 class='article__title'>二分查找（Binary Search）</h2> <p class='article__excerpt'>二分查找是对已排好序的数组查找特定值的常用方法，二分查找不必遍历整个序列，只需关注序列的边界及中间值即可，因此时间复杂度可以达到 O(log n)</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（四）最长上升子序列（LIS）",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/10/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9B%9B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-LIS/",
      "date"     : "Oct 12, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#动态规划\" id=\"markdown-toc-动态规划\">动态规划</a></li>\n  <li><a href=\"#树状数组\" id=\"markdown-toc-树状数组\">树状数组</a></li>\n</ol>\n\n<p><a href=\"https://leetcode-cn.com/problems/longest-increasing-subsequence/\">300.最长递增子序列</a></p>\n\n<h2 id=\"动态规划\">动态规划</h2>\n<p>我们可以定义\\(dp[i]\\)为以\\(i\\)结尾的递增子序列长度的最大值（数组\\(dp\\)的常用套路），则我们可以写出状态转移方程为\n\\(dp[i]=max(dp[j])+1,(0≤j&lt;i, nums[j]&lt;nums[i])\\)</p>\n\n<p>最后，此题的结果便是\\(max(dp[i])\\)，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">lengthOfLIS</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">dp</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">);</span>\n    <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;</span> <span class=\"n\">i</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span>\n            <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">&lt;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n                <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n        <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>该解法时间复杂度为\\(O(n^2)\\)</p>\n\n<h2 id=\"树状数组\">树状数组</h2>\n<p>LIS问题的本质是偏序问题，我们之前在二维偏序问题中提到过，树状数组可以轻松的解决这类问题。但之前的问题中，我们求的是数对的数量，而不是序列的长度。为了能够求得序列长度，我们要对树状数组进行修改。</p>\n\n<p>我们可以用树状数组存储以\\(i\\)结尾的递增子序列最大值，修改树状数组结构如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">N</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n<span class=\"kt\">int</span> <span class=\"nf\">sum</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">sum</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n        <span class=\"n\">i</span> <span class=\"o\">-=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>随后用和\\(dp\\)同样的方式进行遍历，可以得出正确结果，同时要注意数据的离散化，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">Fenwick</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"p\">;</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">node</span><span class=\"p\">;</span>\n\n    <span class=\"n\">Fenwick</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">N</span><span class=\"p\">(</span><span class=\"n\">n</span><span class=\"p\">),</span> <span class=\"n\">node</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n\n    <span class=\"kt\">int</span> <span class=\"nf\">lowbit</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">return</span> <span class=\"n\">i</span> <span class=\"o\">&amp;</span> <span class=\"o\">-</span><span class=\"n\">i</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&lt;=</span> <span class=\"n\">N</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n            <span class=\"n\">i</span> <span class=\"o\">+=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    \n    <span class=\"kt\">int</span> <span class=\"nf\">sum</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">sum</span><span class=\"p\">,</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]);</span>\n            <span class=\"n\">i</span> <span class=\"o\">-=</span> <span class=\"n\">lowbit</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">);</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">class</span> <span class=\"nc\">Solution</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"kt\">int</span> <span class=\"n\">lengthOfLIS</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"o\">&amp;</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"kt\">int</span> <span class=\"n\">n</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span>\n        <span class=\"kt\">int</span> <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n        <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">;</span>\n        <span class=\"n\">sort</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n        <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">erase</span><span class=\"p\">(</span><span class=\"n\">unique</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">()),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">());</span>\n        <span class=\"n\">Fenwick</span> <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">Fenwick</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">());</span>\n        <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">n</span><span class=\"p\">;</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">lower_bound</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">(),</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">end</span><span class=\"p\">(),</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">-</span> <span class=\"n\">l</span><span class=\"p\">.</span><span class=\"n\">begin</span><span class=\"p\">();</span>\n            <span class=\"n\">res</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">res</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n            <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">update</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n            <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">f</span><span class=\"p\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">return</span> <span class=\"n\">res</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n<p>该解法时间复杂度为\\(O(nlogn)\\)</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/10/12/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E5%9B%9B-%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%90%E5%BA%8F%E5%88%97-LIS/'> <img src='/en/images/covers/village.jpg' alt='动态规划（四）最长上升子序列（LIS）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-12T00:19:19+11:00'>Oct 12, 2021</time> </span> </div><h2 class='article__title'>动态规划（四）最长上升子序列（LIS）</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "二叉树基础（三） 线段树（Segment Tree）",
      "category" : "",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/en/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree/",
      "date"     : "Oct 9, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a>    <ol>\n      <li><a href=\"#结构\" id=\"markdown-toc-结构\">结构</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#基本操作\" id=\"markdown-toc-基本操作\">基本操作</a>    <ol>\n      <li><a href=\"#线段树的建立\" id=\"markdown-toc-线段树的建立\">线段树的建立</a></li>\n      <li><a href=\"#区间查询\" id=\"markdown-toc-区间查询\">区间查询</a></li>\n      <li><a href=\"#区间修改\" id=\"markdown-toc-区间修改\">区间修改</a></li>\n      <li><a href=\"#懒惰标记\" id=\"markdown-toc-懒惰标记\">懒惰标记</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#整体代码\" id=\"markdown-toc-整体代码\">整体代码</a></li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>线段树是常用于<strong>维护区间信息</strong>的数据结构</p>\n\n<p>线段树可以在$O(logn)$的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值）等操作</p>\n\n<h3 id=\"结构\">结构</h3>\n\n<p>线段树将每个长度不为$1$的区间划分成左右两个区间递归求解，把整个线段划分为一个树形结构，通过合并左右两区间信息来求得该区间的信息。这种数据结构可以方便的进行大部分的区间操作。</p>\n\n<p>假设以线段树存储数组$a=[6,7,8,9,10]$，设线段树的根节点编号为$1$，用数组$node$来保存线段树，$node[i]$用来保存线段树上编号为$i$的节点的值</p>\n\n<p>该线段树的结构如下</p>\n\n<p><img src=\"/images/posts/segmenttree1.png\" alt=\"在这里插入图片描述\" />\n代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">node</span><span class=\"p\">;</span> <span class=\"c1\">// 线段树下标从1开始</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">;</span> <span class=\"c1\">// 辅助建树</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"p\">;</span>\n</code></pre></div></div>\n\n<h2 id=\"基本操作\">基本操作</h2>\n<h3 id=\"线段树的建立\">线段树的建立</h3>\n\n<p>对于节点$i$，其子节点的编号为$2i$以及$2i+1$，若节点$i$存储的区间为$[a,b]$，则节点$2i$存储的区间应该是$[a,\\frac{a+b}{2}]$，相应地，节点$2i+1$存储的区间为$[\\frac{a+b}{2}+1,b]$。我们可以采用递归的方式建树，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">build</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// i表示当前节点, l表示左边界, r表示右边界</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">];</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span>\n    <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">);</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"区间查询\">区间查询</h3>\n<p>若查询的区间为$[1,5]$，我们只需直接返回$node[1]$，但如果我们查询的是$[3,5]$，则需要合并$[3,3]$和$[4,5]$的答案，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">//i表示当前节点, [l,r]是查询区间, [s,t]表示当前节点包含区间</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接返回</span>\n        <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归查询存在交集的子区间</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询左字串</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询右字串</span>\n    <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h3 id=\"区间修改\">区间修改</h3>\n<p>和区间查询相同，若区间存在包含关系，我们可以为其直接加上所需要更新的值，而当区间存在交集时，进行递归更新，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">add</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接更新</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">add</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归更新存在交集的子区间</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新左字串</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新右字串</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h3 id=\"懒惰标记\">懒惰标记</h3>\n<p>当我们按照上面的方法对$[6,7,8,9,10]$的区间$[3,5]$加上$2$后，更新后的线段树结构如下\n<img src=\"/images/posts/segmenttree2.png\" alt=\"在这里插入图片描述\" />\n我们会发现，在进行递归更新时，递归执行到节点$3$时就已经结束了，因此节点$3$的两个子节点没有被更新</p>\n\n<p>遇到这种情况，我们需要给递归结束的节点打上一个标记，在下一次查询操作时将没有更新的子节点更新，这个标记被称为懒惰标记，这样更新时效果如图</p>\n\n<p><img src=\"/images/posts/segmenttree3.png\" alt=\"在这里插入图片描述\" /></p>\n\n<p>而查询后的效果如下</p>\n\n<p><img src=\"/images/posts/segmenttree4.png\" alt=\"在这里插入图片描述\" />\n我们可以用<code class=\"language-plaintext highlighter-rouge\">vector&lt;int&gt; lazy</code>来存储懒惰标记，下方懒惰标记的代码如下</p>\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">push_down</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n    <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>             <span class=\"c1\">// 下放懒惰标记</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span> <span class=\"c1\">// 将懒惰标记的值加给子树</span>\n    <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>然后在查询和更新函数中调用<code class=\"language-plaintext highlighter-rouge\">push_down()</code>即可</p>\n\n<h2 id=\"整体代码\">整体代码</h2>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">class</span> <span class=\"nc\">SegmentTree</span> <span class=\"p\">{</span>\n<span class=\"nl\">public:</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">node</span><span class=\"p\">;</span> <span class=\"c1\">// 线段树下标从1开始</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">lazy</span><span class=\"p\">;</span> <span class=\"c1\">// 懒惰标记</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">;</span> <span class=\"c1\">// 辅助建树</span>\n    <span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n    <span class=\"n\">SegmentTree</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">n</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">node</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">lazy</span><span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">),</span> <span class=\"n\">nums</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">build</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// i表示当前节点, l表示左边界, r表示右边界</span>\n        <span class=\"n\">N</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">==</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n        <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span>\n        <span class=\"n\">build</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">);</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">push_down</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">])</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span>\n        <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>             <span class=\"c1\">// 下放懒惰标记</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">mid</span> <span class=\"o\">-</span> <span class=\"n\">l</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">-</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span> <span class=\"c1\">// 将懒惰标记的值加给子树</span>\n        <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">int</span> <span class=\"nf\">query</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">//i表示当前节点, [l,r]是查询区间, [s,t]表示当前节点包含区间</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接返回</span>\n            <span class=\"k\">return</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n        <span class=\"n\">push_down</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">sum</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归查询存在交集的子区间</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询左字串</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">sum</span> <span class=\"o\">+=</span> <span class=\"n\">query</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span> <span class=\"c1\">// 递归查询右字串</span>\n        <span class=\"k\">return</span> <span class=\"n\">sum</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"kt\">void</span> <span class=\"nf\">update</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">add</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">s</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"p\">{</span> <span class=\"c1\">// 若[s,t]是[l,r]的子区间，直接更新</span>\n            <span class=\"n\">lazy</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"n\">add</span><span class=\"p\">;</span>\n            <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"p\">(</span><span class=\"n\">t</span> <span class=\"o\">-</span> <span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"n\">add</span><span class=\"p\">;</span>\n            <span class=\"k\">return</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"n\">push_down</span><span class=\"p\">(</span><span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">);</span>\n        <span class=\"kt\">int</span> <span class=\"n\">mid</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">s</span> <span class=\"o\">+</span> <span class=\"n\">t</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"mi\">2</span><span class=\"p\">;</span> <span class=\"c1\">//递归更新存在交集的子区间</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;=</span> <span class=\"n\">mid</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">s</span><span class=\"p\">,</span> <span class=\"n\">mid</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新左字串</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">r</span> <span class=\"o\">&gt;=</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">update</span><span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">l</span><span class=\"p\">,</span> <span class=\"n\">r</span><span class=\"p\">,</span> <span class=\"n\">mid</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">t</span><span class=\"p\">,</span> <span class=\"n\">add</span><span class=\"p\">);</span> <span class=\"c1\">// 递归更新右字串</span>\n        <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">node</span><span class=\"p\">[</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">i</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">];</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/2021/10/09/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%89-%E7%BA%BF%E6%AE%B5%E6%A0%91-Segment-Tree/'> <img src='/en/images/covers/数据结构-cover1.png' alt='二叉树基础（三） 线段树（Segment Tree）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>9 min read <time class='article__date' datetime='2021-10-09T22:00:50+11:00'>Oct 9, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（三） 线段树（Segment Tree）</h2> <p class='article__excerpt'>二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/en/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/en/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "双指针问题（一）对撞指针和快慢指针",
      "category" : "",
      "tags"     : "算法, 指针, 链表, and 数据结构",
      "url"      : "/en/2021/10/09/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%B8%80-%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88%E5%92%8C%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/",
      "date"     : "Oct 9, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a></li>\n  <li><a href=\"#双指针问题\" id=\"markdown-toc-双指针问题\">双指针问题</a>    <ol>\n      <li><a href=\"#对撞指针\" id=\"markdown-toc-对撞指针\">对撞指针</a></li>\n      <li><a href=\"#快慢指针\" id=\"markdown-toc-快慢指针\">快慢指针</a></li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p>双指针是在遍历的过程中，使用两个方向相同或相反的指针进行扫描，从而达到相应目的的算法。</p>\n\n<p>广义上来说，双指针是指用两个变量在线性结构上遍历而解决的问题。</p>\n\n<p>狭义上说：</p>\n\n<ul>\n  <li>对于数组，指两个变量在数组上相向移动解决的问题；</li>\n  <li>对于链表，指两个变量在链表上同向移动解决的问题，也称为「快慢指针」问题。</li>\n</ul>\n\n<h2 id=\"双指针问题\">双指针问题</h2>\n<h3 id=\"对撞指针\">对撞指针</h3>\n<p>对撞指针将最左侧的索引定义为左指针(left)，最右侧的定义为右指针(right)，从两头向中间进行数组遍历</p>\n\n<p>对撞指针适用于<strong>有序的数组和字符串</strong></p>\n\n<p>对撞指针的时间复杂度为\\(O(n)\\)</p>\n\n<p><a href=\"https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof/\">剑指 Offer 21</a></p>\n\n<p>此题要求分奇偶调整数组的顺序，我们可以用左指针寻找奇数，右指针寻找偶数，当左指针找到偶数且右指针找到奇数时，对调两数。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">exchange</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span> <span class=\"o\">&lt;</span> <span class=\"n\">r</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"n\">r</span><span class=\"o\">--</span><span class=\"p\">;</span>\n        <span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">],</span> <span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">nums</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><a href=\"https://leetcode-cn.com/problems/he-wei-sde-liang-ge-shu-zi-lcof/\">剑指 Offer 57</a></p>\n\n<p>此题要求寻找和为\\(target\\)数对，由于此题数组已经做好排序，我们可以确定</p>\n\n<p>若数对\\((nums[i+1],nums[j])&lt;target\\)</p>\n\n<p>则必有\\((nums[i],nums[j])&lt;target\\)</p>\n\n<p>同理，若数对\\((nums[i],nums[j])&gt;target\\)</p>\n\n<p>则\\((nums[i+1],nums[j])&gt;target\\)</p>\n\n<p>因此这道题也可以用对撞指针求解，当\\(nums[l]+nums[r]&lt;target\\)时，\\(l\\)向右移动，反之，\\(nums[l]+nums[r]&gt;target\\)时，r向左移动，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">twoSum</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">nums</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">l</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">r</span> <span class=\"o\">=</span> <span class=\"n\">nums</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">&lt;</span><span class=\"n\">r</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">&lt;</span><span class=\"n\">r</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span><span class=\"o\">&lt;</span><span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">l</span><span class=\"o\">++</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">l</span><span class=\"o\">&lt;</span><span class=\"n\">r</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span><span class=\"o\">&gt;</span><span class=\"n\">target</span><span class=\"p\">)</span> <span class=\"n\">r</span><span class=\"o\">--</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]</span><span class=\"o\">+</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]</span><span class=\"o\">==</span><span class=\"n\">target</span><span class=\"p\">){</span>\n            <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">l</span><span class=\"p\">]);</span>\n            <span class=\"n\">ans</span><span class=\"p\">.</span><span class=\"n\">push_back</span><span class=\"p\">(</span><span class=\"n\">nums</span><span class=\"p\">[</span><span class=\"n\">r</span><span class=\"p\">]);</span>\n            <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">ans</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"快慢指针\">快慢指针</h3>\n<p>快慢指针在序列中定义了一对不同速度的指针，以进行单向序列问题的求解。</p>\n\n<p>快慢指针的时间复杂度为\\(O(n)\\)，空间复杂度为\\(O(1)\\)</p>\n\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle/\">141. 环形链表</a></p>\n\n<p>此题要判断链表是否有环，可以定义一个快指针和一个慢指针，随后进行移动，若快指针可以追上慢指针，则表示链表一定有环，代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">bool</span> <span class=\"nf\">hasCycle</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"k\">do</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n            <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n        <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">!=</span> <span class=\"n\">p2</span><span class=\"p\">);</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<p><a href=\"https://leetcode-cn.com/problems/linked-list-cycle-ii/\">142. 环形链表 II</a></p>\n\n<p>此题需要在求出是否成环的同时找到入环的第一个节点，我们可以根据快指针速度始终是慢指针的两倍这一条件进行推理</p>\n\n<p><img src=\"/images/posts/doublepoint1.png\" alt=\"在这里插入图片描述\" /></p>\n\n<p>假设快慢指针在\\(bc\\)交点相遇，此时慢指针走的距离应该是\\(a+b\\)，而快指针已经走了\\(a+b+k(b+c)\\)\n又有快指针的速度是慢指针的两倍，因此</p>\n\n<p>\\(a+b+k(b+c)=2(a+b)\\)，</p>\n\n<p>即\\(a=k(b+c)-b=(k-1)(b+c)+c\\)</p>\n\n<p>因此，当快慢指针相遇时，相遇点距离入环节点的距离总是\\(a\\)，因此我们可以再用一个指针\\(cur\\)寻找入环节点，同时更新\\(cur\\)和慢指针，当二者相遇时，相遇节点即入环节点。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"nf\">detectCycle</span><span class=\"p\">(</span><span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">head</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"k\">do</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n            <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">p2</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span> <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">p1</span> <span class=\"o\">!=</span> <span class=\"n\">p2</span><span class=\"p\">);</span>\n    <span class=\"n\">ListNode</span> <span class=\"o\">*</span><span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">head</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span> <span class=\"p\">(</span><span class=\"n\">cur</span> <span class=\"o\">!=</span> <span class=\"n\">p1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">cur</span> <span class=\"o\">=</span> <span class=\"n\">cur</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n        <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"n\">p1</span><span class=\"o\">-&gt;</span><span class=\"n\">next</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">cur</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/2021/10/09/%E5%8F%8C%E6%8C%87%E9%92%88%E9%97%AE%E9%A2%98-%E4%B8%80-%E5%AF%B9%E6%92%9E%E6%8C%87%E9%92%88%E5%92%8C%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/'> <img src='/enhttps://api.dujin.org/bing/1920.php' alt='双指针问题（一）对撞指针和快慢指针'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>3 min read <time class='article__date' datetime='2021-10-09T00:14:13+11:00'>Oct 9, 2021</time> </span> </div><h2 class='article__title'>双指针问题（一）对撞指针和快慢指针</h2> <p class='article__excerpt'>双指针是在遍历的过程中，使用两个方向相同或相反的指针进行扫描，从而达到相应目的的算法。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/指针' class='article__tag'>指针</a>  <a href='/en/tag/链表' class='article__tag'>链表</a>  <a href='/en/tag/数据结构' class='article__tag'>数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "二叉树基础（二）二叉搜索树（BST）",
      "category" : "",
      "tags"     : "算法, 数据结构, 二叉树, and 树型数据结构",
      "url"      : "/en/2021/10/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/",
      "date"     : "Oct 5, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#概念\" id=\"markdown-toc-概念\">概念</a>    <ol>\n      <li><a href=\"#性质\" id=\"markdown-toc-性质\">性质</a></li>\n      <li><a href=\"#结构\" id=\"markdown-toc-结构\">结构</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#代码\" id=\"markdown-toc-代码\">代码</a>    <ol>\n      <li><a href=\"#基本操作\" id=\"markdown-toc-基本操作\">基本操作</a>        <ol>\n          <li><a href=\"#find\" id=\"markdown-toc-find\">$find()$</a></li>\n          <li><a href=\"#insert\" id=\"markdown-toc-insert\">$insert()$</a></li>\n          <li><a href=\"#delete\" id=\"markdown-toc-delete\">$delete()$</a></li>\n        </ol>\n      </li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"概念\">概念</h2>\n<p><strong>二叉搜索树（Binary Search Tree）</strong>（又：二叉查找树，二叉排序树），它或者是一棵空树，或者是具有下列性质的二叉树：\n若它的左子树非空，则左子树上所有结点的值均小于它的根结点的值； \n若它的右子树非空，则右子树上所有结点的值均大于它的根结点的值；\n它的左、右子树也分别是二叉搜索树。\n二叉搜索树作为一种经典的数据结构，既有快速插入与删除操作的特点，又有快速查找的优势；所以应用十分广泛，例如在文件系统和数据库系统一般会采用这种数据结构进行高效率的排序与检索操作。</p>\n<h3 id=\"性质\">性质</h3>\n<p>二叉搜索树有以下性质：</p>\n<ul>\n  <li>若左子树非空，则左子树上的所有节点值均小于根节点的值。</li>\n  <li>若右子树非空，则右子树上的所有节点值均小于根节点的值。</li>\n  <li>左右子树是二叉搜索树。</li>\n</ul>\n\n<h3 id=\"结构\">结构</h3>\n<p>BST是以二叉树来构建的，除了key和位置数据之外，每个结点还包含属性lchild、rchild，如果某个孩子结点不存在，则相应属性的值为空。</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">;</span>                               <span class=\"c1\">// 数据</span>\n    <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"o\">*</span><span class=\"n\">lchild</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">rchild</span><span class=\"p\">;</span>  \t\t\t<span class=\"c1\">// 左右子树</span>\n<span class=\"p\">}</span> <span class=\"o\">*</span> <span class=\"n\">BST</span><span class=\"p\">,</span> <span class=\"n\">BSTNode</span><span class=\"p\">;</span>\n</code></pre></div></div>\n<h2 id=\"代码\">代码</h2>\n<h3 id=\"基本操作\">基本操作</h3>\n\n<p>BST的构造和析构与普通二叉树相同，这里不多赘述。相比于普通二叉树，BST的主要功能增加了查找，插入和删除</p>\n\n<h4 id=\"find\">$find()$</h4>\n<p>$find()$函数的作用是查找某一个数据值已知的节点是否在树中，并返回节点值。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"n\">BST</span> <span class=\"nf\">find</span><span class=\"p\">(</span><span class=\"n\">BST</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">){</span>\n    <span class=\"n\">BST</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h4 id=\"insert\">$insert()$</h4>\n<p>$insert()$函数的作用是在树中插入一个节点。BST中所有的节点都是作为叶子节点插入的，因此在创建节点$p$后，要找到合适的父节点$f$并插入其中。代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">bool</span> <span class=\"nf\">insert</span><span class=\"p\">(</span><span class=\"n\">BST</span><span class=\"o\">&amp;</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">BST</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n        <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>                  <span class=\"c1\">// 记录f为p的父节点</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>                           <span class=\"c1\">// 查找data是否已经在树中</span>\n\n    <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">BST</span><span class=\"p\">)</span> <span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">BSTNode</span><span class=\"p\">));</span>\n    <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">data</span><span class=\"p\">;</span>             <span class=\"c1\">// 创建节点</span>\n\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"k\">else</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<h4 id=\"delete\">$delete()$</h4>\n<p>二叉搜索树进行删除操作后，仍然要保证它的排序正确，因此我们的删除操作分为三种情况：</p>\n\n<ul>\n  <li>待删除节点无左孩子，则用右孩子代替其位置</li>\n  <li>待删除节点无右孩子，则用左孩子代替其位置</li>\n  <li>待删除节点拥有左右孩子，则用左子树最大节点或右子树最小节点代替其位置</li>\n</ul>\n\n<p>代码如下</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">bool</span> <span class=\"nf\">delete</span><span class=\"p\">(</span><span class=\"n\">BST</span><span class=\"o\">&amp;</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n    <span class=\"n\">BST</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"n\">f</span><span class=\"p\">;</span>\n    <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">==</span> <span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"k\">break</span><span class=\"p\">;</span>\n        <span class=\"n\">f</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>                  <span class=\"c1\">// 记录f为p的父节点</span>\n        <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">data</span> <span class=\"o\">&lt;</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span> <span class=\"k\">else</span> <span class=\"p\">{</span>\n            <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"p\">}</span>\n    <span class=\"p\">}</span>                           <span class=\"c1\">// 查找data的位置</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">p</span><span class=\"p\">)</span>  <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>       <span class=\"c1\">// 若未找到，则返回false</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">)</span> <span class=\"p\">{</span>            <span class=\"c1\">// 情况1</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">tree</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span> <span class=\"nf\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">){</span>        <span class=\"c1\">// 情况2</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">tree</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">==</span> <span class=\"n\">p</span><span class=\"p\">)</span> <span class=\"n\">f</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">else</span><span class=\"p\">{</span>                       <span class=\"c1\">// 情况3</span>\n        <span class=\"n\">BST</span> <span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">,</span> <span class=\"n\">fl</span> <span class=\"o\">=</span> <span class=\"n\">p</span><span class=\"p\">;</span>\n        <span class=\"k\">while</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">)</span> <span class=\"n\">fl</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"p\">,</span><span class=\"n\">tmp</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">;</span>\n        <span class=\"n\">p</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span><span class=\"p\">;</span>\n        <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">==</span> <span class=\"n\">tmp</span><span class=\"p\">)</span> <span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"k\">else</span> <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">==</span> <span class=\"n\">tmp</span><span class=\"p\">)</span> <span class=\"n\">fl</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span> <span class=\"o\">=</span> <span class=\"n\">tmp</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">;</span>\n        <span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">tmp</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/2021/10/05/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%BA%8C-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91-BST/'> <img src='/en/images/covers/数据结构-cover1.png' alt='二叉树基础（二）二叉搜索树（BST）'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>4 min read <time class='article__date' datetime='2021-10-05T04:14:28+11:00'>Oct 5, 2021</time> </span> </div><h2 class='article__title'>二叉树基础（二）二叉搜索树（BST）</h2> <p class='article__excerpt'>二叉树（Binary tree）是指树中节点的度不大于2的有序树，它是一种最简单且最重要的树。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/数据结构' class='article__tag'>数据结构</a>  <a href='/en/tag/二叉树' class='article__tag'>二叉树</a>  <a href='/en/tag/树型数据结构' class='article__tag'>树型数据结构</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（三）股票问题系列",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 29, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#121-买卖股票的最佳时机\" id=\"markdown-toc-121-买卖股票的最佳时机\">121. 买卖股票的最佳时机</a>    <ol>\n      <li><a href=\"#状态转移方程\" id=\"markdown-toc-状态转移方程\">状态转移方程</a>        <ol>\n          <li><a href=\"#如何表示price_min\" id=\"markdown-toc-如何表示price_min\">如何表示$price_{min}$</a></li>\n          <li><a href=\"#边界条件\" id=\"markdown-toc-边界条件\">边界条件</a></li>\n        </ol>\n      </li>\n      <li><a href=\"#代码\" id=\"markdown-toc-代码\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#122-买卖股票的最佳时机-ii\" id=\"markdown-toc-122-买卖股票的最佳时机-ii\">122. 买卖股票的最佳时机 II</a>    <ol>\n      <li><a href=\"#状态转移方程-1\" id=\"markdown-toc-状态转移方程-1\">状态转移方程</a></li>\n      <li><a href=\"#代码-1\" id=\"markdown-toc-代码-1\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#714-买卖股票的最佳时机含手续费\" id=\"markdown-toc-714-买卖股票的最佳时机含手续费\">714. 买卖股票的最佳时机含手续费</a>    <ol>\n      <li><a href=\"#状态转移方程-2\" id=\"markdown-toc-状态转移方程-2\">状态转移方程</a></li>\n      <li><a href=\"#代码-2\" id=\"markdown-toc-代码-2\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#309-最佳买卖股票时机含冷冻期\" id=\"markdown-toc-309-最佳买卖股票时机含冷冻期\">309. 最佳买卖股票时机含冷冻期</a>    <ol>\n      <li><a href=\"#状态转移方程-3\" id=\"markdown-toc-状态转移方程-3\">状态转移方程</a></li>\n      <li><a href=\"#代码-3\" id=\"markdown-toc-代码-3\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#123-买卖股票的最佳时机-iii\" id=\"markdown-toc-123-买卖股票的最佳时机-iii\">123. 买卖股票的最佳时机 III</a>    <ol>\n      <li><a href=\"#思路\" id=\"markdown-toc-思路\">思路</a></li>\n      <li><a href=\"#代码-4\" id=\"markdown-toc-代码-4\">代码</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#188-买卖股票的最佳时机-iv\" id=\"markdown-toc-188-买卖股票的最佳时机-iv\">188. 买卖股票的最佳时机 IV</a></li>\n  <li><a href=\"#股票问题的一般通解\" id=\"markdown-toc-股票问题的一般通解\">股票问题的一般通解</a>    <ol>\n      <li><a href=\"#状态转移方程-4\" id=\"markdown-toc-状态转移方程-4\">状态转移方程</a>        <ol>\n          <li><a href=\"#边界条件-1\" id=\"markdown-toc-边界条件-1\">边界条件</a></li>\n        </ol>\n      </li>\n    </ol>\n  </li>\n  <li><a href=\"#结束语\" id=\"markdown-toc-结束语\">结束语</a></li>\n</ol>\n\n<h2 id=\"121-买卖股票的最佳时机\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock/\">121. 买卖股票的最佳时机</a></h2>\n<h3 id=\"状态转移方程\">状态转移方程</h3>\n<p>我们可以用$dp[i]$来表示，在前$i$日我们可以得到的最大利润，那么我们第$i$日的操作有两种选择：</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>1.我们在第i日卖出得到的利润可能比之前的利润（dp[i-1]）更高\n2.我们之前的利润要比现在更高，不用进行任何操作\n</code></pre></div></div>\n\n<p>对于情况1，我们得到状态转移方程$dp[i]=prices[i]-price_{min}$\n而对于情况2，我们有$dp[i]=dp[i-1]$\n综合两种情况，也就得到此题的状态转移方程：</p>\n\n<p>$dp[i]=max(dp[i-1],prices[i]-price_{min})$</p>\n\n<p>那么剩下的问题就在于如何表示$price_{min}$。</p>\n\n<h4 id=\"如何表示price_min\">如何表示$price_{min}$</h4>\n<p>我们发现，$price_{min}$的计算也是一个无后效性的问题，我们同样可以通过动态规划来求解，用$dp_{price_{min}}[i]$来表示前i日股票的最低价格，则$dp_{price_{min}}[i]$的状态转移方程可以写成：</p>\n\n<p>$dp_{price_{min}}[i]$ = $min(prices[i],dp_{price_{min}}[i-1])$</p>\n\n<p>可能这时候你就要说了，你这不是脱了裤子放屁吗？那我们不妨换一个思维方式，还是上面的状态转移方程不变，<strong>我们用$dp[i][j]$表示前$i$天手上有$j$个股票时我们的最大利润。</strong> 这时候你不妨停下来思考一会，该如何写出状态转移方程呢？</p>\n\n<p>联立上面两个转移方程，得到$dp[i][j]$的状态转移方程：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$\n$dp[i][1] = max(-prices[i], dp[i - 1][1]);$</p>\n\n<p>没错，此时的$dp[i][1]$就是之前我们的开销，用来辅助我们计算第$i$天的最大利润，也就是$dp[i][0]$</p>\n\n<h4 id=\"边界条件\">边界条件</h4>\n<p>$dp[0][0]$表示在第0天我们手上有0支股票时的最大利润，因此$dp[0][0]=0$</p>\n\n<p>$dp[0][1]$表示在第0天我们手上有1支股票时的最大利润，因此$dp[0][0]=-prices[0]$</p>\n\n<h3 id=\"代码\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span> \n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>篇幅关系，空间复杂度的优化留给读者自己思考，我这里不作展开</p>\n\n<h2 id=\"122-买卖股票的最佳时机-ii\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii/\">122. 买卖股票的最佳时机 II</a></h2>\n<h3 id=\"状态转移方程-1\">状态转移方程</h3>\n<p>122.题与121.题的不同点在于，122.是可以无限进行购买操作的，相应的，我们的状态转移方程也有所改变。</p>\n\n<p>根据我们第一题的状态转移方程，在第一题里，一但我们前面卖出了股票，下次再想购买股票时，总利润便会变成$-prices[i]$，但在这道题中，由于我们不再受购买次数的限制，因此我们的利润就可以一直累计下去，如何理解这种累计呢？</p>\n\n<p>在前$i-1$天，我们的最大利润达到了$dp[i-1][0]$，而在第$i$天我们要购入股票，此时的利润就会变为$dp[i-1][0]-prices[i]$</p>\n\n<p>即$dp[i][1]$的状态转移方程变为：</p>\n\n<p>$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$</p>\n\n<p>读者应该也注意到，在我们把状态转移方程分成两部分后，我们对转移方程的解读方式也转变了，这里我再次阐述一遍，$dp[i][0]$表示手上没有股票时的最大利润，$dp[i][1]$表示手上有一枚股票时的最大利润。</p>\n\n<p>综上，状态转移方程为：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i]+dp[i - 1][1]);$\n$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$</p>\n\n<p>边界条件与之前相同。</p>\n\n<h3 id=\"代码-1\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"714-买卖股票的最佳时机含手续费\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/\">714. 买卖股票的最佳时机含手续费</a></h2>\n<h3 id=\"状态转移方程-2\">状态转移方程</h3>\n<p>如果你认真阅读了题714.并理解了题122.那这道题你其实可以直接过的，因为这道题和题122.的不同之处就在于，它在售卖时多了手续费这个固定消耗，因此在决定卖出股票的第$i$天里，如果收益不足以抵消掉手续费，那我们会选择之前的利润作为最优解，即：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$</p>\n\n<p>整体的转移方程表示为：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], prices[i] - fee+dp[i - 1][1]);$\n$dp[i][1] = max(dp[i-1][0]-prices[i], dp[i - 1][1]);$</p>\n\n<p>边界条件仍与之前相同</p>\n\n<h3 id=\"代码-2\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">fee</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">fee</span><span class=\"p\">),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"309-最佳买卖股票时机含冷冻期\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-with-cooldown/\">309. 最佳买卖股票时机含冷冻期</a></h2>\n<h3 id=\"状态转移方程-3\">状态转移方程</h3>\n<p>这道题的变化在于，之前我们只有$(0)$卖出、$(1)$买入两种状态，但这道题引入了一个新的新的状态$(2)$冷冻期，而这个冷冻期状态是在卖出操作后出现，如果我们用$dp[i][2]$来表示当我们在第$i$天的冷冻期收益，则$dp[i][2]$可以用$dp$表示为：</p>\n\n<p>$dp[i][2] = dp[i-1][0]$</p>\n\n<p>买入状态的转移方程也有所变化，因为此题中买入状态必须由冷冻期状态进入，也就是：</p>\n\n<p>$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$</p>\n\n<p>最后，综合三式就可以得到我们新的状态转移方程：</p>\n\n<p>$dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i])$\n$dp[i][1] = max(dp[i - 1][2]-prices[i], dp[i - 1][1])$\n$dp[i][2] = dp[i - 1][0]$</p>\n\n<p>边界条件仍然不变</p>\n\n<h3 id=\"代码-3\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n     <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n     <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">3</span><span class=\"p\">];</span>\n     <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n     <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]),</span> <span class=\"c1\">//</span>\n         <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n     <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"123-买卖股票的最佳时机-iii\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/\">123. 买卖股票的最佳时机 III</a></h2>\n<h3 id=\"思路\">思路</h3>\n<p>如果没有前面的铺垫直接来看这道题，难度瞬间就高起来了。但现在带着前面的经验再来对比这道题，我们会发现这道题和题121. 题122.有着很大的关联。</p>\n\n<p>假设在第$i$天卖出了股票，当我们是第一次或第二次操作时，我们的利润是可以积累的。但如果是在第三次操作，那么我们就要重新累计利润了。</p>\n\n<p>我们不妨将$dp$升到三维数组，用第三维来区分第一次操作和第二次操作，即得到代码如下：</p>\n<h3 id=\"代码-4\">代码</h3>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">100100</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">];</span>\n    <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">){</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]);</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">]),</span>\n        <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">]</span><span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">]);</span>\n    <span class=\"p\">}</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n<p>这个代码并不优雅，但对于问题的解决无疑是直接而有效的</p>\n\n<h2 id=\"188-买卖股票的最佳时机-iv\"><a href=\"https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv/\">188. 买卖股票的最佳时机 IV</a></h2>\n\n<p>当问题扩充到$k$时，我们解决题123.的思路仍然有效，我们可以用初始化边界为$0$，再用一个$for$循环写出结果。</p>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code> <span class=\"kt\">int</span> <span class=\"nf\">maxProfit</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;&amp;</span> <span class=\"n\">prices</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">empty</span><span class=\"p\">())</span> <span class=\"k\">return</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n    <span class=\"k\">const</span> <span class=\"kt\">int</span> <span class=\"n\">MAX</span> <span class=\"o\">=</span> <span class=\"mi\">1100</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">][</span><span class=\"mi\">2</span><span class=\"p\">][</span><span class=\"mi\">110</span><span class=\"p\">]</span><span class=\"o\">=</span><span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">};</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">k</span><span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"o\">-</span><span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">];</span>\n    <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">i</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">i</span> <span class=\"o\">&lt;</span> <span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">();</span> <span class=\"n\">i</span><span class=\"o\">++</span><span class=\"p\">)</span>\n        <span class=\"k\">for</span><span class=\"p\">(</span><span class=\"kt\">int</span>  <span class=\"n\">j</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span> <span class=\"n\">j</span> <span class=\"o\">&lt;=</span> <span class=\"n\">k</span> <span class=\"p\">;</span> <span class=\"n\">j</span><span class=\"o\">++</span><span class=\"p\">)</span>\n            <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">+</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]),</span>\n            <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">prices</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">],</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"n\">j</span><span class=\"p\">]);</span>\n    <span class=\"k\">return</span> <span class=\"n\">dp</span><span class=\"p\">[</span><span class=\"n\">prices</span><span class=\"p\">.</span><span class=\"n\">size</span><span class=\"p\">()</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">][</span><span class=\"mi\">0</span><span class=\"p\">][</span><span class=\"n\">k</span><span class=\"p\">];</span>\n <span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h2 id=\"股票问题的一般通解\">股票问题的一般通解</h2>\n<h3 id=\"状态转移方程-4\">状态转移方程</h3>\n<p>股票问题的三个限定条件是</p>\n\n<ul>\n  <li>当前天数$i$</li>\n  <li>手持股票$j$</li>\n  <li>允许的最大操作次数$k$</li>\n</ul>\n\n<p>我们设在第$i$天，手持股票为$j$，操作次数为$k$时我们的利润为$dp[i][j][k]$，视每次购买股票为进行一次操作，则我们的状态转移方程为：</p>\n\n<p>$dp[i][0][k] = max(dp[i-1][1][k] + prices[i], dp[i-1][0][k])$\n$dp[i][1][k] = max(dp[i-1][0][k-1] - prices[i], dp[i-1][1][k])$</p>\n\n<h4 id=\"边界条件-1\">边界条件</h4>\n<p>$dp[0][1][k] = -prices[0]$\n其余值都为0</p>\n\n<h2 id=\"结束语\">结束语</h2>\n<p>股票问题系列和打家劫舍系列的不同点在于，股票问题的每一个系列问题都对状态转移方程进行了改动。面临一道动态规划问题时，要想迅速找到子问题并写出状态转移方程，关键还是要多了解不同的动归题型。</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/29/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%89-%E8%82%A1%E7%A5%A8%E9%97%AE%E9%A2%98%E7%B3%BB%E5%88%97/'> <img src='/en/images/covers/village.jpg' alt='动态规划（三）股票问题系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>8 min read <time class='article__date' datetime='2021-09-29T22:29:46+10:00'>Sep 29, 2021</time> </span> </div><h2 class='article__title'>动态规划（三）股票问题系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "Binary Tree Basics (Part 1) - Understanding Binary Trees",
      "category" : "Fundamentals of Data Structures",
      "tags"     : "Algorithm, Data Structures, Binary Tree, and Tree Data Structures",
      "url"      : "/en/fundamentals%20of%20data%20structures/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/",
      "date"     : "Sep 28, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#introduction\" id=\"markdown-toc-introduction\">Introduction</a>    <ol>\n      <li><a href=\"#definition-of-binary-tree\" id=\"markdown-toc-definition-of-binary-tree\">Definition of Binary Tree</a></li>\n      <li><a href=\"#basic-forms\" id=\"markdown-toc-basic-forms\">Basic Forms</a></li>\n      <li><a href=\"#special-types\" id=\"markdown-toc-special-types\">Special Types</a></li>\n      <li><a href=\"#related-terminology\" id=\"markdown-toc-related-terminology\">Related Terminology</a></li>\n      <li><a href=\"#properties\" id=\"markdown-toc-properties\">Properties</a></li>\n    </ol>\n  </li>\n  <li><a href=\"#implementing-binary-trees-in-c\" id=\"markdown-toc-implementing-binary-trees-in-c\">Implementing Binary Trees in C++</a>    <ol>\n      <li><a href=\"#sequential-storage-of-binary-trees\" id=\"markdown-toc-sequential-storage-of-binary-trees\">Sequential Storage of Binary Trees</a>        <ol>\n          <li><a href=\"#implementation-code\" id=\"markdown-toc-implementation-code\">Implementation Code</a></li>\n        </ol>\n      </li>\n      <li><a href=\"#linked-storage-of-binary-trees\" id=\"markdown-toc-linked-storage-of-binary-trees\">Linked Storage of Binary Trees</a>        <ol>\n          <li><a href=\"#implementation-code-1\" id=\"markdown-toc-implementation-code-1\">Implementation Code</a></li>\n        </ol>\n      </li>\n      <li><a href=\"#recursive-traversal-of-binary-trees\" id=\"markdown-toc-recursive-traversal-of-binary-trees\">Recursive Traversal of Binary Trees</a>        <ol>\n          <li><a href=\"#preorder-traversal-dlr\" id=\"markdown-toc-preorder-traversal-dlr\">Preorder Traversal (DLR)</a></li>\n          <li><a href=\"#inorder-traversal-ldr\" id=\"markdown-toc-inorder-traversal-ldr\">Inorder Traversal (LDR)</a></li>\n          <li><a href=\"#postorder-traversal-lrd\" id=\"markdown-toc-postorder-traversal-lrd\">Postorder Traversal (LRD)</a></li>\n        </ol>\n      </li>\n    </ol>\n  </li>\n</ol>\n\n<h2 id=\"introduction\">Introduction</h2>\n<p>A binary tree is a crucial type of tree structure. Many data structures abstracted from practical problems often take the form of binary trees. Even general trees can be easily converted into binary trees, and the storage structure and algorithms for binary trees are relatively simple. Hence, binary trees are particularly important. The defining characteristic of a binary tree is that each node can have at most two child nodes, with a distinction between left and right.</p>\n\n<h3 id=\"definition-of-binary-tree\">Definition of Binary Tree</h3>\n<p>A binary tree is a type of ordered tree in which the degree of each node is at most 2. It is the simplest and most important tree structure. The recursive definition of a binary tree states that a binary tree is either an empty tree or a tree formed by a root node and two disjoint, mutually exclusive binary trees called the left subtree and the right subtree.</p>\n\n<h3 id=\"basic-forms\">Basic Forms</h3>\n<p><img src=\"/images/posts/tree1.png\" alt=\"Binary Tree Forms\" /></p>\n<ul>\n  <li>Empty binary tree</li>\n  <li>Binary tree with only one root node</li>\n  <li>Binary tree with only a left subtree of the root node</li>\n  <li>Binary tree with only a right subtree of the root node</li>\n  <li><strong>Complete binary tree</strong> with both left and right subtrees of the root node\n    <h3 id=\"special-types\">Special Types</h3>\n  </li>\n  <li>Full binary tree: A tree where each node has either 0 or 2 children, and nodes with 0 children are at the same level.</li>\n  <li>Complete binary tree: A binary tree of depth k where each node is in the same level as the nodes of a full binary tree of depth k, numbered from 1 to n.\n<img src=\"/images/posts/tree2.png\" alt=\"Complete Binary Tree\" />\n    <h3 id=\"related-terminology\">Related Terminology</h3>\n  </li>\n  <li>Node: Contains a data element and information pointing to child subtrees.</li>\n  <li>Node degree: The number of child subtrees a node has.</li>\n  <li>Leaf node: Also known as a terminal node, it has no child subtrees or has a degree of 0.</li>\n  <li>Branch node: Also known as a non-terminal node, it has a degree greater than 0.</li>\n  <li>Tree degree: The maximum degree among all nodes in the tree.</li>\n  <li>Node level: Starting from the root node, where the root node is at level 0, its children are at level 1, and so on.</li>\n  <li>Tree depth: Also known as the height of the tree, it is the maximum level among all nodes in the tree.</li>\n  <li>Ordered tree: If the subtrees of a tree have a specific sequence, the tree is ordered.</li>\n  <li>Unordered tree: If the subtrees of a tree have no specific sequence, the tree is unordered.</li>\n  <li>Forest: A collection of m (m≥0) disjoint trees. Removing the root node of a non-empty tree turns it into a forest, where each tree consists of the original root node’s subtrees.\n    <h3 id=\"properties\">Properties</h3>\n  </li>\n  <li>A binary tree’s ith level can have at most $2^i$ nodes $(i≥0)$.</li>\n  <li>A binary tree of depth k can have at most $2^{k+1}-1$ nodes $(k≥0)$.</li>\n  <li>For a binary tree with n nodes, if the number of nodes with a degree of 0 is $n_0$ and with a degree of 2 is $n_2$, then $n_0=n_2+1$.</li>\n  <li>Full binary tree theorem: The number of leaf nodes in a non-empty full binary tree equals the number of internal nodes $+1$.</li>\n  <li>Corollary of full binary tree theorem: In a binary tree with n nodes, the number of null subtrees equals $n+1$.</li>\n  <li>The height of a complete binary tree with n nodes is $log_2(n+1)$, and the depth is $log_2(n+1)-1$.</li>\n</ul>\n\n<h2 id=\"implementing-binary-trees-in-c\">Implementing Binary Trees in C++</h2>\n\n<h3 id=\"sequential-storage-of-binary-trees\">Sequential Storage of Binary Trees</h3>\n\n<p>We can use an array to store all the nodes. The root node is stored at index 0, and its left child is stored at index $2<em>0+1$, and its right child is stored at index $2</em>0+2$, and so on. For a node with index i, its left and right children are stored at indexes $2<em>i+1$ and $2</em>i+2$, respectively.</p>\n\n<h4 id=\"implementation-code\">Implementation Code</h4>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"kt\">int</span> <span class=\"n\">BinaryTree</span><span class=\"p\">[</span><span class=\"n\">MAX</span><span class=\"p\">];</span>\n<span class=\"kt\">void</span> <span class=\"nf\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">i</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">&gt;=</span> <span class=\"n\">MAX</span><span class=\"p\">)</span> <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"kt\">int</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"n\">cin</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">tree</span><span class=\"p\">[</span><span class=\"n\">i</span><span class=\"p\">];</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"o\">*</span><span class=\"n\">i</span><span class=\"o\">+</span><span class=\"mi\">2</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"linked-storage-of-binary-trees\">Linked Storage of Binary Trees</h3>\n\n<p>Sequential storage is generally suitable for complete binary trees. Typically, we use linked storage to represent binary trees.</p>\n\n<h4 id=\"implementation-code-1\">Implementation Code</h4>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"k\">typedef</span> <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">data</span><span class=\"p\">;</span>                     <span class=\"c1\">// Data</span>\n    <span class=\"k\">struct</span> <span class=\"nc\">Node</span> <span class=\"o\">*</span><span class=\"n\">lchild</span><span class=\"p\">,</span> <span class=\"o\">*</span><span class=\"n\">rchild</span><span class=\"p\">;</span> <span class=\"c1\">// Left and right subtrees</span>\n<span class=\"p\">}</span> <span class=\"o\">*</span> <span class=\"n\">BinaryTree</span><span class=\"p\">,</span> <span class=\"n\">BtNode</span><span class=\"p\">;</span>\n\n<span class=\"kt\">void</span> <span class=\"nf\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"o\">&amp;</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"kt\">int</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"n\">cin</span> <span class=\"o\">&gt;&gt;</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">input</span> <span class=\"o\">==</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"nb\">NULL</span><span class=\"p\">;</span>\n        <span class=\"k\">return</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n    <span class=\"n\">tree</span> <span class=\"o\">=</span> <span class=\"k\">new</span> <span class=\"n\">BtNode</span><span class=\"p\">;</span>\n    <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">=</span> <span class=\"n\">input</span><span class=\"p\">;</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n    <span class=\"n\">CreateBinaryTree</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h3 id=\"recursive-traversal-of-binary-trees\">Recursive Traversal of Binary Trees</h3>\n\n<h4 id=\"preorder-traversal-dlr\">Preorder Traversal (DLR)</h4>\n<p>If the binary tree is empty, do nothing. Otherwise:</p>\n\n<ol>\n  <li>Visit the current node.</li>\n  <li>Traverse the left subtree in preorder.</li>\n  <li>Traverse the right subtree in preorder.</li>\n</ol>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">DLR</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"n\">DLR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n        <span class=\"n\">DLR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4 id=\"inorder-traversal-ldr\">Inorder Traversal (LDR)</h4>\n<p>If the binary tree is empty, do nothing. Otherwise:</p>\n\n<ol>\n  <li>Traverse the left subtree in inorder.</li>\n  <li>Visit the current node.</li>\n  <li>Traverse the right subtree in inorder.</li>\n</ol>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">LDR</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">LDR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n        <span class=\"n\">LDR</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n\n<h4 id=\"postorder-traversal-lrd\">Postorder Traversal (LRD)</h4>\n<p>If the binary tree is empty, do nothing. Otherwise:</p>\n\n<ol>\n  <li>Traverse the left subtree in postorder.</li>\n  <li>Traverse the right subtree in postorder.</li>\n  <li>Visit the current node.</li>\n</ol>\n\n<div class=\"language-cpp highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code><span class=\"kt\">void</span> <span class=\"nf\">LRD</span><span class=\"p\">(</span><span class=\"n\">BinaryTree</span> <span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n        <span class=\"n\">LRD</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">lchild</span><span class=\"p\">);</span>\n        <span class=\"n\">LRD</span><span class=\"p\">(</span><span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">rchild</span><span class=\"p\">);</span>\n        <span class=\"n\">cout</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">tree</span><span class=\"o\">-&gt;</span><span class=\"n\">data</span> <span class=\"o\">&lt;&lt;</span> <span class=\"n\">endl</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n<span class=\"p\">}</span>\n</code></pre></div></div>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/fundamentals%20of%20data%20structures/2021/09/28/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E7%A1%80-%E4%B8%80-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%A6%82%E5%BF%B5/'> <img src='/en/images/covers/数据结构-cover1.png' alt='Binary Tree Basics (Part 1) - Understanding Binary Trees'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>6 min read <time class='article__date' datetime='2021-09-28T15:58:19+10:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>Binary Tree Basics (Part 1) - Understanding Binary Trees</h2> <p class='article__excerpt'>A binary tree is a fundamental type of tree structure where each node has at most two child nodes, making it one of the simplest and most important trees.</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/Algorithm' class='article__tag'>Algorithm</a>  <a href='/en/tag/Data Structures' class='article__tag'>Data Structures</a>  <a href='/en/tag/Binary Tree' class='article__tag'>Binary Tree</a>  <a href='/en/tag/Tree Data Structures' class='article__tag'>Tree Data Structures</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（二）最优子序列系列",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 28, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#动态规划核心思想\" id=\"markdown-toc-动态规划核心思想\">动态规划核心思想</a></li>\n  <li><a href=\"#198-打家劫舍\" id=\"markdown-toc-198-打家劫舍\">198. 打家劫舍</a></li>\n</ol>\n\n<h2 id=\"动态规划核心思想\">动态规划核心思想</h2>\n<p>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p>\n\n<p>动态规划基础</p>\n\n<p>我们可以举个例子：</p>\n\n<blockquote>\n  <p>A: 1+1+1+1+1+1+1+1 = ?</p>\n\n  <p>B ( 计算 ) : 8</p>\n\n  <p>A: 在上面等式的左边写上 “1+” 呢？</p>\n\n  <p>B (脱口而出): 9</p>\n\n  <p>A: 你怎么这么快就得到答案了？</p>\n\n  <p>B: 只要在8的基础上加1就好了</p>\n\n  <p>A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间</p>\n</blockquote>\n\n<h2 id=\"198-打家劫舍\"><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. 打家劫舍</a></h2>\n\n<ol>\n  <li>只有一间房屋时，我们选择偷这间房屋</li>\n  <li>存在两间房屋时，选择偷两间中较大的那间</li>\n  <li>如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间</li>\n  <li>将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：\n    <ol>\n      <li>偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和</li>\n      <li>不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额</li>\n    </ol>\n  </li>\n</ol>\n\n<p>我们总会选择1、2中可以得到更高金额的选项，这时我们用$d[i]$来表示偷窃前i间房子的总金额，并且用$d[i]$来表示选项1、2:</p>\n\n\\[\\begin{equation}\n\\left\\{\n\\begin{aligned}\n%\\nonumber\n&amp;d[i] = d[i-2] + nums[i], \\\\\n&amp;d[i] = d[i-1].\n\\end{aligned}\n\\right.\n\\end{equation}\\]\n\n<p>hello</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/28/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%BA%8C-%E6%9C%80%E4%BC%98%E5%AD%90%E5%BA%8F%E5%88%97%E7%B3%BB%E5%88%97/'> <img src='/en/images/covers/village.jpg' alt='动态规划（二）最优子序列系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-28T13:12:38+10:00'>Sep 28, 2021</time> </span> </div><h2 class='article__title'>动态规划（二）最优子序列系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "动态规划（一）打家劫舍系列",
      "category" : "动态规划基础",
      "tags"     : "算法 and 动态规划",
      "url"      : "/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/",
      "date"     : "Sep 27, 2021",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#动态规划核心思想\" id=\"markdown-toc-动态规划核心思想\">动态规划核心思想</a></li>\n  <li><a href=\"#198-打家劫舍\" id=\"markdown-toc-198-打家劫舍\">198. 打家劫舍</a></li>\n</ol>\n\n<h2 id=\"动态规划核心思想\">动态规划核心思想</h2>\n<p>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p>\n\n<p>我们可以举个例子：</p>\n\n<blockquote>\n  <p>A: 1+1+1+1+1+1+1+1 = ?</p>\n\n  <p>B (计算) : 8</p>\n\n  <p>A: 在上面等式的左边写上 “1+” 呢？</p>\n\n  <p>B (脱口而出): 9</p>\n\n  <p>A: 你怎么这么快就得到答案了？</p>\n\n  <p>B: 只要在8的基础上加1就好了</p>\n\n  <p>A: 所以你不用重新计算，因为你记住了第一个等式的值为8。动态规划算法也可以说是记住求过的解来节省时间</p>\n</blockquote>\n\n<h2 id=\"198-打家劫舍\"><a href=\"https://leetcode-cn.com/problems/house-robber/\">198. 打家劫舍</a></h2>\n\n<ol>\n  <li>只有一间房屋时，我们选择偷这间房屋</li>\n  <li>存在两间房屋时，选择偷两间中较大的那间</li>\n  <li>如果房屋数量大于两间时，比如第三间，我们要考虑，第一间和第三间房屋的价值总和与第二间房屋的价值相比，哪个更大？如果第一间和第三间房屋的价值总和较大的话，我们会选择偷第一间和第三间；否则，我们则会选择不偷第一间和第三间，去偷第二间</li>\n  <li>将其推广到一般情况，对于前i间房子，我们偷窃的方案有两种：\n    <ol>\n      <li>偷窃第i间房子，得到的总金额是第i间房子的价值与偷窃前i-2间房子的总金额之和</li>\n      <li>不偷窃第i间房子，得到的总金额是偷窃前i-1间房子的总金额</li>\n    </ol>\n  </li>\n</ol>\n\n<p>我们总会选择1、2中可以得到更高金额的选项，这时我们用\\(d[i]\\)来表示偷窃前i间房子的总金额，并且用\\(d[i]\\)来表示选项1、2:</p>\n\n\\[\\begin{equation}\n\\left\\{\n\\begin{aligned}\n%\\nonumber\n&amp;d[i] = d[i-2] + nums[i], \\\\\n&amp;d[i] = d[i-1].\n\\end{aligned}\n\\right.\n\\end{equation}\\]\n\n<p>hello</p>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%9F%BA%E7%A1%80/2021/09/27/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92-%E4%B8%80-%E6%89%93%E5%AE%B6%E5%8A%AB%E8%88%8D%E7%B3%BB%E5%88%97/'> <img src='/en/images/covers/village.jpg' alt='动态规划（一）打家劫舍系列'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>1 min read <time class='article__date' datetime='2021-09-27T22:12:45+10:00'>Sep 27, 2021</time> </span> </div><h2 class='article__title'>动态规划（一）打家劫舍系列</h2> <p class='article__excerpt'>动态规划最核心的思想，就在于将问题拆分为一个个子问题，保留之前的计算结果，以达到减少计算量的效果。</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/算法' class='article__tag'>算法</a>  <a href='/en/tag/动态规划' class='article__tag'>动态规划</a> </span></div></div></div></div></div>"
       } ,
  
    {
      "title"    : "One-Click Hanmu on Sunshine Sports Platform",
      "category" : "",
      "tags"     : "Computer Networking",
      "url"      : "/en/2019/10/11/%E9%98%B3%E5%85%89%E4%BD%93%E8%82%B2%E4%B8%80%E9%94%AE%E6%B1%89%E5%A7%86/",
      "date"     : "Oct 11, 2019",
      "content"  : "<ol id=\"markdown-toc\">\n  <li><a href=\"#login-process\" id=\"markdown-toc-login-process\">Login Process</a></li>\n  <li><a href=\"#applying-for-a-run\" id=\"markdown-toc-applying-for-a-run\">Applying for a Run</a></li>\n  <li><a href=\"#ending-the-run\" id=\"markdown-toc-ending-the-run\">Ending the Run</a></li>\n  <li><a href=\"#password-table\" id=\"markdown-toc-password-table\">Password Table</a></li>\n</ol>\n\n<p>This blog introduces a method for completing Hanmu on the Sunshine Sports platform using HTTP requests. Compared to virtual positioning, this method is faster and more convenient.</p>\n\n<p>This blog is inspired by Senior Li Ye’s project. <a href=\"https://github.com/HackerLiye/fuckhanmu\">Click here</a> to visit the project.</p>\n\n<h2 id=\"login-process\">Login Process</h2>\n\n<p>The login process is about <strong>acquiring the <code class=\"language-plaintext highlighter-rouge\">token</code></strong>. During this process, the user’s <code class=\"language-plaintext highlighter-rouge\">IMEI</code> is required.</p>\n\n<p><code class=\"language-plaintext highlighter-rouge\">IMEI</code> is a <strong>32-bit hexadecimal number</strong> that can be captured during the login process on the Sunshine Sports platform.</p>\n\n<p>During the login process, we need to pass the <code class=\"language-plaintext highlighter-rouge\">IMEI</code> as a parameter, like this:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://client3.aipao.me/api/{token}/QM_Users/Login_AndroidSchool?IMEICode=00000000000000000000000000000000\n</code></pre></div></div>\n\n<p>At the same time, we need to include the current version of <strong>LePao (<code class=\"language-plaintext highlighter-rouge\">version</code>)</strong> in the header. Usually, the version is 2.40.</p>\n\n<p>This HTTP request will fetch a <code class=\"language-plaintext highlighter-rouge\">json</code>, where the <code class=\"language-plaintext highlighter-rouge\">token</code> under <code class=\"language-plaintext highlighter-rouge\">Data</code> is the value we need to obtain.</p>\n\n<h2 id=\"applying-for-a-run\">Applying for a Run</h2>\n\n<p>The running process requires a request based on the previously obtained <code class=\"language-plaintext highlighter-rouge\">token</code>. The link and parameters for the request are as follows:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://client3.aipao.me/api/{token}/QM_Runs/SRS?S1=30.534737&amp;S2=114.367785&amp;S3=2000\n</code></pre></div></div>\n\n<p>You can notice that there are three parameters: S1, S2, and S3, representing the <strong>latitude and longitude</strong> of the running location and the <strong>distance</strong> respectively.</p>\n\n<p>The parameters used in the above link represent the track of the Wuhan University Information School playground and a 2000-meter distance.</p>\n\n<p>After sending this request, you will receive a <code class=\"language-plaintext highlighter-rouge\">RunId</code> and enter the running state.</p>\n\n<h2 id=\"ending-the-run\">Ending the Run</h2>\n\n<p>In Li Ye’s code, there is a process of waiting for the run to finish. This is to ensure the accuracy and consistency of the data. However, in practical testing, we found that we don’t actually need to wait for the run to finish. We can directly request the end of the run to submit the Hanmu result.</p>\n\n<p>The link for this request is as follows:</p>\n\n<div class=\"language-plaintext highlighter-rouge\"><div class=\"highlight\"><pre class=\"highlight\"><code>http://client3.aipao.me/api/{token}/QM_Runs/ES\n</code></pre></div></div>\n\n<p>At this point, several parameters need to be submitted, let’s explain them one by one:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Parameter</th>\n      <th>Meaning</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>S1</td>\n      <td>RunId obtained during the run application</td>\n    </tr>\n    <tr>\n      <td>S4</td>\n      <td>Time spent on running, reasonable value</td>\n    </tr>\n    <tr>\n      <td>S5</td>\n      <td>Actual running distance, usually 1 to 2 meters more than the theoretical distance</td>\n    </tr>\n    <tr>\n      <td>S8</td>\n      <td>Password table, will be explained later</td>\n    </tr>\n    <tr>\n      <td>S9</td>\n      <td>Number of steps, reasonable value</td>\n    </tr>\n  </tbody>\n</table>\n\n<h2 id=\"password-table\">Password Table</h2>\n\n<p>In the parameters for ending the run, all integer parameters are encrypted using a password table. The principle is similar to the Caesar cipher, where numbers and letters correspond one-to-one. When submitting, both the ciphertext and the password table are submitted simultaneously.</p>\n\n<p>When submitting, we must <strong>ensure that the password table corresponds correctly to the numbers</strong> for successful submission.</p>\n\n<p>Here’s an example of encrypting the running distance:</p>\n\n<table>\n  <thead>\n    <tr>\n      <th>Actual Value</th>\n      <th>Encrypted Value</th>\n      <th>Password Table</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>2000</td>\n      <td>caaa</td>\n      <td>abcdefghijklmnopqrstuvwxyz</td>\n    </tr>\n    <tr>\n      <td>246</td>\n      <td>oqs</td>\n      <td>mnopqrstuvwxyzabcdefghijkl</td>\n    </tr>\n  </tbody>\n</table>\n",
      "article"  : "<div class='article col col-4 col-d-6 col-t-12 grid__post animate'> <div class='article__inner'><a class='article__image' href='/en/2019/10/11/%E9%98%B3%E5%85%89%E4%BD%93%E8%82%B2%E4%B8%80%E9%94%AE%E6%B1%89%E5%A7%86/'> <img src='/enhttps://src.onlinedown.net/images/h_imges/wdj/3/logo/c76a697a57cfc446c777513a033e19b1_256_256.png' alt='One-Click Hanmu on Sunshine Sports Platform'> </a><div class='article__content'> <div class='article__meta'> <span class='article__minutes'>2 min read <time class='article__date' datetime='2019-10-11T14:59:11+11:00'>Oct 11, 2019</time> </span> </div><h2 class='article__title'>One-Click Hanmu on Sunshine Sports Platform</h2> <p class='article__excerpt'>This blog introduces a method for completing Hanmu (a type of running challenge) on the Sunshine Sports platform using HTTP requests. Compared to virtual positioning, this method is faster and more convenient.</p><div class='article__bottom'><div class='article__author'> <a href='/en/about/' aria-label='Mortalreminder PT'><img class='article__author-image' src='https://q.qlogo.cn/headimg_dl?dst_uin=2656453168&spec=140&img_type=jpg' alt='Mortalreminder PT's Picture'></a> </div><div class='article__bottom-meta'><a href='/en/about/' class='article__author-link'>Mortalreminder PT</a><span> in </span> <span class='article-tags'> <a href='/en/tag/Computer Networking' class='article__tag'>Computer Networking</a> </span></div></div></div></div></div>"
       } 
  
]
