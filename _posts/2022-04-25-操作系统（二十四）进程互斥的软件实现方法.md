---
layout: post 
title: 操作系统（二十四）进程互斥的软件实现方法
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-25 10:56:13 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 单标志法

算法思想：两个进程中，一个进程在**访问完临界区后**会把使用临界区的**权限转交**给另一个进程。
也就是说每个进程进入临界区的权限只能被另一个进程赋予。

```c
int turn = 0; // turn表示当前允许进入临界区的进程号

/* P0进程 */
while (turn != 0); // 1.进入区
critical section; // 2.临界区
turn = 1; // 3.退出区
remainder section; // 4.剩余区

/* P1进程 */
while (turn != 1); // 5.进入区
critical section; // 6.临界区
turn = 0; // 7.退出区
remainder section; // 8.剩余区
```

turn的初值为0，即刚开始只允许О号进程进入临界区。

若P1先上处理机运行，则会一直卡在5。
直到P1的时间片用完，发生调度，切换PO上处理机运行。
代码1不会卡住PO，PO可以正常访问临界区，在PO访问临界区期间即时切换回P1, P1依然会卡在5。

只有PO在退出区将turn改为1后，P1才能进入临界区。
因此，该算法**可以实现“同一时刻最多只允许一个进程访问临界区”**。

缺点：
只能按PO->P1->PO->P1这样轮流访问。
这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是PO，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。

因此，**单标志法**存在的主要问题是：**违背“空闲让进”原则。**

## 双标志先检查法
算法思想：设置一个布尔型数组`flag[0]`，数组中各个元素用来**标记各进程想进入临界区的意愿。**
比如`flag[0]=ture`意味着0号进程P0现在想要进入临界区。
每个进程在进入临界区之前先检查当前有没有别的进程想进入临界区，如果没有，则把自身对应的标志`flag[i]`设为`true`，之后开始访问临界区。

```c 
bool flag[2]; // 表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;

/* P0进程 */
while (flag[1]); // 1.
flag[0] = true; // 2.修改标记为想要进入临界区
critical section; // 3.临界区
flag[0] = false; // 4.退出区
remainder section; 

/* P1进程 */
while (flag[0]); // 5.
flag[1] = true; // 6.修改标记为想要进入临界区
critical section; // 7.临界区
flag[1] = false; // 8.退出区
remainder section; 
```

若按照152637的顺序执行，PO和P1将会同时访问临界区。

因此，**双标志先检查法**的主要问题是：**违反“忙则等待”原则。**

原因在于，**进入区**的“检查”和“上锁”**两个处理不是一气呵成**的。“检查”后，“上锁”前可能发生进程切换。

## 双标志后检查法

算法思想：双标志先检查法的改版。
前一个算法的问题是先“检查”后“上锁”，但是这两个操作又无法一气呵成，因此导致了两个进程同时进入临界区的问题。
因此，人们又想到先“上锁”后“检查”的方法，来避免上述问题。

```c 
bool flag[2]; // 表示进入临界区意愿的数组
flag[0] = false;
flag[1] = false;

/* P0进程 */
flag[0] = true; // 1.修改标记为想要进入临界区
while (flag[1]); // 2.如果P1也想进入临界区，则P0循环等待
critical section; // 3.临界区
flag[0] = false; // 4.退出区
remainder section; 

/* P1进程 */
flag[1] = true; // 5.修改标记为想要进入临界区
while (flag[0]); // 6.如果P0也想进入临界区，则P1循环等待
critical section; // 7.临界区
flag[1] = false; // 8.退出区
remainder section; 
```

若按照1526的顺序执行，P0和P1将都无法进入临界区。

因此，**双标志后检查法**虽然**解决了“忙则等待”的问题**，但是又**违背了“空闲让进”和“有限等待”原则**，会因各进程都长期无法访问临界资源而**产生“饥饿”**现象。

## Peterson算法

算法思想：结合双标志法、单标志法的思想。如果双方都争着想进入临界区，那可以让进程尝试谦让。

```c 
bool flag[2]; // 表示进入临界区意愿的数组
int turn = 0; // turn 表示优先让哪个线程进入临界区
flag[0] = false;
flag[1] = false;

/* P0进程 */
flag[0] = true; // 1.进入区，表示自己想要进入临界区
turn = 1; // 2.进入区，表示可以优先让对方进入临界区
while (flag[1] && turn == 1); // 3.进入区，如果对方想进且最后一次是自己谦让则进行循环等待
critical section; // 4.临界区
flag[0] = false; // 5.退出区，表示自己不想访问临界区
remainder section; 

/* P1进程 */
flag[1] = true; // 6.进入区，表示自己想要进入临界区
turn = 0; // 7.进入区，可以优先让对方进入临界区
while (flag[0] && turn == 0); // 8.进入区，如果对方想进且最后一次是自己谦让则进行循环等待
critical section; // 9.临界区
flag[1] = false; // 10.退出区，表示自己不想访问临界区
remainder section; 
```

**Peterson算法**用软件方法解决了进程互斥问题，**遵循了空闲让进、忙则等待、有限等待三个原则**，但是依然**未遵循让权等待的原则。**

Peterson算法相较于之前三种软件解决方案来说，是最好的，但依然不够好。
