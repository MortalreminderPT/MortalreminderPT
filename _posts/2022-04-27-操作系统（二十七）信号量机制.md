---
layout: post 
title: 操作系统（二十七）信号量机制
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-27 11:12:18 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 信号量的概念

用户进程可以通过使用操作系统提供的**一对原语**来对**信号量**进行操作，从而很方便地实现了进程互斥、进程同步。

**信号量**其实就是一个**变量**（可以是一个整数，也可以是更复杂的记录型变量），可以用一个信号量来**表示系统中某种资源的数量**。
比如：系统中只有一台打印机，就可以设置一个初值为1的信号量。

**原语**是一种特殊的**程序段**，其执行**只能一气呵成，不可被中断。**
原语是由**关中断/开中断指令**实现的。
软件解决方案的主要问题是由“进入区的各种操作无法一气呵成”，因此如果能把进入区、退出区的操作都用“原语”实现，使这些操作能“一气呵成”就能避免问题。

**一对原语**：`wait(S)`原语和`signal(S)`原语，可以把原语理解为我们自己写的函数，函数名分别为`wait`和`signal`，括号里的信号量S其实就是函数调用时传入的一个参数。

`wait`、`signal`原语常简称为**P、V操作**（来自荷兰语proberen和verhogen）。

## 整型信号量

用一个**整数型的变量**作为信号量，用来表示**系统中某种资源的数量**。

与普通整数变量的区别：对信号量的操作只有三种，即初始化、P操作、V操作。

```c
int S = 1; // 初始化整型信号量S，表示当前系统中可用的打印机资源数。

void wait(int S) {      // wait原语，相当于"进入区"
    while (S <= 0);     // 如果资源数不够，就一直循环等待
    S--;                // 如果资源数够，则占用一个资源
}

void signal(int S) {    // signal原语，相当于"退出区"
    S++;                // 使用完资源后，在退出区释放资源
}
```

整型信号量中，“检查”和“上锁”一气呵成，避免了并发、异步导致的问题。

存在的问题：**不满足“让权等待”原则**，会发生“忙等”。

## 记录型信号量

整型信号量的缺陷是存在“忙等”问题，因此人们又提出了“记录型信号量”，即用记录型数据结构表示的信号量。

```c
/* 记录型信号量的定义 */
typedef struct {
    int value;          // 剩余资源数
    Struct process *L;  // 等待队列
} semaphore;

/* 某进程需要使用资源时，通过wait原语申请 */
void wait(semaphore S) {
    S.value--;
    if (S.value < 0) {
        block(S.L);
    }
}

/* 进程使用完资源后，通过signal原语释放 */
void signal(semaphore S) {
    S.value++;
    if (S.value <= 0) {
        wakeup(S.L);
    }
}
```

如果剩余资源数不够，使用`block`原语使进程从运行态进入阻塞态，并把挂到信号量S的等待队列（即阻塞队列）中；
释放资源后，若还有别的进程在等待这种资源`wakeup`原语唤醒等待队列中的一个进程，该进程从阻塞态变为就绪态。

`wait(S)`、`signal(S)`也可以记为`P(S)`、`V(S)`,这对原语可用于**实现系统资源的“申请”和“释放”**。

`S.value`的初值表示系统中**某种资源的数目**。

对信号量S的**一次Р操作**意味着进程**请求一个单位的该类资源**，因此需要执行`S.value--`，表示资源数减1；
当`S.value < 0`时表示该类资源己分配完毕，因此进程应调用`block`原语进行**自我阻塞**（当前运行的进程从**运行态->阻塞态**），主动放弃处理机，并插入该类资源的等待队列`S.L`中。
可见，该机制**遵循了“让权等待”原则**,不会出现“忙等”现象。

对信号量S的**一次V操作**意味着进程**释放一个单位的该类资源**，因此需要执行`S.value++`，表示资源数加1；
若加1后仍是`S.value <= 0`，表示依然有进程在等待该类资源，因此应调用`wakeup`原语**唤醒等待队列中的第一个进程**（被唤醒进程从**阻塞态->就绪态**）。
