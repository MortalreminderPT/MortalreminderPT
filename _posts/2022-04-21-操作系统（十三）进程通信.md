---
layout: post
featured: false
title: 操作系统（十三）进程通信
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-21 23:59:35 +0800
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 为什么进程通信需要操作系统支持?

进程间通信（Inter-Process Communication，**IPC**）是指两个进程之间产生数据交互。

<img src='\images\posts\操作系统-进程-进程间通信.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

进程是分配系统资源的单位（包括内存地址空间），因此**各进程**拥有的**内存地址空间相互独立**。

为了保证安全，**一个进程不能直接访问另一个进程的地址空间**。

进程通信的方式主要有共享存储、消息传递和管道通信。

## 共享存储

操作系统在内存中开辟一块**共享空间**，允许通信进程**互斥访问**。

<img src='\images\posts\操作系统-进程-共享存储.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

为避免出错，各个进程对共享空间的**访问**应该是**互斥**的。

各个进程可使用操作系统内核提供的同步互斥工具（如P、V操作）。

注：通过“增加页表项/段表项”即可将同一片共享内存区映射到各个进程的地址空间中。

Linux中如何实现共享内存：

```c
int shm_open() ; // 通过shm_open系统调用，申请一片共享内存区
void * mmap(); //通过mmap系统调用，将共享内存区映射到进程自己的地址空间
```

共享存储包括基于数据结构的共享和基于存储区的共享：

**基于数据结构**的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式速度慢、限制多，是一种**低级通信**方式。

**基于存储区**的共享:操作系统在内存中划出块共享存储区，数据的形式、存放位置都由通信进程控制，而不是操作系统。这种共享方式速度很快，是一种**高级通信**方式。

## 消息传递

进程间的数据交换以**格式化的消息（Message）**为单位。进程通过操作系统提供的“发送消息/接收消息”两个**原语**进行数据交换。

<img src='\images\posts\操作系统-进程-消息传递.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

消息传递包括直接通信方式和间接通信方式。

### 直接通信方式

直接通信方式指的是消息发送进程要指明接收进程ID的通信方式。

假设存在两个进程P和Q，在进程P运行过程中，进程P的地址空间存放有一条消息`msg`需要发送给进程Q，我们通过描述两个进程的直接通信来展示直接通信方式的过程。

<img src='\images\posts\操作系统-进程-直接通信.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

1. 首先，在操作系统内核的地址空间中存放着进程Q的PCB，而**进程Q的PCB**中存放着**进程Q的消息队列**；
2. 进程P使用发送原语`send(Q, msg);`，操作系统将消息`msg`**添加到进程Q的PCB的消息队列**中去；
3. 进程Q在运行中执行了接收原语`receive(P,&msg);`，操作系统检查进程Q的PCB的消息队列，查看哪条消息是由进程P发来的，并把这条消息`msg`移动到进程Q的地址空间。

### 间接通信方式

间接通信方式是以“信箱”作为中间实体进行消息传递，又称信箱通信方式。

同样以上述场景为例子，我们通过描述两个进程的间接通信来展示间接通信方式的过程。

<img src='\images\posts\操作系统-进程-间接通信.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

1. 首先，在操作系统内核的地址空间中存放着**数个信箱**；
2. 进程P使用发送原语`send(A, msg);`，操作系统将消息`msg`**添加到操作系统内核的地址空间的信箱A**中去；
3. 进程Q在运行中执行了接收原语`receive(A,&msg);`，操作系统从信箱A中获取消息`msg`移动到进程Q的地址空间。

这个过程中，可以多个进程往同一个信箱send消息，也可以多个进程从同一个信箱中receive消息。

## 管道通信

“管道”是一个特殊的共享文件，又名pipe文件，其实就是在内存中开辟一个大小固定的内存缓冲区。

<img src='\images\posts\操作系统-进程-管道通信.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

1. 管道只能采用**半双工通信**，某一时间段内只能实现单向的传输。如果要实现**双向同时通信**，则**需要设置两个管道**。
2. 各进程互斥地访问管道（由操作系统实现）
3. 当**管道写满**时，**写进程**将**阻塞**，直到读进程将管道中的数据取走，即可唤醒写进程。
4. 当**管道读空**时，**读进程**将**阻塞**，直到写进程往管道中写入数据，即可唤醒读进程。
5. 管道中的数据一旦被读出，就彻底消失。因此，当多个进程读同一个管道时，可能会错乱。通常的解决方案是**一个管道允许多个写进程，一个读进程**，但在Linux中允许进程轮流从管道中读取数据，即**允许有多个写进程，多个读进程。**

