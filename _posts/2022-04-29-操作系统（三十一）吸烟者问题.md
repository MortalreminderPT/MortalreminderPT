---
layout: post 
title: 操作系统（三十一）吸烟者问题
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-29 09:26:25 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 问题描述
假设一个系统有**三个抽烟者进程**和**一个供应者进程**。
每个抽烟者不停地卷烟并抽掉它，但是要卷起并抽掉一支烟，抽烟者需要有三种材料：烟草、纸和胶水。
三个抽烟者中，**第一个拥有烟草、第二个拥有纸、第三个拥有胶水。**
供应者进程无限地提供三种材料，供应者每次将两种材料放桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者进程一个信号告诉完成了，供应者就会放另外两种材料再桌上，这个过程一直重复（让三个抽烟者轮流地抽烟）

## 实现原理

这个问题本质上也属于“生产者-消费者”问题，更详细的说是“可生产多种产品的单生产者-多消费者”。

互斥关系：
- 桌子可以抽象为容量为1的缓冲区，要互斥访问。

桌子上可能的组合：
- 组合一：纸+胶水； 
- 组合二：烟草+胶水； 
- 组合三：烟草+纸。

同步关系（从事件的角度分析）：
- 桌上有组合一->第一个抽烟者取走东西；
- 桌上有组合二->第二个抽烟者取走东西；
- 桌上有组合三->第三个抽烟者取走东西；
- 发出完成信号->供应者将下一个组合放到桌上。

信号量设计：

<img src='\images\posts\操作系统-信号量8.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

## 代码实现

```c 
semaphore offer1 = 0;     //桌上组合一的数量
semaphore offer2 = 0;     //桌上组合二的数量
semaphore offer3 = 0;     /桌上组合三的数量
semaphore finish = 0;     //抽烟是否完成
int i = 0;                //用于实现"三个抽烟者轮流抽烟"

Provider() {
    while(1) {
        if(i == 0) {
            将组合一放到桌上;
            V(offer1);
        }
        else if (i == 1) {
            将组合二放到桌上;
            V(offer2);
        }
        else if (i == 2) {
            将组合三放到桌上;
            V(offer3);
        }
        i = (i + 1) % 3;
        P(finish);
    }
}

Smoker1() {
    while(1) {
        P(offer1);
        从桌上拿走组合一;
        V(finish);
    }
}

Smoker2() {
    while(1) {
        P(offer2);
        从桌上拿走组合二;
        V(finish);
    }
}

Smoker3() {
    while(1) {
        P(offer3);
        从桌上拿走组合三;
        V(finish);
    }
}
```

缓冲区大小为1，同一时刻，四个同步信号量中至多有一个的值为1，因此**不必专门设置一个互斥信号量**。

## 总结

吸烟者问题可以为我们解决“可以生产多个产品的单生产者”问题提供一个思路。
值得吸取的精华是：**轮流让各个吸烟者吸烟**必然需要**轮流的在桌上放上组合**一、二、三。
注意体会我们是如何用一个整型变量i实现这个**轮流**过程的。

若**一个生产者要生产多种产品**（或者说会**引发多种前驱事件**），那么**各个V操作**应该放在各自**对应的“事件”发生之后**的位置。
