---
layout: post 
title: 操作系统（二十八）信号量实现进程的同步、互斥和前驱
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-27 16:08:23 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## P、V操作

- 信号量的值：这种**资源的剩余数量**（信号量的值如果小于0，说明此时有进程在等待这种资源）；
- `P(S)`：申请一个资源S，如果**资源不够就阻塞等待**；
- `V(S)`：释放一个资源S，如果有进程在等待该资源，则**唤醒一个进程**。


## 实现进程互斥

1. 分析并发进程的关键活动，划定临界区（如:对临界资源打印机的访问就应放在临界区）；
2. 设置**互斥信号量**mutex，表示**进入临界区的名额**。初值为1；
3. 在进入区`P(mutex)`——申请资源；
4. 在退出区`V(mutex)`——释放资源。

注意：
- 对**不同的临界资源**需要设置**不同的互斥信号量**。
- **P、V操作必须成对出现**。缺少`P(mutex)`就**不能保证临界资源的互斥访问**。缺少`V(mutex)`会导致**资源永不被释放，等待进程永不被唤醒**。

```c 
/* 信号量机制实现互斥 */
semaphore mutex = 1;

Process1 () {
    /* ... */
    P(mutex);   // 使用临界资源前加锁
    critical section; 
    V(mutex);   // 使用临界资源后解锁
    /* ... */
}

Process2 () {
    /* ... */
    P(mutex);   // 使用临界资源前加锁
    critical section; 
    V(mutex);   // 使用临界资源后解锁
    /* ... */
}

```

不同的临界资源设置不同的互斥信号量：

<img src='\images\posts\操作系统-信号量1.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

## 实现进程同步
进程同步：要让各并发进程按要求有序地推进。

比如，P1、P2并发执行，由于存在异步性，因此二者交替推进的次序是不确定的。

若**P2的“代码4”要基于P1的“代码1”和“代码2”的运行结果**才能执行，那么我们就必须**保证“代码4”一定是在“代码2”之后才会执行**。

这就是进程同步问题，让本来异步并发的进程互相配合，有序推进。

用信号量实现进程同步:
1. 分析什么地方需要实现“同步关系”，即必须保证“一前一后”执行的两个操作（或两句代码）；
2. 设置**同步信号量S,初始为0**。 
3. 在**“前操作”之后**执行`V(S)`
4. 在**“后操作”之前**执行`P(S)`

```c 
/* 信号量机制实现同步 */
semaphore mutex = 0;

Process1() {
  代码1;
  代码2;
  V(S);
  代码3;
}

Process2() {
  P(S);
  代码4;
  代码5;
  代码6;
}
```

**分析：信号量S代表“某种资源”，刚开始是没有这种资源的。P2需要使用这种资源，而又只能由P1产生这种资源。**

若先执行到`V(S)`操作，则`S++`后`S=1`。
之后当执行到`P(S)`操作时，由于`S=1`，表示有可用资源，会执行`S--`，S的值变回0，P2进程不会执行`block`原语，而是继续往下执行代码4。

若先执行到`P(S)`操作，由于`S=0`，`S--`后`S=-1`，表示此时没有可用资源，因此P操作中会执行`block`原语，主动请求阻塞。
之后当执行完代码2，继而执行`V(S)`操作，`S++`，使S变回0，由于此时有进程在该信号量对应的阻塞队列中，因此会在V操作中执行`wakeup`原语，唤醒P2进程。
这样P2就可以继续执行代码4了。

## 实现进程的前驱关系

前驱关系问题本质上是多级同步问题，假设6个进程中的代码要求按照以下前驱图所示顺序进行执行：

<img src='\images\posts\操作系统-信号量2.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

其实每一对前驱关系都是一个进程同步问题（需要保证一前一后的操作）,因此：
1. 要为**每一对前驱关系**各设置**一个同步信号量**；
2. 在**“前操作”之后**对相应的同步信号量执行**V操作**；
3. 在**“后操作”之前**对相应的同步信号量执行**Р操作**。

<img src='\images\posts\操作系统-信号量3.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

此时的代码为：

```c 
Process1() {
  /* ... */
  S1;
  V(a);
  V(b);
  /* ... */
}

Process2() {
  /* ... */
  P(a);
  S2;
  V(c);
  V(d);
  /* ... */
}

Process3() {
  /* ... */
  P(b);
  S3;
  V(g);
  /* ... */
}

Process4() {
  /* ... */
  P(c);
  S4;
  V(e);
  /* ... */
}

Process5() {
  /* ... */
  P(d);
  S5;
  V(f);
  /* ... */
}

Process6() {
  /* ... */
  P(e);
  P(f);
  P(g);
  S6;
  /* ... */
}
```
