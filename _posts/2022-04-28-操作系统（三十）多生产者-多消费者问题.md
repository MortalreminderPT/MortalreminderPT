---
layout: post 
title: 操作系统（三十）多生产者-多消费者问题
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-28 10:02:09 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 问题描述
桌子上有一只盘子，每次只能向其中放入一个水果。
爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等着吃盘子中的橘子，女儿专等着吃盘子中的苹果。
只有盘子空时，爸爸或妈妈才可向盘子中放一个水果。
仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出水果。

## 实现原理

互斥关系（mutex = 1）： 
- 对缓冲区（盘子）的访问要互斥地进行。

同步关系（一前一后）：
1. 父亲将苹果放入盘子后，女儿才能取苹果；
2. 母亲将橘子放入盘子后，儿子才能取橘子；
3. 只有盘子为空时，父亲或母亲才能放入水果。（“盘子为空”这个事件可以由儿子或女儿触发，事件发生后才允许父亲或母亲放水果）

信号量设计：

<img src='\images\posts\操作系统-信号量5.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

## 代码实现

```c
semaphore mutex = 1;   //实现互斥访问盘子（缓冲区）
semaphore apple = 0;   //盘子中有几个苹果
semaphore orange = 0;  //盘子中有几个橘子
semaphore plate = 1;   //盘子中还可以放多少个水果

dad() {
    while(1) {
        准备一个苹果;
        P(plate);
        P(mutex);
        把苹果放入盘子;
        V(mutex);
        V(apple);
    }
}

mom() {
    while(1) {
        准备一个橘子；
        P(plate);
        P(mutex);
        把橘子放入盘子;
        V(mutex);
        V(orange);
    }
}

daughter() {
    while(1) {
        P(apple);
        P(mutex);
        从盘中取出苹果;
        V(mutex);
        V(plate);
        吃掉苹果;
    }
}

son() {
    while(1) {
        P(orange);
        P(mutex);
        从盘中取出橘子;
        V(mutex);
        V(plate);
        吃掉橘子;
    }
}
```

## 去掉互斥信号的情况

### 缓冲区容量为1

在缓冲区容量为1时，即使不设置专门的互斥变量mutex，也不会出现多个进程同时访问盘子的现象。

分析：刚开始，儿子、女儿进程即使上处理机运行也会被阻塞。
如果刚开始是父亲进程先上处埋机行，则父亲`P(plate)`，可以访问盘子->
母亲`P(plate)`，阻塞等待盘子->
父亲放入苹果`V(apple)`，女儿进程被唤醒，其他进程即使运行也都会阻塞，暂时不可能访问临界资源（盘子）->
女儿`P(apple)`，访问盘子，`V(plate)`，等待盘子的母亲进程被唤醒->
母亲进程访问盘子（其他进程暂时都无法进入临界区）->......

原因在于本题中的缓冲区大小为1。
在任何时刻，apple、orange、plate三个同步信号量中最多只有一个是1。
因此最多只有一个进程的P操作不会被阻塞，并顺利地进入临界区。

### 缓冲区容量为2

父亲`P(plate)`，可以访问盘子->
母亲`P(plate)`，可以访问盘子->
父亲在往盘子里放苹果，同时母亲也可以往盘子里放橘子。
于是就出现了两个进程同时访问缓冲区的情况，有可能导致两个进程写入缓冲区的数据相互覆盖的情况。
因此，如果缓冲区大小大于1，就必须专门设置一个互斥信号量mutex来保证互斥访问缓冲区。

## 总结

解决“多生产者-多消费者问题”的关键在于理清复杂的同步关系。

在分析同步问题（一前一后问题）的时候不能从单个进程行为的角度来分析，要把“一前一后”发生的事看做是两种“事件”的前后关系。

比如，如果从单个进程行为的角度来考虑的话，我们会有以下结论：
- **如果盘子里装有苹果，那么一定要女儿取走苹果后父亲或母亲才能再放入水果；**
- **如果盘子里装有橘子，那么一定要儿子取走橘子后父亲或母亲才能再放入水果。**

这么看是否就意味着要设置四个同步信号量分别实现这四个“一前一后”的关系了？

<img src='\images\posts\操作系统-信号量6.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

正确的分析方法应该**从“事件”的角度来考虑**，我们可以把上述**四对“进程行为的前后关系”**抽象为**一对“事件的前后关系”**
盘子变空事件->放入水果事件：
- **“盘子变空事件”既可由儿子引发，也可由女儿引发；**
- **“放水果事件”既可能是父亲执行，也可能是母亲执行。**

这样的话，就可以用一个同步信号量解决问题了。

<img src='\images\posts\操作系统-信号量7.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />
