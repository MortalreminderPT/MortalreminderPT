---
layout: post 
title: 操作系统（二十五）进程互斥的硬件实现方法
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-25 15:24:46 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 中断屏蔽方法
利用“开/关中断指令”实现。
与原语的实现思想相同，即在某进程开始访问临界区到结束访问为止都不允许被中断，也就不能发生进程切换，因此也不可能发生两个同时访问临界区的情况。

```
...
关中断指令;
临界区;
开中断指令;
...
```

- **关中断指令**：关中断后即不允许当前进程被中断，也必然不会发生进程切换； 
- **开中断指令**：直到当前进程访问完临界区,再执行开中断指令，才有可能有别的进程上处理机并访问临界区。

- 优点：简单、高效
- 缺点：**不适用于多处理机**；只适用于操作系统内核进程，**不适用于用户进程**（因为开/关中断指令只能运行在内核态，这组指令如果能让用户随意使用会很危险）。




## TestAndSet指令（TS/TSL指令）
TS指令是用硬件实现的，**执行的过程不允许被中断**，只能一气呵成。以下是用c语言描述的逻辑：

```c
/* 布尔型共享变量lock表示当前临界区是否被加锁
 * true表示已加锁,false表示未加锁 
 */
bool testAndSet (bool *lock) {
    bool old; 
    old = *lock; // old 用来存放lock原来的值
    *lock = true; // 无论是否已加锁，都设置为true
    return old; // 返回lock原来的值
}

/* 使用TSL指令实现互斥的算法逻辑 */
while (testAndSet(&lock)); // 上锁并检查
critical section; // 临界区代码
lock = false; // 解锁操作
remainder section; // 剩余区代码
```

若刚开始lock是false，则TS返回的old值为false，while循环条件不满足，直接跳过循环，进入临界区；
若刚开始lock是true，则执行TS后old返回的值为true，while循环条件满足，会一直循环，直到当前访问临界区的进程在退出区进行“解锁”。
相比软件实现方法，TS指令把**“上锁”和“检查”**操作**用硬件的方式**变成了一气呵成的**原子操作**。

- 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；**适用于多处理机**环境；
- 缺点：**不满足“让权等待”原则**，暂时无法进入临界区的进程会占用CPU并循环执行TSL指令，从而导致“忙等”。


## Swap指令（Exchange/XCHG指令）
Swap指令是用硬件实现的，执行的过程不允许被中断，只能一气呵成。以下是用c语言描述的逻辑：

```c
/* Swap指令是交换两个变量的值 */
swap (bool *a, bool *b) {
    bool temp;
    temp = *a;
    *a = *b;
    *b = temp;
}

/* 使用Swap指令实现互斥的算法逻辑 */
bool old = true;
while (old == true)
    swap (&lock, *old);
critical section; // 临界区代码
lock = false; // 解锁操作
remainder section; // 剩余区代码
```

逻辑上来看Swap和TS并无太大区别，都是先记录下此时临界区是否已经被上锁（记录在old变量上），再将上锁标记lock设置为true，最后检查old。
如果old为false则说明之前没有别的进程对临界区上锁，则可跳出循环，进入临界区。

- 优点：实现简单，无需像软件实现方法那样严格检查是否会有逻辑漏洞；**适用于多处理机**环境；
- 缺点：**不满足“让权等待”原则**，暂时无法进入临界区的进程会占用CPU并循环执行Swap指令，从而导致“忙等”。
