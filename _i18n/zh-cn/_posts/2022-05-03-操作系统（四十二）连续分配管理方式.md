---
layout: post 
title: 操作系统（四十二）连续分配管理方式
description: 内存（Memory）是计算机的重要部件，也称内存储器和主存储器，它用于暂时存放CPU中的运算数据，以及与硬盘等外部存储器交换的数据，是外存与CPU进行沟通的桥梁。
date: 2022-05-03 16:01:06 +0800 
image: /images/covers/操作系统-cover4.jpg
tags:
- 操作系统
---

1. 目录
{:toc}

## 连续分配的概念

内存空间的分配与回收包括**连续分配管理方式**和**非连续分配管理方式**。

**连续分配**：指为用户进程分配的必须是一个**连续的内存空间**。

## 单一连续分配

在单一连续分配方式中，内存被分为**系统区**和**用户区**。
系统区通常位于内存的低地址部分，用于存放操作系统相关数据；用户区用于存放用户进程相关数据。
内存中**只能有一道用户程序**，用户程序独占整个用户区空间。

<img src='\images\posts\操作系统-内存分配1.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

- 优点：实现简单；**无外部碎片**；可以采用覆盖技术扩充内存；不一定需要采取内存保护（如早期的PC操作系统MS-DOS）。
- 缺点：只能用于单用户、单任务的操作系统中；**有内部碎片**；有很大一部分用户区空闲，存储器利用率极低。

内部碎片：分配给某进程的内存区域中，如果有些部分没有用上，就是“内部碎片”。

## 固定分区分配

20世纪60年代出现了支持多道程序的系统。
为了能在内存中装入多道程序，且这些程序之间又不会相互干扰，于是将**整个用户空间**划分为**若干个固定大小的分区**。
在**每个分区中只装入一道作业**，这样就形成了最早的、最简单的一种可运行多道程序的内存管理方式。

固定分区分配的分区有两种模式，分区大小相等和分区大小不等，如下图：

<img src='\images\posts\操作系统-内存分配2.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

- 分区大小相等：缺乏灵活性，但是很**适合用于用一台计算机控制多个相同对象的场合**（比如钢铁厂有n个相同的炼钢炉，就可把内存分为n个大小相等的区域存放n个炼钢炉控制程序）；
- 分区大小不等：增加了灵活性，可以满足不同大小的进程需求。
根据常在系统中运行的作业大小情况进行划分。（比如划分多个小分区、适量中等分区、少量大分区）

操作系统需要建立一个数据结构——**分区说明表**，来实现各个分区的分配与回收。
每个表项对应一个分区，通常按分区大小排列。
每个表项包括对应分区的**大小、起始地址、状态**（是否已分配）。

|分区号|大小（MB）|起始地址（M）|分配状态|
|--|--|--|--|
|1|2|8|未分配|
|2|2|10|未分配|
|3|4|12|已分配|
|...|...|...|...|

当某用户程序要装入内存时，由操作系统内核程序根据用户程序大小检索该表，从中找到一个能满足大小的、未分配的分区，将之分配给该程序，然后修改状态为“已分配”。
- 优点：实现简单，**无外部碎片**。
- 缺点：
  1. 当用户程序太大时，可能所有的分区都不能满足需求，此时不得不采用覆盖技术来解决，但这又会降低性能； 
  2. **会产生内部碎片**，内存利用率低。

## 动态分区分配

**动态分区分配**又称为**可变分区分配**。
这种分配方式**不会预先划分内存分区**，而是在进程装入内存时，**根据进程的大小动态地建立分区**，并使**分区的大小正好适合进程的需要**。
因此系统分区的大小和数目是可变的。（假设某计算机内存大小为64MB，系统区8MB，用户区共56MB）

### 空闲分区表和空闲分区链
系统可以使用空闲分区表或者空闲分区链这两种数据结构来记录内存的使用情况：
- 空闲分区表：每个空闲分区对应一个表项。表项中包含分区号、分区大小、分区起始地址等信息；
- 空闲分区链：每个分区的起始部分和末尾部分分别设置前向指针和后向指针。起始部分处还可记录分区大小等信息。

<img src='\images\posts\操作系统-内存分配3.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

### 动态分区分配算法
把一个新作业装入内存时，须按照一定的**动态分区分配算法**，从空闲分区表（或空闲分区链）中选出一个分区分配给该作业。
由于分配算法算法对系统性能有很大的影响，因此人们对它进行了广泛的研究。

### 分区回收
1. 回收区的后面有一个相邻的空闲分区，则将两个相邻的空闲分区合并为一个；
2. 回收区的前面有一个相邻的空闲分区，则将两个相邻的空闲分区合并为一个；
3. 回收区的前、后各有一个相邻的空闲分区，则将三个相邻的空闲分区合并为一个；
4. 回收区的前、后都没有相邻的空闲分区，则新增一个表项。

### 内部碎片和外部碎片

动态分区分配**没有内部碎片**，但是**有外部碎片**。

- **内部碎片**，分配给某进程的内存区域中，如果有些部分没有用上。
- **外部碎片**，是指内存中的某些空闲分区由于太小而难以利用。

如果内存中空闲空间的总和本来可以满足某进程的要求，但由于进程需要的是一整块连续的内存空间，因此这些“碎片”不能满足进程的需求。

<img src='\images\posts\操作系统-内存分配4.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

可以通过**紧凑（拼凑，Compaction）**技术来解决外部碎片。

