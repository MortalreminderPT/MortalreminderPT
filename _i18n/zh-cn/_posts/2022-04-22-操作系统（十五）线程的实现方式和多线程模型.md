---
layout: post 
title: 操作系统（十五）线程的实现方式和多线程模型
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-22 02:46:02 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 线程的背景

## 线程的实现方式

### 用户级线程

<img src='\images\posts\操作系统-进程-用户级线程.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

1. 用户级线程（User-Level Thread，ULT）由应用程序通过线程库实现，所有的**线程管理工作**都由**应用程序负责**（包括线程切换）；
2. 用户级线程中，**线程切换**可以在**用户态下即可完成**，无需操作系统干预；
3. 在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。**“用户级线程”**就是**“从用户视角看能看到的线程”**。

用户级线程的优缺点：
- 优点：用户级线程的切换在用户空间即可完成，不需要切换到内核态，线程管理的系统开销小，效率高；
- 缺点：当一个用户级线程被阻塞后。整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行。

### 内核级线程

<img src='\images\posts\操作系统-进程-内核级线程.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

1. **内核级线程（Kernel-Level Thread，KLT）的管理工作**由**操作系统内核**完成；
2. 线程调度、切换等工作都由内核负责，因此**内核级线程的切换**必然需要在**内核态**下才能完成；
3. 操作系统会为每个内核级线程建立相应的TCB (Thread Control Block，线程控制块)，通过TCB对线程进行管理。**“内核级线程”**就是**“从操作系统内核视角看能看到的线程”**。

内核级线程的优缺点： 
- 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行；
- 缺点：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。

## 多线程模型

在支持内核级线程的系统中，根据用户级线程和内核级线程的映射关系，可以划分为几种多线程模型。

### 一对一模型

<img src='\images\posts\操作系统-进程-一对一模型.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

一对一模型：一个用户级线程映射到一个内核级线程，每个用户进程有与用户级线程同数量的内核级线程。
- 优点：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。
- 缺点：一个用户进程会占用多个内核级线程,线程切换由操作系统内核完成，需要切换到内核态，因此线程管理的成本高，开销大。

### 多对一模型

<img src='\images\posts\操作系统-进程-多对一模型.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

多对一模型：多个用户级线程映射到一个内核级线程，且一个进程只被分配一个内核级线程。
- 优点：用户级线程的切换在用户空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高
- 缺点：当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行
- 注意：操作系统只“看得见”内核级线程，因此只有**内核级线程才是处理机分配的单位**。


### 多对多模型

<img src='\images\posts\操作系统-进程-多对多模型.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

多对多模型：**n用户及线程映射到m个内核级线程（n>=m）**。每个用户进程对应m个内核级线程。

克服了多对一模型并发度不高的缺点（一个阻塞全体阻塞），又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。

可以这么理解：用户级线程是“代码逻辑”的载体；内核级线程是“运行机会”的载体。**内核级线程才是处理机分配的单位**，多核CPU环境下，上图这个进程最多能被分配两个核。
一段“代码逻辑”只有获得了“运行机会”才能被CPU执行。
内核级线程中可以运行任意一个有映射关系的用户级线程代码，只有两个内核级线程中正在运行的代码逻辑都阻塞时，这个进程才会阻塞。
