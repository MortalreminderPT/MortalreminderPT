---
layout: post 
title: 操作系统（二十一）FCFS、SJF、HRRN调度算法
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-24 11:34:45 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 简介

本章介绍三种适用于**早期批处理系统**的调度算法。

|算法|可抢占|优点|缺点|考虑运行和等待时间|会导致饥饿|
|--|--|--|--|
|FCFS|非抢占|公平、实现简单|对短作业不利|等待时间√<br />运行时间×|不会|
|SJF/SPF|非抢占，也有抢占式版本最短剩余时间优先算法（SRTN）|几乎最短的平均等待时间/周转时间|对长作业不利，可能导致饥饿；<br />难以实现真正的短作业优先|等待时间×<br />运行时间√|会|
|HRRN|非抢占|FCFS和SJF算法的折中，综合考虑了等待和运行时间|-|等待时间√<br />运行时间√|不会|

这几种算法主要关心对用户的公平性、平均周转时间、平均等待时间等评价系统整体性能的指标，但是不关心“响应时间”，也并不区分任务的紧急程度。
因此对于用户来说，交互性很糟糕。因此过三种算法一般适合用于**早期的批处理系统**，当然，FCFS算法也常结合其他的算法使用，在现在也扮演着很重要的角色。
而适合用于交互式系统的调度算法在下章介绍。

## FCFS算法

### FCFS算法特点

|算法名|先来先服务（First Come First Serve，FCFS）|
|--|--|
|算法思想|主要从“公平”的角度考虑（类似于我们生活中排队买东西的例子）|
|算法规则|按照作业/进程到达的**先后顺序进行服务**|
|用于作业/进程调度|用于**作业调度**时，考虑的是哪个作业先到达**后备队列**；<br />用于**进程调度**时，考虑的是哪个进程先到达**就绪队列**|
|是否可抢占|非抢占式算法|
|优缺点|优点：公平、算法实现简单；<br />缺点：排在长作业（进程）后面的短作业需要等待很长时间，带权周转时间很大，对短作业来说用户体验不好。即**FCFS算法对长作业有利，对短作业不利**|
|是否会导致饥饿|不会|

### 例子
各进程到达就绪队列的时间、需要的运行时间如下表所示。使用先来先服务调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

|进程|到达时间|运行时间|
|--|--|--|
|P1|0|7|
|P2|2|4|
|P3|4|1|
|P4|5|4|

解答：

FCFS按照**到达的先后顺序调度**，事实上就是**等待时间越久的越优先**得到服务。

因此，调度顺序为P1>P2>P3>P4，如图所示。

<img src='\images\posts\操作系统-调度算法1.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

周转时间 = 完成时间-到达时间
带权周转时间 = 周转时间 / 运行时间
等待时间 = 周转时间 - 运行时间

注意：本例中的进程都是纯计算型的进程，一个进程到达后要么在等待，要么在运行。
如果是又有计算、又有I/O操作的进程，其等待时间就是周转时间 - 运行时间 - I/O操作的时间。

|进程|P1|P2|P3|P4|
|--|--|--|--|--|
|周转时间|7-0=7|11-2=9|12-4=8|16-5=11|
|带权周转时间|7/7=1|9/4=2.25|8/1=8|11/4=2.75|
|等待时间|7-7=0|9-4=5|8-1=7|11-4=7|

平均周转时间 = (7+9+8+11) / 4 = 8.75

平均带权周转时间 = (1+2.25+8+2.75) / 4 = 3.5

平均等待时间 = (0+5+7+7) / 4 = 4.75

## SJF算法

### SJF算法特点

|算法名|短作业优先（Shortest Job First，SJF）|
|--|--|
|算法思想|追求**最少的平均等待时间、最少的平均周转时间、最少的平均平均带权周转时间**|
|算法规则|最短的作业/进程优先得到服务（所谓“最短”，是指**要求服务时间最短**）|
|用于作业/进程调度|即可用于作业调度，也可用于进程调度。用于进程调度时称为短进程优先(Shortest Process First，SPF）算法|
|是否可抢占|SJF/SPF是非抢占式的算法。但是也有抢占式的版本——**最短剩余时间优先算法**（Shortest Remaining Time Next，SRTN）|
|优缺点|优点：几乎最短的平均等待时间、平均周转时间；<br />缺点：不公平。**对短作业有利，对长作业不利。**可能产生**饥饿现象**。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先|
|是否会导致饥饿|会。如果源源不断地有短作业/进程到来，可能使长作业/进程长时间得不到服务，产生“饥饿”现象。如果一直得不到服务，则称为“饿死”|

### 例子
各进程到达就绪队列的时间、需要的运行时间如下表所示。使用非抢占式的短作业优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

|进程|到达时间|运行时间|
|--|--|--|
|P1|0|7|
|P2|2|4|
|P3|4|1|
|P4|5|4|

解答：

短作业/进程优先调度算法每次调度时选择**当前已到达且运行时间最短的**作业/进程。

因此，调度顺序为P1>P3>P2>P4

<img src='\images\posts\操作系统-调度算法2.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

|进程|P1|P2|P3|P4|
|--|--|--|--|--|
|周转时间|7-0=7|8-4=4|12-2=10|16-5=11|
|带权周转时间|7/7=1|4/1=4|10/4=2.5|11/4=2.75|
|等待时间|7-7=0|4-1=3|10-4=6|11-4=7|

平均周转时间 = (7+4+10+11) / 4 = 8

平均带权周转时间 = (1+4+2.5+2.75) / 4 = 2.56

平均等待时间 = (0+3+6+7) / 4 = 4

对比FCFS算法的结果，显然SPF算法的平均等待/周转/带权周转时间都要更低

### 抢占式版本——SRTN算法

各进程到达就绪队列的时间、需要的运行时间如下表所示。使用抢占式的短作业优先调度算法计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

|进程|到达时间|运行时间|
|--|--|--|
|P1|0|7|
|P2|2|4|
|P3|4|1|
|P4|5|4|

解答：

**最短剩余时间优先算法**每当有进程加入**就绪队列改变时就需要调度**，如果新到达的进程**剩余时间**比当前运行的进程剩余时间**更短**，则由新进程**抢占处理机**，当前运行进程重新回到就绪队列。
另外，**当一个进程完成时也需要调度。**

需要注意的是，当有新进程到达时就绪队列就会改变，就要按照上述规则进行检查。
以下Pn=m表示当前Pn进程剩余时间为m。各个时刻的情况如下：

|时刻|不同进程剩余时间|
|--|--|
|0（P1到达）|**P1=7**|
|2（P2到达）|P1=5、**P2=4**|
|4（P3到达）|P1=5、P2=2、**P3=1**|
|5（P3完成、P4到达）|P1=5、**P2=2**、P4=4|
|7（P2完成）|P1=5、**P4=4**|
|11（P4完成）|**P1=5**|

<img src='\images\posts\操作系统-调度算法3.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

|进程|P1|P2|P3|P4|
|--|--|--|--|--|
|周转时间|16-0=16|7-2=5|5-4=1|11-5=6|
|带权周转时间|16/7=2.28|5/4=1.25|1/1=1|6/4=1.5|
|等待时间|16-7=9|5-4=1|1-1=0|6-4=2|

平均周转时间 = (16+5+1+6) / 4 = 7

平均带权周转时间 = (2.28+1.25+1+1.5) / 4 = 1.50

平均等待时间 = (9+1+0+2) / 4 = 3

对比SJF/SPF算法，显然抢占式的这几个指标又要更低。

### 注意

严格来说，“SJF调度算法的平均等待时间、平均周转时间最少”这个表述是错误的，不严谨的。
之前的例子表明，最短剩余时间优先算法得到的平均等待时间、平均周转时间还要更少；
应该加上一个条件“在**所有进程同时可运行**时，采用SIF调度算法的平均等待时间、平均周转时间最少”；
或者说“在**所有进程都几乎同时到达**时，采用SJF调度算法的平均等待时间、平均周转时间最少”。

如果不加上述前提条件，则应该说“**抢占式的**短作业/进程优先调度算法的平均等待时间、平均周转时间最少”。

虽然严格来说，SJF的平均等待时间、平均周转时间并不一定最少，
但相比于其他算法（如FCFS），SJF依然可以获得较少的平均等待时间、平均周转时间。

## HRRN算法

### 关于FCFS和SJF的思考

FCFS算法是在每次调度的时候选择一个等待时间最长的作业（进程）为其服务。
但是没有考虑到作业的运行时间，因此导致了对短作业不友好的问题；

SJF算法是选择一个执行时间最短的作业为其服务。
但是又完全不考虑各个作业的等待时间，因此导致了对长作业不友好的问题，甚至还会造成饥饿问题；

高响应比算法既考虑到了各个作业的等待时间，也兼顾了运行时间。

### 响应比

**响应比** = （等待时间 + 要求服务时间） / 要求服务时间

响应比兼顾了作业的等待时间和运行时间，且响应比总是≥1。

### HRRN算法特点

|算法名|高响应比优先（Highest Response Ratio Next，HRRN）|
|--|--|
|算法思想|要综合考虑作业/进程的等待时间和要求服务的时间|
|算法规则|在每次调度时先计算各个作业/进程的**响应比**，选择**响应比最高**的作业/进程为其服务|
|用于作业/进程调度|即可用于作业调度，也可用于进程调度。|
|是否可抢占|非抢占式的算法。因此只有当前运行的作业/进程主动放弃处理机时，才需要调度，才需要计算响应比|
|优缺点|综合考虑了等待时间和运行时间（要求服务时间）<br />等待时间相同时，要求服务时间短的优先（SJF的优点）<br />要求服务时间相同时，等待时间长的优先（FCFS的优点）<br />对于长作业来说，随着等待时间越来越久，其响应比也会越来越大，从而避免了长作业饥饿的问题 |
|是否会导致饥饿|不会。|

### 例子
各进程到达就绪队列的时间、需要的运行时间如下表所示。使用高响应比优先调度算法，计算各进程的等待时间、平均等待时间、周转时间、平均周转时间、带权周转时间、平均带权周转时间。

**高响应比优先算法**是**非抢占式**的调度算法，只有当前运行的进程**主动放弃CPU**时（正常/异常完成，或主动阻塞），才需要进行调度。
调度时**计算所有就绪进程的响应比，选响应比最高的进程**上处理机。

以下Pn=m表示当前Pn进程的响应比为m。各个时刻的情况如下：

|时刻|不同进程响应比|
|--|--|
|0（P1到达）|只有P1到达就绪队列，直接选取**P1**|
|7（P1完成）|P2=(5+4)/4=2.25、**P3=(3+1)/1=4**、P4=(2+4)/4=1.5|
|8（P3完成）|**P2=2.5**、P4=1.75|
|12（P2完成）|就绪队列中只剩**P4**|

<img src='\images\posts\操作系统-调度算法4.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

具体计算可以参考前文，这里不再给出。
