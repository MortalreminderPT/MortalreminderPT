---
layout: post 
title: 操作系统（二十二）RR、PSA、MLFQ调度算法
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-24 11:57:12 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 简介

本章介绍三种适用于**交互式系统**的调度算法。

|算法|可抢占|优点|缺点|会导致饥饿|
|--|--|--|--|
|RR|抢占式|公平，适用于分时系统|频繁切换存在开销；不区分优先级|不会|
|PSA|有抢占式，也有非抢占式|区分优先级，适用于实时系统|可能导致饥饿|会|
|MLFQ|抢占式|平衡、优秀|可能导致饥饿|会|

比起早期的批处理操作系统来说，由于计算机造价大幅降低 因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。
而这几种算法恰好能较好地满足交互式系统的需求。因此**这三种算法适合用于交互式系统**。（比如UNIX使用的就是多级反馈队列调度算法）

## RR算法

### RR算法特点

|算法名|时间片轮转（Round-Robin，RR）|
|--|--|
|算法思想|公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应|
|算法规则|按照各进程到达就绪队列的顺序，轮流让各个进程执行一个**时间片**（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。|
|用于作业/进程调度|用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）|
|是否可抢占|若进程未能在时间片内运行完，将被强行剥夺处理机使用权，因此时间片轮转调度算法属于**抢占式**的算法。由时钟装置发出**时钟中断**来通知CPU时间片已到|
|优缺点|优点：公平、响应快，适用于分时操作系统；<br />缺点：由于高频率的进程切换，因此有一定开销；不区分任务的紧急程度。|
|是否会导致饥饿|不会|

### 例子

各进程到达就绪队列的时间、需要的运行时间如下表所示。使用**时间片轮转调度**算法，分析时间片大小分别是2、5时的进程运行情况。

注意：常用于分时操作系统，更注重响应时间，因而此处不计算周转时间。

|进程|到达时间|运行时间|
|--|--|--|
|P1|0|5|
|P2|2|4|
|P3|4|1|
|P4|5|6|

**时间片轮转调度算法**轮流让就绪队列中的进程依次执行一个时间片（每次选择的都是排在就绪队列队头的进程）

- 时间片大小为2

|时刻|就绪队列|分析|
|--|--|--|
|0|**P1(5)**|只有P1到达就绪队列，让P1上处理机运行一个时间片|
|2|**P2(4)**->P1(3)|P2到达就绪队列，P1运行完一个时间片，被剥夺处理机，重新放到队尾。此时P2排在队头，因此让P2上处理机。（注意：2时刻，P1下处理机，同一时刻新进程P2到达，**默认新到达的进程先进入就绪队列**）|
|4|**P1(3)**->P3(1)->P2(2)|P3到达，先插到就绪队尾，紧接着，P2下处理机也插到队尾|
|5|P3(1)->P2(2)->P4(6)|P4到达插到就绪队尾。由于P1的时间片还没用完，因此暂时不调度。另外，此时P1处于运行态，并不在就绪队列中|
|6|**P3(1)**->P2(2)->P4(6)->P1(1)|P1时间片用完，下处理机，重新放回就绪队尾，发生调度|
|7|**P2(2)**->P4(6)->P1(1)|虽然P3的时间片没用完，但是由于P3只需运行1个单位的时间。运行完了会**主动放弃处理机**，因此也会发生调度。队头进程P2上处理机。|
|9|**P4(6)**->P1(1)|进程P2时间片用完，并刚好运行完，发生调度，P4上处理机|
|11|**P1(1)**->P4(4)|P4时间片用完，重新回到就绪队列。P1上处理机|
|12|**P4(4)**|P1运行完，主动放弃处理机，此时就绪队列中只剩P4，P4上处理机|
|14|-|就绪队列为空，因此让P4接着运行一个时间片|

<img src='\images\posts\操作系统-调度算法5.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

- 时间片大小为5

|时刻|就绪队列|分析|
|--|--|--|
|0|**P1(5)**|只有P1到达，P1上处理机|
|2|P2(4)|P2到达，但P1时间片尚未结束，因此**暂不调度**|
|4|P2(4)->P3(1)|P3到达，但P1时间片尚未结束，因此暂不调度|
|5|**P2(4)**->P3(1)->P4(6)|P4到达，同时，P1运行结束。发生调度，P2上处理机|
|9|**P3(1)**->P4(6)|P2运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度|
|10|**P4(6)**|P3运行结束，虽然时间片没用完，但是会主动放弃处理机。发生调度|
|15|-|P4时间片用完，但就绪队列为空，因此会让P4继续执行一个时间片|

<img src='\images\posts\操作系统-调度算法6.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

## PSA算法

### PSA算法特点

|算法名|优先级调度（Priority Scheduling Algorithm，PSA）|
|--|--|
|算法思想|随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序|
|算法规则|每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程|
|用于作业/进程调度|既可用于作业调度，也可用于进程调度。甚至，还会用于在之后的I/O调度中|
|是否可抢占|抢占式、非抢占式都有。非抢占式只需在进程主动放弃处理机时进行调度即可，而抢占式还需在就绪队列变化时，检查是否会发生抢占。|
|优缺点|优点：用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活地调整对各种作业/进程的偏好程度。<br />缺点：若源源不断地有高优先级进程到来，则可能导致饥饿|
|是否会导致饥饿|会|

### 非抢占式PSA
各进程到达就绪队列的时间、需要的运行时间、进程优先数如下表所示。使用**非抢占式的优先级调度算法**，分析进程运行情况。（注：优先数越大，优先级越高)

|进程|到达时间|运行时间|优先数|
|--|--|--|--|
|P1|0|7|1|
|P2|2|4|2|
|P3|4|1|3|
|P4|5|4|2|

**非抢占式的优先级调度算法**：每次调度时选择**当前已到达且优先级最高**的进程。当前进程**主动放弃处理机时**发生调度。

|时刻|就绪队列|分析|
|--|--|--|
|0|**P1**|只有P1到达，P1上处理机|
|7|P2、**P3**、P4|P1运行完成主动放弃处理机，其余进程都已到达，P3优先级最高，P3上处理机|
|8|**P2**、P4|P3完成，P2、P4优先级相同，由于P2先到达，因此P2优先上处理机|
|12|**P4**|P2完成，就绪队列只剩P4，P4上处理机|
|16|-|P4完成，所有进程都结束|

<img src='\images\posts\操作系统-调度算法7.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

### 抢占式PSA
抢占式的优先级调度算法：每次调度时选择**当前已到达且优先级最高**的进程。当前进程**主动放弃处理机时**发生调度。
另外，当**就绪队列发生改变**时也需要检查是会发生抢占。

|时刻|就绪队列|分析|
|--|--|--|
|0|**P1**|只有P1到达，P1上处理机|
|2|P1、**P2**|P2到达就绪队列，优先级比P1更高，发生抢占。P1回到就绪队列，P2上处理机。|
|4|P1、P2、**P3**|P3到达，优先级比P2更高，P2回到就绪队列，P3抢占处理机|
|5|P1、**P2**、P4|P3完成，主动释放处理机，同时，P4也到达，由于P2比P4更先进入就绪队列，因此选择P2上处理机|
|7|P1、**P4**|P2完成，就绪队列只剩P1、P4，P4上处理机。|
|11|**P1**|P4完成，P1上处理机|
|16|-|P1完成，所有进程都结束|

<img src='\images\posts\操作系统-调度算法8.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

### 补充

就绪队列未必只有一个，可以按照不同优先级来组织。另外，也可以把优先级高的进程排在更靠近队头的位置；

根据优先级是否可以动态改变，可将优先级分为**静态优先级**和**动态优先级**两种：
- 静态优先级:创建进程时确定，之后一直不变；
- 动态优先级:创建进程时有一个初始值，之后会根据情况动态地调整优先级。

通常情况下：
- 系统进程优先级**高于**用户进程；
- 前台进程优先级**高于**后台进程；
- 操作系统更偏好I/O型进程（或称I/O繁忙型进程，I/O设备和CPU可以**并行**工作。如果优先让I/O繁忙型进程运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升。）

与I/O型进程相对的是计算型进程（或称CPU繁忙型进程）

可以从追求公平、提升资源利用率等角度考虑动态优先级的调整：
- 如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级；
- 如果某进程占用处理机运行了很长时间，则可适当降低其优先级； 
- 如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级。

## MLFQ算法

### MLFQ算法特点

|算法名|多级反馈队列调度算法（Multi-Level Feedback Queue，MLFQ）|
|--|--|
|算法思想|对其他调度算法的折中权衡|
|算法规则|1．设置多级就绪队列，各级队列**优先级从高到低，时间片从小到大**<br />2．新进程到达时先进入第1级队列，按**FCFS原则排队等待**被分配时间片，若**用完时间片进程还未结束，则进程进入下一级队列队尾**。 如果此时已经是在最下级的队列，则重新放回该队列队尾<br />3．只有**第k级队列为空时，才会为k+1级队头的进程分配时间片**|
|用于作业/进程调度|用于进程调度|
|是否可抢占|**抢占式**的算法。在k级队列的进程运行过程中，若更上级的队列(1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，原来运行的进程放回k级队列队尾。|
|优缺点|对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/O密集型进程（可以将因I/O而阻塞的进程重新放回原队列，这样I/O型进程就可以保持较高优先级）|
|是否会导致饥饿|会|

### 例子
各进程到达就绪队列的时间、需要的运行时间如下表所示。使用多级反馈队列调度算法，分析进程的运行过程。

|进程|到达时间|运行时间|
|--|--|--|
|P1|0|8|
|P2|1|4|
|P3|5|1|

设置多级就绪队列，各级队列**优先级从高到低，时间片从小到大；**

**新进程到达时先进入第1级队列**，按**FCFS原则**排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。
如果此时已经在最下级的队列，则重新放回最下级队列队尾；

只有**第k级队列为空**时，才会**为k+1级队头的进程分配时间片**；

**被抢占处理机的进程**重新放回**原队列队尾**。

假设此时的多级反馈队列共3级，3级队列优先级从高到低，时间片分别为1、2、4。

|时刻|第1级队列（时间片1）|第2级队列（时间片2）|第3级队列（时间片4）|分析|
|--|--|--|--|--|
|0|**P1（8）**|-|-|仅有P1到达，上处理机|
|1|**P2（4）**|P1（7）|-|P1**时间片用完，但任务未结束，放到第2级队列**，同时P2到达第1级队列，优先上处理机运行|
|2|-|**P1（7）**->P2（3）|-|P2时间片用完，但任务未结束，放到第2级队列，此时第1级队列为空，第2级队列队头的P1上处理机运行|
|4|-|**P2（3）**|P1（5）|P1时间片用完，但任务未结束，放到第3级队列，此时第1级队列为空，P2上处理机运行|
|5|**P3（1）**|P2（2）|P1（5）|P3到达，处于更高的优先级队列，**抢占处理机**，P2下处理机，被**重新放回原队列队尾**|
|6|-|**P2（2）**|P1（5）|P3运行结束，第2级队列的P2上处理机|
|8|-|-|**P1（5）**|P2运行结束，第3级队列的P1上处理机|
|12|-|-|**P1（1）**|P1时间片用完，第3级队列已经是**最低级，重新放回**，且队列中仅剩P1，上处理机|
|13|-|-|-|全部程序运行结束|

### 补充

MLFQ不仅可以使用固定优先级和FCFS的调度策略，还可以灵活选用别的优先级划分和调度策略。

如图，系统中按进程类型设置多个队列，进程创建成功后插入某个队列。

<img src='\images\posts\操作系统-调度算法9.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

队列之间可采取固定优先级，或**时间片划分**：
- 固定优先级：高优先级空时低优先级进程才能被调度；
- 时间片划分：如三个队列分配时间50%、40%、10%

各队列可采用不同的调度策略，如：
- 系统进程队列采用PSA
- 交互式队列采用RR
- 批处理队列采用FCFS

