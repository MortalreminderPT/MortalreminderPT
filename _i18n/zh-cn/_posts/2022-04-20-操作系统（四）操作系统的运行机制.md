---
layout: post 
title: 操作系统（四）操作系统的运行机制 
description: 操作系统（Operating System，OS）是指控制和管理计算机系统软硬件资源，合理组织调度计算机工作和资源分配，提供给用户和其它软件方便的接口和环境。
date: 2022-04-20 17:45:27 +0800
image: /images/covers/操作系统-cover1.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 程序是如何运行的
在完成代码编写后，编译器将高级语言“翻译”成二进制的机器指令，**程序运行的过程其实就是CPU执行一条一条机器指令的过程**。

“指令”就是处理器（CPU）能识别、执行的最基本命令。

很多人习惯把Linux、Windows、MacOS的“小黑框”中使用的命令也称为“指令”，其实这是“交互式命令接口”，注意与本节的“指令”区别开。本节中的“指令”指二进制机器指令。

## 内核程序和应用程序
普通程序员写的程序就是“**应用程序**”；

微软、苹果有一帮人负责实现操作系统，他们写的是“**内核程序**”由很多内核程序组成了“**操作系统内核**”，或简称“**内核（Kernel）**”，内核是操作系统最重要最核心的部分，也是**最接近硬件的部分**。

一个操作系统只要有内核就够了（比如Docker仅需Linux内核）。操作系统的功能未必都在内核中，如GUI。

## 特权指令和非特权指令
操作系统内核作为“管理者”，有时会让CPU执行一些“特权指令”，如内存清零指令。这些指令影响重大，只允许“管理者”，即操作系统内核来使用。

应用程序只能使用“非特权指令”，如加法指令、减法指令等。

在**CPU设计和生产的时候就划分了特权指令和非特权指令**，因此CPU执行一条指令前就能判断出其类型。

## 处理器的内核态和用户态
虽然CPU能判断出指令类型，但是它怎么区分此时正在运行的是内核程序还是应用程序?

CPU有两种状态，“**内核态**”和“**用户态**”

处于内核态时，说明此时**正在运行的是内核程序**，此时**可以执行特权指令**；

处于用户态时，说明此时**正在运行的是应用程序**，此时**只能执行非特权指令**。

    CPU中有一个寄存器叫程序状态字寄存器（PSW），其中有个二进制位，1表示“内核态”，0表示“用户态”。

### 内核态和用户态之间的转换

1. 刚开机时，CPU为“内核态”，操作系统内核程序先上CPU运行；
2. 开机完成后，用户可以启动某个应用程序；
3. 操作系统内核程序在合适的时候主动让出CPU，让该应用程序上CPU运行（操作系统内核在让出CPU之前，会**用一条特权指令把PSW的标志位设置为“用户态”**）；
4. 应用程序运行在“用户态”；
5. 应用程序中植入了一条特权指令，CPU发现接下来要执行的这条指令是特权指令，但是自己又处于“用户态”；
6. 因此，这个事件会引发一个**中断信号**（**CPU检测到中断信号后**，会立即**变为“内核态”**，并停止运行当前的应用程序，转而运行处理中断信号的内核程序）；
7. “中断”使操作系统再次夺回CPU的控制权；
8. 操作系统会对引发中断的事件进行处理，处理完了再把CPU使用权交给别的应用程序。

内核态→用户态：执行一条**特权指令——修改PSW**的标志位为“用户态”，这个动作意味着操作系统将主动让出CPU使用权。

用户态→内核态：由“**中断**”引发，**硬件自动完成变态过程**，触发中断信号意味着操作系统将强行夺回CPU的使用权（除了非法使用特权指令之外，还有很多事件会触发中断信号。一个共性是，**但凡需要操作系统介入的地方，都会触发中断信号**）。
