---
layout: post 
title: 操作系统（三十六）死锁的预防
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-05-01 16:20:06 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 死锁的处理策略

1. 预防死锁。破坏死锁产生的四个必要条件中的一个或几个；
2. 避免死锁。用某种方法防止系统进入不安全状态，从而避免死锁（银行家算法）；
3. 死锁的检测和解除。允许死锁的发生，不过操作系统会负责检测出死锁的发生，然后采取某种措施解除死锁。

## 静态策略：预防死锁

### 破坏互斥条件

互斥条件：只有对必须互斥使用的资源的争抢才会导致死锁。

如果把只能互斥使用的资源改造为允许共享使用，则系统不会进入死锁状态。
比如: **SPOOLing技术。**操作系统可以采用SPOOLing技术把独占设备在逻辑上改造成共享设备。
如用SPooLing技术将打印机改造为共享设备。

如图，进程1还没用完打印机之前，进程2申请使用打印机会阻塞：

<img src='\images\posts\操作系统-死锁1.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

使用了SPOOLing技术后，在各进程看来，自己对打印机资源的使用请求立即就被接收处理了，不需要再阻塞等待：

<img src='\images\posts\操作系统-死锁2.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

#### 该策略的缺点
并不是所有的资源都可以改造成可共享使用的资源。
并且为了系统安全，很多地方还必须保护这种互斥性。
因此，**很多时候都无法破坏互斥条件**。

### 破坏不剥夺条件
不剥夺条件：进程所获得的资源在未使用完之前，不能由其他进程强行夺走，只能主动释放。

破坏不剥夺条件： 
- 方案一：当某个进程请求新的资源得不到满足时，它必须立即释放保持的所有资源，待以后需要时再重新申请。也就是说，即使某些资源尚未使用完，也需要主动释放，从而破坏了不可剥夺条件；
- 方案二:当某个进程需要的资源被其他进程所占有的时候，可以由操作系统协助，将想要的资源强行剥夺。这种方式一般需要考虑各进程的优先级。（比如剥夺调度方式，就是将处理机资源强行剥夺给优先级更高的进程使用）

#### 该策略的缺点

1. 实现起来比较复杂。
2. 释放已获得的资源可能造成前一阶段工作的失效。因此这种方法一般**只适用于易保存和恢复状态的资源**，如CPU。 
3. 反复地申请和释放资源会增加系统开销，降低系统吞吐量。
4. 若采用**方案一**，意味着只要暂时得不到某个资源，之前获得的那些资源就都需要放弃，以后再重新申请。如果一直发生这样的情况，就会**导致进程饥饿**。

### 破坏请求和保持条件
请求和保持条件：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源又被其他进程占有，此时请求进程被阻塞，但又对自己已有的资源保持不放。

可以**采用静态分配方法**，即进程在**运行前一次申请完**它所需要的全部资源，在它的**资源未满足前，不让它投入运行**。
一旦投入运行后，这些资源就一直归它所有，该进程就不会再请求别的任何资源了。

#### 该策略的缺点

该策略实现起来简单，但也有明显的缺点：
有些资源可能只需要用很短的时间，因此如果进程的整个运行期间都一直保持着所有资源，就会造成严重的资源浪费，**资源利用率极低**。
另外，该策略也有**可能导致某些进程饥饿**。

如图A类进程只需资源1即可运行，B类进程只需资源2即可运行，但C类进程需要同时拥有资源1和资源2才可运行：

<img src='\images\posts\操作系统-死锁3.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

这种情况下，可能存在A类进程和B类进程不断运行，而C类进程被饿死的情况发生。

### 破坏循环等待条件
循环等待条件：存在一种进程资源的循环等待链，链中的每一个进程已获得的资源同时被下一个进程所请求。

可采用**顺序资源分配法**。
首先给系统中的资源编号，规定**每个进程必须按编号递增的顺序请求资源**，同类资源（即编号相同的资源）一次申请完。

原理分析：一个进程只有**已占有小编号**的资源时，**才有资格申请更大编号**的资源。
按此规则，**已持有大编号资源的进程不可能逆向地回来申请小编号的资源**，从而就不会产生循环等待的现象。

Eg. 假设系统中共有10个资源，编号为1,2,...,10：

<img src='\images\posts\操作系统-死锁4.jpg'
  style="
    display: block;
    margin-left: auto;
    margin-right: auto; 
    zoom:50%;" />

在任何一个时刻，总有一个进程拥有的资源编号是最大的，那这个进程申请之后的资源必然畅通无阻。
因此,不可能出现所有进程都阻塞的死锁现象。

#### 该策略的缺点

1. 不方便增加新的设备，因为可能需要重新分配所有的编号；
2. 进程实际使用资源的顺序可能和编号递增顺序不一致，会导致资源浪费；
3. 必须按规定次序申请资源，用户编程麻烦。
