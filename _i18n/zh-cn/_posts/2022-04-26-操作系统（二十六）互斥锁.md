---
layout: post 
title: 操作系统（二十六）互斥锁
description: 进程（Process）是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。
date: 2022-04-26 09:42:34 +0800 
image: /images/covers/操作系统-cover2.png
tags:
- 操作系统
---

1. 目录
{:toc}

## 互斥锁的概念
解决临界区最简单的工具就是互斥锁（mutex lock）。
一个进程在进入临界区时应获得锁；在退出临界区时释放锁。
函数`acquire()`获得锁，而函数`release()`释放锁。

每个互斥锁有一个布尔变量`available`，表示锁是否可用。
如果锁是可用的，调用`acquire()`会成功，且锁不再可用。
当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。

```c 
acquire () {
    while (!available); // 忙等待
    available = false;  // 获得锁
}

release () {
    available = true;   // 释放锁
}
```

`acquire()`或`release()`的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。

互斥锁的主要缺点是忙等待，当有一个进程在临界区中，任何其他进程在进入临界区时必连续循环调用`acquire()`。
当多个进程共享同一CPU时，就浪费了CPU周期。
因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。

需要连续循环忙等的互斥锁（自旋等待），都可称为自旋锁（spin lock）。
如TS、swap指令；单标志、双标志法、Peterson算法。

## 互斥锁的特性
- 需忙等，进程时间片用完才下处理机，**违反“让权等待”原则**； 
- 优点：等待期间**不用切换进程上下文**，多处理器系统中，**若上锁时间短，则等待代价很低**；
- 常用于多处理器系统，一个核忙等，其他核照常工作，并快速释放临界区；
- **不太适用于单处理机系统**，忙等的过程中不可能解锁。

```c
do {
    acquire(); // 进入区
    critical section; // 临界区
    release(); // 退出区
    remainder section; // 剩余区
} while (true);
```
